# Context API - Intermediate

Now that you understand the basics of Context, let's dive deeper into patterns, composition, and performance considerations that will make you a Context pro!

<InfoBox type="tip" title="Level Up Your Context Skills">
This lesson covers context composition, custom hooks for context, and understanding when context causes re-renders.
</InfoBox>

<ProgressCheckpoint section="introduction" xpReward={15} />

## Context Composition

Real apps often need multiple contexts. You can nest them to provide different data:

```jsx
function App() {
  return (
    <ThemeProvider>
      <AuthProvider>
        <LanguageProvider>
          <Router>
            <MainContent />
          </Router>
        </LanguageProvider>
      </AuthProvider>
    </ThemeProvider>
  );
}
```

Each context is independent - components can consume any or all of them:

```jsx
function UserProfile() {
  const { theme } = useContext(ThemeContext);
  const { user } = useContext(AuthContext);
  const { language } = useContext(LanguageContext);
  
  return (
    <div className={theme}>
      <h1>{language === 'es' ? 'Hola' : 'Hello'}, {user.name}!</h1>
    </div>
  );
}
```

<ContextFlowDiagram 
  animated={true}
/>

<ProgressCheckpoint section="creating-context" xpReward={15} />

## Custom Hooks for Context

Instead of using `useContext` directly everywhere, create a custom hook:

```jsx
// contexts/ThemeContext.jsx
import { createContext, useContext, useState } from 'react';

const ThemeContext = createContext(null);

export function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light');
  
  const toggleTheme = () => {
    setTheme(t => t === 'light' ? 'dark' : 'light');
  };
  
  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}

// Custom hook with error handling!
export function useTheme() {
  const context = useContext(ThemeContext);
  
  if (context === null) {
    throw new Error('useTheme must be used within a ThemeProvider');
  }
  
  return context;
}
```

Now components have a cleaner API:

```jsx
function Header() {
  const { theme, toggleTheme } = useTheme(); // Clean!
  
  return (
    <header className={theme}>
      <button onClick={toggleTheme}>Toggle Theme</button>
    </header>
  );
}
```

<KeyConcept title="Why Custom Hooks?">
1. **Better error messages** - Catch missing providers early
2. **Cleaner imports** - One import instead of two
3. **Type safety** - Better TypeScript support
4. **Encapsulation** - Hide implementation details
</KeyConcept>

<ProgressCheckpoint section="provider-consumer" xpReward={15} />

## Understanding Re-renders

When a context value changes, ALL consumers re-render. This can cause performance issues if not handled carefully.

<RerenderTracker 
  showRenderCount={true}
  highlightOnRender={true}
/>

### The Problem

```jsx
function App() {
  const [user, setUser] = useState({ name: 'Alice', theme: 'dark' });
  
  return (
    // Every time ANY part of user changes, ALL consumers re-render!
    <UserContext.Provider value={user}>
      <Header />      {/* Re-renders even if only theme changed */}
      <ThemeToggle /> {/* Re-renders even if only name changed */}
    </UserContext.Provider>
  );
}
```

### The Solution: Split Contexts

```jsx
// Split into separate contexts
const UserContext = createContext(null);
const ThemeContext = createContext(null);

function App() {
  const [user, setUser] = useState({ name: 'Alice' });
  const [theme, setTheme] = useState('dark');
  
  return (
    <UserContext.Provider value={user}>
      <ThemeContext.Provider value={theme}>
        <Header />      {/* Only re-renders when user changes */}
        <ThemeToggle /> {/* Only re-renders when theme changes */}
      </ThemeContext.Provider>
    </UserContext.Provider>
  );
}
```

<ProgressCheckpoint section="usecontext-hook" xpReward={15} />

## Common Context Patterns

### Pattern 1: Auth Context

```jsx
const AuthContext = createContext(null);

export function AuthProvider({ children }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    // Check if user is logged in on mount
    checkAuthStatus().then(user => {
      setUser(user);
      setLoading(false);
    });
  }, []);
  
  const login = async (credentials) => {
    const user = await loginAPI(credentials);
    setUser(user);
  };
  
  const logout = () => {
    logoutAPI();
    setUser(null);
  };
  
  return (
    <AuthContext.Provider value={{ user, loading, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider');
  }
  return context;
}
```

### Pattern 2: Theme Context with Persistence

```jsx
const ThemeContext = createContext(null);

export function ThemeProvider({ children }) {
  const [theme, setTheme] = useState(() => {
    // Load from localStorage on init
    return localStorage.getItem('theme') || 'light';
  });
  
  useEffect(() => {
    // Persist to localStorage
    localStorage.setItem('theme', theme);
    // Update document class for CSS
    document.documentElement.className = theme;
  }, [theme]);
  
  const toggleTheme = () => {
    setTheme(t => t === 'light' ? 'dark' : 'light');
  };
  
  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}
```

<ProgressCheckpoint section="context-patterns" xpReward={15} />

## Interactive Example: Multi-Context App

<ReactPlayground
  initialCode={`// Multiple Contexts Working Together
const ThemeContext = React.createContext();
const UserContext = React.createContext();

function ThemeProvider({ children }) {
  const [theme, setTheme] = React.useState('light');
  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}

function UserProvider({ children }) {
  const [user, setUser] = React.useState({ name: 'Alice', role: 'admin' });
  return (
    <UserContext.Provider value={{ user, setUser }}>
      {children}
    </UserContext.Provider>
  );
}

// Custom hooks
function useTheme() {
  const ctx = React.useContext(ThemeContext);
  if (!ctx) throw new Error('useTheme requires ThemeProvider');
  return ctx;
}

function useUser() {
  const ctx = React.useContext(UserContext);
  if (!ctx) throw new Error('useUser requires UserProvider');
  return ctx;
}

// Components using contexts
function Header() {
  const { theme, setTheme } = useTheme();
  const { user } = useUser();
  
  return (
    <header style={{
      padding: '15px',
      background: theme === 'dark' ? '#1a1a2e' : '#f0f0f0',
      color: theme === 'dark' ? '#fff' : '#333',
      display: 'flex',
      justifyContent: 'space-between',
      alignItems: 'center',
      borderRadius: '8px 8px 0 0'
    }}>
      <span>Welcome, {user.name}!</span>
      <button 
        onClick={() => setTheme(t => t === 'light' ? 'dark' : 'light')}
        style={{ padding: '8px 16px', cursor: 'pointer' }}
      >
        {theme === 'light' ? 'üåô' : '‚òÄÔ∏è'}
      </button>
    </header>
  );
}

function Profile() {
  const { theme } = useTheme();
  const { user, setUser } = useUser();
  
  return (
    <div style={{
      padding: '20px',
      background: theme === 'dark' ? '#16213e' : '#fff',
      color: theme === 'dark' ? '#fff' : '#333',
    }}>
      <h3>Profile</h3>
      <p>Name: {user.name}</p>
      <p>Role: {user.role}</p>
      <input
        value={user.name}
        onChange={(e) => setUser({ ...user, name: e.target.value })}
        style={{ padding: '8px', marginTop: '10px', width: '100%' }}
        placeholder="Change name..."
      />
    </div>
  );
}

function App() {
  return (
    <ThemeProvider>
      <UserProvider>
        <div style={{ maxWidth: '400px', border: '1px solid #ddd', borderRadius: '8px' }}>
          <Header />
          <Profile />
        </div>
      </UserProvider>
    </ThemeProvider>
  );
}

render(<App />);`}
  height={380}
/>

<ProgressCheckpoint section="performance" xpReward={15} />

## Performance Tips

### 1. Memoize Context Values

```jsx
function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light');
  
  // Memoize to prevent unnecessary re-renders
  const value = useMemo(() => ({
    theme,
    toggleTheme: () => setTheme(t => t === 'light' ? 'dark' : 'light')
  }), [theme]);
  
  return (
    <ThemeContext.Provider value={value}>
      {children}
    </ThemeContext.Provider>
  );
}
```

### 2. Split State and Dispatch

```jsx
const StateContext = createContext(null);
const DispatchContext = createContext(null);

function Provider({ children }) {
  const [state, dispatch] = useReducer(reducer, initialState);
  
  return (
    <StateContext.Provider value={state}>
      <DispatchContext.Provider value={dispatch}>
        {children}
      </DispatchContext.Provider>
    </StateContext.Provider>
  );
}

// Components that only dispatch don't re-render on state changes!
function AddButton() {
  const dispatch = useContext(DispatchContext);
  return <button onClick={() => dispatch({ type: 'ADD' })}>Add</button>;
}
```

### 3. Use Context Selectors (with libraries)

For complex state, consider libraries like `use-context-selector` that allow subscribing to specific parts of context.

<ProgressCheckpoint section="summary" xpReward={10} />

## Quick Quiz

<Quiz>
  <Question text="Why should you create custom hooks for context?">
    <Answer>They make the code run faster</Answer>
    <Answer correct>Better error handling, cleaner imports, and encapsulation</Answer>
    <Answer>React requires it</Answer>
    <Answer>To avoid using useContext</Answer>
  </Question>
  
  <Question text="What happens when a context value changes?">
    <Answer>Only the Provider re-renders</Answer>
    <Answer>Nothing happens automatically</Answer>
    <Answer correct>All components consuming that context re-render</Answer>
    <Answer>Only the nearest consumer re-renders</Answer>
  </Question>
  
  <Question text="How can you prevent unnecessary re-renders with context?">
    <Answer>Use more Providers</Answer>
    <Answer correct>Split contexts and memoize values</Answer>
    <Answer>Avoid using context</Answer>
    <Answer>Use class components</Answer>
  </Question>
  
  <Question text="What's the benefit of splitting state and dispatch into separate contexts?">
    <Answer>It's required by React</Answer>
    <Answer>It makes the code shorter</Answer>
    <Answer correct>Components that only dispatch won't re-render on state changes</Answer>
    <Answer>It improves TypeScript support</Answer>
  </Question>
</Quiz>

<ProgressCheckpoint section="summary" xpReward={10} />

---

**Excellent progress!** üéâ You now understand context composition and performance patterns. In the advanced level, we'll explore optimization techniques, compound components, and when to use context vs. other state management solutions.
