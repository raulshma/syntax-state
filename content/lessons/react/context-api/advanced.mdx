# Context API - Advanced

Welcome to the advanced Context lesson! Here we'll explore sophisticated patterns, optimization techniques, and learn when Context is the right tool versus when you might need something else.

<InfoBox type="tip" title="Master-Level Context">
This lesson covers compound components, context selectors, reducer patterns, and architectural decisions for state management.
</InfoBox>

<ProgressCheckpoint section="introduction" xpReward={15} />

## Advanced Optimization Techniques

### The Re-render Problem Deep Dive

When context value changes, React re-renders ALL consumers. Let's understand why and how to optimize:

<RerenderTracker 
  showRenderCount={true}
  highlightOnRender={true}
/>

```jsx
// Problem: Object reference changes every render
function BadProvider({ children }) {
  const [count, setCount] = useState(0);
  
  // ‚ùå New object created every render!
  return (
    <MyContext.Provider value={{ count, setCount }}>
      {children}
    </MyContext.Provider>
  );
}

// Solution: Memoize the value
function GoodProvider({ children }) {
  const [count, setCount] = useState(0);
  
  // ‚úÖ Same object reference unless count changes
  const value = useMemo(() => ({ count, setCount }), [count]);
  
  return (
    <MyContext.Provider value={value}>
      {children}
    </MyContext.Provider>
  );
}
```

<ProgressCheckpoint section="creating-context" xpReward={15} />

## Compound Components Pattern

Compound components share implicit state through context, creating a clean API:

```jsx
// Usage - Clean, declarative API
<Tabs defaultValue="tab1">
  <TabsList>
    <TabsTrigger value="tab1">Tab 1</TabsTrigger>
    <TabsTrigger value="tab2">Tab 2</TabsTrigger>
  </TabsList>
  <TabsContent value="tab1">Content 1</TabsContent>
  <TabsContent value="tab2">Content 2</TabsContent>
</Tabs>
```

Implementation:

```jsx
const TabsContext = createContext(null);

function Tabs({ defaultValue, children }) {
  const [activeTab, setActiveTab] = useState(defaultValue);
  
  const value = useMemo(() => ({
    activeTab,
    setActiveTab,
  }), [activeTab]);
  
  return (
    <TabsContext.Provider value={value}>
      <div className="tabs">{children}</div>
    </TabsContext.Provider>
  );
}

function TabsList({ children }) {
  return <div className="tabs-list">{children}</div>;
}

function TabsTrigger({ value, children }) {
  const { activeTab, setActiveTab } = useContext(TabsContext);
  
  return (
    <button
      className={activeTab === value ? 'active' : ''}
      onClick={() => setActiveTab(value)}
    >
      {children}
    </button>
  );
}

function TabsContent({ value, children }) {
  const { activeTab } = useContext(TabsContext);
  
  if (activeTab !== value) return null;
  return <div className="tabs-content">{children}</div>;
}

// Attach sub-components
Tabs.List = TabsList;
Tabs.Trigger = TabsTrigger;
Tabs.Content = TabsContent;
```

<ProgressCheckpoint section="provider-consumer" xpReward={15} />

## Context with useReducer

For complex state logic, combine context with useReducer:

```jsx
const initialState = {
  items: [],
  loading: false,
  error: null,
  filter: 'all',
};

function reducer(state, action) {
  switch (action.type) {
    case 'FETCH_START':
      return { ...state, loading: true, error: null };
    case 'FETCH_SUCCESS':
      return { ...state, loading: false, items: action.payload };
    case 'FETCH_ERROR':
      return { ...state, loading: false, error: action.payload };
    case 'SET_FILTER':
      return { ...state, filter: action.payload };
    case 'ADD_ITEM':
      return { ...state, items: [...state.items, action.payload] };
    case 'REMOVE_ITEM':
      return { 
        ...state, 
        items: state.items.filter(i => i.id !== action.payload) 
      };
    default:
      return state;
  }
}

// Split contexts for optimization
const StateContext = createContext(null);
const DispatchContext = createContext(null);

function ItemsProvider({ children }) {
  const [state, dispatch] = useReducer(reducer, initialState);
  
  return (
    <StateContext.Provider value={state}>
      <DispatchContext.Provider value={dispatch}>
        {children}
      </DispatchContext.Provider>
    </StateContext.Provider>
  );
}

// Custom hooks
function useItemsState() {
  const context = useContext(StateContext);
  if (!context) throw new Error('useItemsState requires ItemsProvider');
  return context;
}

function useItemsDispatch() {
  const context = useContext(DispatchContext);
  if (!context) throw new Error('useItemsDispatch requires ItemsProvider');
  return context;
}

// Combined hook for convenience
function useItems() {
  return [useItemsState(), useItemsDispatch()];
}
```

<ProgressCheckpoint section="usecontext-hook" xpReward={15} />

## Interactive: Advanced Context Patterns

<ReactPlayground
  initialCode={`// Compound Component Pattern with Context
const AccordionContext = React.createContext();

function Accordion({ children, allowMultiple = false }) {
  const [openItems, setOpenItems] = React.useState(new Set());
  
  const toggle = React.useCallback((id) => {
    setOpenItems(prev => {
      const next = new Set(prev);
      if (next.has(id)) {
        next.delete(id);
      } else {
        if (!allowMultiple) next.clear();
        next.add(id);
      }
      return next;
    });
  }, [allowMultiple]);
  
  const value = React.useMemo(() => ({
    openItems,
    toggle,
  }), [openItems, toggle]);
  
  return (
    <AccordionContext.Provider value={value}>
      <div style={{ border: '1px solid #ddd', borderRadius: '8px', overflow: 'hidden' }}>
        {children}
      </div>
    </AccordionContext.Provider>
  );
}

function AccordionItem({ id, title, children }) {
  const { openItems, toggle } = React.useContext(AccordionContext);
  const isOpen = openItems.has(id);
  
  return (
    <div style={{ borderBottom: '1px solid #ddd' }}>
      <button
        onClick={() => toggle(id)}
        style={{
          width: '100%',
          padding: '15px',
          textAlign: 'left',
          background: isOpen ? '#f0f0f0' : '#fff',
          border: 'none',
          cursor: 'pointer',
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
          fontSize: '16px',
          fontWeight: '500'
        }}
      >
        {title}
        <span style={{ 
          transform: isOpen ? 'rotate(180deg)' : 'rotate(0)',
          transition: 'transform 0.2s'
        }}>
          ‚ñº
        </span>
      </button>
      {isOpen && (
        <div style={{ padding: '15px', background: '#fafafa' }}>
          {children}
        </div>
      )}
    </div>
  );
}

function App() {
  return (
    <div style={{ maxWidth: '500px', padding: '20px' }}>
      <h3>Compound Component: Accordion</h3>
      <p style={{ color: '#666', marginBottom: '15px' }}>
        Click items to expand. Only one can be open at a time.
      </p>
      
      <Accordion>
        <AccordionItem id="1" title="What is React Context?">
          Context provides a way to pass data through the component tree 
          without having to pass props down manually at every level.
        </AccordionItem>
        <AccordionItem id="2" title="When should I use Context?">
          Use Context for data that needs to be accessible by many components 
          at different nesting levels, like themes, user data, or locale.
        </AccordionItem>
        <AccordionItem id="3" title="What about performance?">
          Context consumers re-render when the context value changes. 
          Split contexts and memoize values to optimize performance.
        </AccordionItem>
      </Accordion>
    </div>
  );
}

render(<App />);`}
  height={450}
/>

<ProgressCheckpoint section="context-patterns" xpReward={15} />

## Context Selectors Pattern

React doesn't have built-in selectors, but you can implement them:

```jsx
// Using a subscription pattern
function createContextWithSelectors(defaultValue) {
  const Context = createContext(null);
  
  function Provider({ value, children }) {
    const storeRef = useRef(value);
    const subscribersRef = useRef(new Set());
    
    // Update store and notify subscribers
    useEffect(() => {
      storeRef.current = value;
      subscribersRef.current.forEach(callback => callback(value));
    }, [value]);
    
    const contextValue = useMemo(() => ({
      getState: () => storeRef.current,
      subscribe: (callback) => {
        subscribersRef.current.add(callback);
        return () => subscribersRef.current.delete(callback);
      },
    }), []);
    
    return (
      <Context.Provider value={contextValue}>
        {children}
      </Context.Provider>
    );
  }
  
  function useSelector(selector) {
    const { getState, subscribe } = useContext(Context);
    const [selectedState, setSelectedState] = useState(() => 
      selector(getState())
    );
    
    useEffect(() => {
      return subscribe((state) => {
        const newSelected = selector(state);
        setSelectedState(prev => {
          // Only update if selected value changed
          if (Object.is(prev, newSelected)) return prev;
          return newSelected;
        });
      });
    }, [selector, subscribe]);
    
    return selectedState;
  }
  
  return { Provider, useSelector };
}

// Usage
const { Provider: StoreProvider, useSelector } = createContextWithSelectors();

function UserName() {
  // Only re-renders when user.name changes!
  const name = useSelector(state => state.user.name);
  return <span>{name}</span>;
}
```

<ProgressCheckpoint section="performance" xpReward={15} />

## When NOT to Use Context

Context isn't always the answer. Consider alternatives:

### 1. Component Composition

```jsx
// Instead of context for passing components...
// ‚ùå Using context
<LayoutContext.Provider value={{ sidebar: <Sidebar /> }}>
  <Layout />
</LayoutContext.Provider>

// ‚úÖ Use composition
<Layout sidebar={<Sidebar />}>
  <MainContent />
</Layout>
```

### 2. Server State (React Query, SWR)

```jsx
// ‚ùå Context for server data
const DataContext = createContext();
function DataProvider({ children }) {
  const [data, setData] = useState(null);
  useEffect(() => {
    fetch('/api/data').then(r => r.json()).then(setData);
  }, []);
  return <DataContext.Provider value={data}>{children}</DataContext.Provider>;
}

// ‚úÖ Use React Query
function useData() {
  return useQuery(['data'], () => fetch('/api/data').then(r => r.json()));
}
```

### 3. Complex Global State (Zustand, Redux)

For complex state with many updates, dedicated state management libraries offer better performance and developer experience.

<KeyConcept title="Context vs. State Management Libraries">
- **Context**: Great for low-frequency updates (theme, auth, locale)
- **Zustand/Jotai**: Better for frequent updates with selectors
- **Redux**: Best for complex state with time-travel debugging needs
- **React Query/SWR**: Ideal for server state
</KeyConcept>

<ProgressCheckpoint section="summary" xpReward={10} />

## Best Practices Summary

1. **Create custom hooks** for every context
2. **Memoize context values** with useMemo
3. **Split contexts** by update frequency
4. **Separate state and dispatch** for reducer patterns
5. **Use compound components** for related UI elements
6. **Consider alternatives** for server state or complex updates

## Quick Quiz

<Quiz>
  <Question text="What is the compound components pattern?">
    <Answer>Using multiple Providers together</Answer>
    <Answer correct>Components that share implicit state through context for a clean API</Answer>
    <Answer>Combining useState and useReducer</Answer>
    <Answer>Nesting contexts deeply</Answer>
  </Question>
  
  <Question text="Why split state and dispatch into separate contexts?">
    <Answer>It's required by React</Answer>
    <Answer>To make TypeScript work</Answer>
    <Answer correct>Components that only dispatch won't re-render on state changes</Answer>
    <Answer>To reduce bundle size</Answer>
  </Question>
  
  <Question text="When should you NOT use Context?">
    <Answer>For theme switching</Answer>
    <Answer>For user authentication</Answer>
    <Answer correct>For frequently updating server data (use React Query instead)</Answer>
    <Answer>For locale/language settings</Answer>
  </Question>
  
  <Question text="How do you prevent context value reference changes?">
    <Answer>Use useCallback</Answer>
    <Answer correct>Wrap the value object in useMemo</Answer>
    <Answer>Use useRef</Answer>
    <Answer>Use useState</Answer>
  </Question>
</Quiz>

<ProgressCheckpoint section="summary" xpReward={10} />

---

**Congratulations!** üéâ You've mastered React Context! You now understand advanced patterns like compound components, optimization techniques, and when to choose Context versus other state management solutions. Apply these patterns to build scalable, performant React applications!
