# Server Components Basics

Welcome to the advanced level! Let's explore the internals of React Server Components, streaming architecture, server actions, and optimization strategies. 

<ProgressCheckpoint section="introduction" xpReward={15} />

## RSC Architecture Deep Dive

React Server Components introduce a new rendering paradigm. Let's understand how it works under the hood.

### The RSC Payload

When a Server Component renders, React doesn't send HTML directly. It sends a special format called the **RSC Payload** - a serialized representation of the component tree.

```
// Simplified RSC Payload structure
{
  "type": "div",
  "props": {
    "children": [
      {
        "type": "h1",
        "props": { "children": "Hello World" }
      },
      {
        "$$typeof": "client.reference",
        "id": "./components/Counter.tsx",
        "props": { "initialCount": 0 }
      }
    ]
  }
}
```

<KeyConcept title="RSC Payload vs HTML">
The RSC Payload is NOT HTML. It's a tree structure that React on the client can reconcile with. This enables features like preserving client state during navigation!
</KeyConcept>

<ServerClientBoundaryVisualizer 
  showDataFlow={true}
  animated={true}
/>

<ProgressCheckpoint section="server-vs-client" xpReward={15} />

## The Module Graph

Understanding how React resolves Server vs Client Components requires understanding the module graph:

```
// Module resolution flow
app/page.tsx (Server)
  └── components/Header.tsx (Server)
       └── components/Logo.tsx (Server)
       └── components/Nav.tsx (Client - 'use client')
            └── components/NavItem.tsx (Client - inherited)
            └── components/Dropdown.tsx (Client - inherited)
  └── components/Content.tsx (Server)
       └── components/Article.tsx (Server)
       └── components/Comments.tsx (Client - 'use client')
```

<InfoBox type="info" title="Boundary Propagation">
The `'use client'` directive creates a boundary. All modules imported by a Client Component are bundled for the client, even if they don't have the directive.
</InfoBox>

### Optimizing the Boundary

```jsx
// ❌ Bad: Large client boundary
'use client';
import { HeavyLibrary } from 'heavy-library';
import { AnotherLib } from 'another-lib';

export function InteractiveWidget() {
  // All imports are now client-side
}

// ✅ Good: Minimal client boundary
// InteractiveWidget.tsx
'use client';
import { useState } from 'react';

export function InteractiveWidget({ data }) {
  const [state, setState] = useState(data);
  // Only essential client code
}

// Page.tsx (Server)
import { processData } from 'heavy-library';  // Stays on server!
import { InteractiveWidget } from './InteractiveWidget';

export default async function Page() {
  const data = await processData();  // Heavy work on server
  return <InteractiveWidget data={data} />;
}
```

<ProgressCheckpoint section="use-client-directive" xpReward={15} />

## Streaming Architecture

Streaming is one of the most powerful features of RSC. Let's understand how it works:

<ServerDataFlowDiagram 
  showStreaming={true}
  showSuspense={true}
  animated={true}
/>

### How Streaming Works

1. **Initial Shell**: React sends the synchronous parts immediately
2. **Suspense Boundaries**: Mark where async content will appear
3. **Streaming Chunks**: As promises resolve, React streams replacement HTML
4. **Client Reconciliation**: React swaps placeholders with real content

```jsx
// The streaming flow
async function Page() {
  return (
    <html>
      <body>
        {/* Sent immediately */}
        <Header />
        
        {/* Placeholder sent, content streams later */}
        <Suspense fallback={<Skeleton />}>
          <SlowComponent />
        </Suspense>
        
        {/* Sent immediately */}
        <Footer />
      </body>
    </html>
  );
}
```

### Nested Suspense for Progressive Loading

```jsx
async function Dashboard() {
  return (
    <div className="grid grid-cols-3 gap-4">
      {/* Fast data - loads first */}
      <Suspense fallback={<CardSkeleton />}>
        <UserCard />
      </Suspense>
      
      {/* Medium speed - loads second */}
      <Suspense fallback={<CardSkeleton />}>
        <StatsCard />
      </Suspense>
      
      {/* Slow data - loads last */}
      <Suspense fallback={<CardSkeleton />}>
        <AnalyticsCard />
      </Suspense>
    </div>
  );
}
```

<KeyConcept title="Independent Streaming">
Each Suspense boundary streams independently. Fast queries don't wait for slow ones. Users see content progressively!
</KeyConcept>

<ProgressCheckpoint section="data-fetching" xpReward={15} />

## Server Actions In Depth

Server Actions are functions that run on the server but can be called from the client. They're the mutation counterpart to Server Components.

### Defining Server Actions

```jsx
// app/actions.ts
'use server';

import { revalidatePath, revalidateTag } from 'next/cache';
import { redirect } from 'next/navigation';

export async function createPost(formData: FormData) {
  // Validate input
  const title = formData.get('title') as string;
  const content = formData.get('content') as string;
  
  if (!title || title.length < 3) {
    return { error: 'Title must be at least 3 characters' };
  }
  
  // Database operation
  const post = await prisma.post.create({
    data: { title, content, authorId: getCurrentUserId() },
  });
  
  // Revalidate cached data
  revalidateTag('posts');
  revalidatePath('/posts');
  
  // Redirect to new post
  redirect(`/posts/${post.id}`);
}
```

### Using Server Actions

```jsx
// Form action (progressive enhancement)
'use client';

import { useFormStatus, useFormState } from 'react-dom';
import { createPost } from './actions';

function SubmitButton() {
  const { pending } = useFormStatus();
  return (
    <button disabled={pending}>
      {pending ? 'Creating...' : 'Create Post'}
    </button>
  );
}

export function CreatePostForm() {
  const [state, formAction] = useFormState(createPost, null);
  
  return (
    <form action={formAction}>
      <input name="title" required />
      <textarea name="content" required />
      {state?.error && <p className="error">{state.error}</p>}
      <SubmitButton />
    </form>
  );
}
```

### Server Actions with useTransition

```jsx
'use client';

import { useTransition } from 'react';
import { deletePost } from './actions';

export function DeleteButton({ postId }) {
  const [isPending, startTransition] = useTransition();
  
  const handleDelete = () => {
    startTransition(async () => {
      await deletePost(postId);
    });
  };
  
  return (
    <button onClick={handleDelete} disabled={isPending}>
      {isPending ? 'Deleting...' : 'Delete'}
    </button>
  );
}
```

<ProgressCheckpoint section="streaming" xpReward={15} />

## Performance Optimization

### 1. Minimize Client Components

```jsx
// ❌ Entire component is client
'use client';
export function ProductPage({ product }) {
  const [quantity, setQuantity] = useState(1);
  return (
    <div>
      <h1>{product.name}</h1>
      <p>{product.description}</p>
      <img src={product.image} />
      <QuantitySelector value={quantity} onChange={setQuantity} />
    </div>
  );
}

// ✅ Only interactive part is client
// ProductPage.tsx (Server)
export function ProductPage({ product }) {
  return (
    <div>
      <h1>{product.name}</h1>
      <p>{product.description}</p>
      <img src={product.image} />
      <QuantitySelector productId={product.id} />
    </div>
  );
}

// QuantitySelector.tsx (Client)
'use client';
export function QuantitySelector({ productId }) {
  const [quantity, setQuantity] = useState(1);
  return <input type="number" value={quantity} onChange={...} />;
}
```

### 2. Preload Data

```jsx
import { preload } from 'react-dom';

async function Page() {
  // Preload critical resources
  preload('/api/user', { as: 'fetch' });
  preload('/fonts/inter.woff2', { as: 'font' });
  
  const user = await getUser();
  return <Dashboard user={user} />;
}
```

### 3. Cache Expensive Operations

```jsx
import { cache } from 'react';
import { unstable_cache } from 'next/cache';

// Request-level cache (deduplication)
const getUser = cache(async (id: string) => {
  return await prisma.user.findUnique({ where: { id } });
});

// Cross-request cache (persistent)
const getPopularPosts = unstable_cache(
  async () => {
    return await prisma.post.findMany({
      orderBy: { views: 'desc' },
      take: 10,
    });
  },
  ['popular-posts'],
  { revalidate: 3600 }  // 1 hour
);
```

<ProgressCheckpoint section="server-actions" xpReward={15} />

## Common Patterns

### Pattern: Optimistic Updates

```jsx
'use client';

import { useOptimistic } from 'react';
import { likePost } from './actions';

export function LikeButton({ postId, initialLikes }) {
  const [optimisticLikes, addOptimisticLike] = useOptimistic(
    initialLikes,
    (state, newLike) => state + 1
  );
  
  const handleLike = async () => {
    addOptimisticLike(1);  // Update UI immediately
    await likePost(postId);  // Server action
  };
  
  return (
    <button onClick={handleLike}>
      ❤️ {optimisticLikes}
    </button>
  );
}
```

### Pattern: Error Boundaries for Server Components

```jsx
// error.tsx (must be Client Component)
'use client';

export default function Error({ error, reset }) {
  return (
    <div>
      <h2>Something went wrong!</h2>
      <p>{error.message}</p>
      <button onClick={reset}>Try again</button>
    </div>
  );
}

// layout.tsx
export default function Layout({ children }) {
  return (
    <ErrorBoundary fallback={<Error />}>
      {children}
    </ErrorBoundary>
  );
}
```

<ComponentTypeSelector showExplanations={true} />

## Quick Quiz

<Quiz>
  <Question text="What is the RSC Payload?">
    <Answer>Raw HTML sent to the browser</Answer>
    <Answer correct>A serialized representation of the component tree</Answer>
    <Answer>Compressed JavaScript code</Answer>
    <Answer>CSS styles for server components</Answer>
  </Question>
  
  <Question text="How does streaming improve performance?">
    <Answer>By compressing the response</Answer>
    <Answer>By caching all components</Answer>
    <Answer correct>By sending content progressively as it becomes available</Answer>
    <Answer>By running components in parallel</Answer>
  </Question>
  
  <Question text="What does 'use server' do at the top of a file?">
    <Answer>Makes all components Server Components</Answer>
    <Answer correct>Marks exported functions as Server Actions</Answer>
    <Answer>Enables server-side rendering</Answer>
    <Answer>Disables client-side JavaScript</Answer>
  </Question>
  
  <Question text="Why should you minimize the client boundary?">
    <Answer>To reduce server load</Answer>
    <Answer correct>To reduce JavaScript sent to the browser</Answer>
    <Answer>To improve SEO</Answer>
    <Answer>To enable caching</Answer>
  </Question>
</Quiz>

<ProgressCheckpoint section="summary" xpReward={10} />

---

**Outstanding work!**  You now have a deep understanding of React Server Components architecture, streaming, server actions, and optimization strategies. 

Key takeaways:
- RSC uses a special payload format, not just HTML
- Streaming enables progressive loading with Suspense
- Server Actions provide type-safe mutations
- Minimize client boundaries for better performance
- Use caching strategically for expensive operations

You're now equipped to build high-performance React applications with the latest patterns!
