# Forms in React - Intermediate

Now that you understand controlled components, let's dive into more advanced form patterns: validation, handling multiple inputs efficiently, and an introduction to form libraries.

<InfoBox type="info" title="What You'll Learn">
- Real-time form validation
- Managing multiple inputs with a single handler
- Form state patterns
- Introduction to form libraries
</InfoBox>

<ProgressCheckpoint section="introduction" xpReward={20} />

## Real-Time Validation

One of the biggest advantages of controlled components is the ability to validate input as the user types. Let's build a validation system:

```jsx
function SignupForm() {
  const [email, setEmail] = useState('');
  const [errors, setErrors] = useState({});
  
  const validateEmail = (value) => {
    if (!value) return 'Email is required';
    if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value)) {
      return 'Please enter a valid email';
    }
    return '';  // No error
  };
  
  const handleEmailChange = (e) => {
    const value = e.target.value;
    setEmail(value);
    setErrors(prev => ({
      ...prev,
      email: validateEmail(value)
    }));
  };
  
  return (
    <div>
      <input
        type="email"
        value={email}
        onChange={handleEmailChange}
        className={errors.email ? 'error' : ''}
      />
      {errors.email && <span className="error-text">{errors.email}</span>}
    </div>
  );
}
```

<ValidationPlayground 
  showCode={true}
/>

<ProgressCheckpoint section="controlled-components" xpReward={20} />

## Managing Multiple Inputs

Instead of creating separate state and handlers for each input, use a single state object and a generic handler:

```jsx
function ProfileForm() {
  const [formData, setFormData] = useState({
    firstName: '',
    lastName: '',
    email: '',
    phone: ''
  });
  
  // One handler for all inputs!
  const handleChange = (e) => {
    const { name, value, type, checked } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: type === 'checkbox' ? checked : value
    }));
  };
  
  return (
    <form>
      <input name="firstName" value={formData.firstName} onChange={handleChange} />
      <input name="lastName" value={formData.lastName} onChange={handleChange} />
      <input name="email" value={formData.email} onChange={handleChange} />
      <input name="phone" value={formData.phone} onChange={handleChange} />
    </form>
  );
}
```

<KeyConcept title="The [name] Pattern">
Using `[name]: value` (computed property name) lets us update any field dynamically based on the input's name attribute.
</KeyConcept>

<ReactPlayground
  initialCode={`function RegistrationForm() {
  const [formData, setFormData] = React.useState({
    username: '',
    email: '',
    password: '',
    confirmPassword: '',
    agreeToTerms: false
  });
  
  const [errors, setErrors] = React.useState({});
  const [touched, setTouched] = React.useState({});
  
  // Validation rules
  const validate = (name, value, allData) => {
    switch (name) {
      case 'username':
        if (!value) return 'Username is required';
        if (value.length < 3) return 'Username must be at least 3 characters';
        return '';
      case 'email':
        if (!value) return 'Email is required';
        if (!/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(value)) return 'Invalid email';
        return '';
      case 'password':
        if (!value) return 'Password is required';
        if (value.length < 8) return 'Password must be at least 8 characters';
        return '';
      case 'confirmPassword':
        if (!value) return 'Please confirm your password';
        if (value !== allData.password) return 'Passwords do not match';
        return '';
      case 'agreeToTerms':
        if (!value) return 'You must agree to the terms';
        return '';
      default:
        return '';
    }
  };
  
  // Generic change handler
  const handleChange = (e) => {
    const { name, value, type, checked } = e.target;
    const newValue = type === 'checkbox' ? checked : value;
    
    const newFormData = { ...formData, [name]: newValue };
    setFormData(newFormData);
    
    // Validate on change
    setErrors(prev => ({
      ...prev,
      [name]: validate(name, newValue, newFormData)
    }));
  };
  
  // Mark field as touched on blur
  const handleBlur = (e) => {
    const { name } = e.target;
    setTouched(prev => ({ ...prev, [name]: true }));
  };
  
  // Check if form is valid
  const isValid = Object.values(errors).every(e => !e) && 
                  formData.username && formData.email && 
                  formData.password && formData.confirmPassword &&
                  formData.agreeToTerms;
  
  const handleSubmit = (e) => {
    e.preventDefault();
    // Mark all as touched
    setTouched({
      username: true, email: true, password: true, 
      confirmPassword: true, agreeToTerms: true
    });
    
    if (isValid) {
      alert('Form submitted successfully!');
    }
  };
  
  const inputStyle = (name) => ({
    width: '100%',
    padding: '10px',
    borderRadius: '6px',
    border: touched[name] && errors[name] ? '2px solid #ef4444' : '1px solid #ddd',
    marginBottom: '4px'
  });
  
  return (
    <form onSubmit={handleSubmit} style={{ padding: '20px', maxWidth: '350px' }}>
      <h3>Create Account</h3>
      
      {['username', 'email', 'password', 'confirmPassword'].map(field => (
        <div key={field} style={{ marginBottom: '15px' }}>
          <label style={{ display: 'block', marginBottom: '5px', textTransform: 'capitalize' }}>
            {field.replace(/([A-Z])/g, ' $1').trim()}
          </label>
          <input
            type={field.includes('password') || field.includes('Password') ? 'password' : field === 'email' ? 'email' : 'text'}
            name={field}
            value={formData[field]}
            onChange={handleChange}
            onBlur={handleBlur}
            style={inputStyle(field)}
          />
          {touched[field] && errors[field] && (
            <span style={{ color: '#ef4444', fontSize: '12px' }}>{errors[field]}</span>
          )}
        </div>
      ))}
      
      <div style={{ marginBottom: '15px' }}>
        <label style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
          <input
            type="checkbox"
            name="agreeToTerms"
            checked={formData.agreeToTerms}
            onChange={handleChange}
            onBlur={handleBlur}
          />
          I agree to the terms and conditions
        </label>
        {touched.agreeToTerms && errors.agreeToTerms && (
          <span style={{ color: '#ef4444', fontSize: '12px', display: 'block', marginTop: '4px' }}>
            {errors.agreeToTerms}
          </span>
        )}
      </div>
      
      <button
        type="submit"
        disabled={!isValid}
        style={{
          width: '100%',
          padding: '12px',
          background: isValid ? '#22c55e' : '#ccc',
          color: 'white',
          border: 'none',
          borderRadius: '8px',
          cursor: isValid ? 'pointer' : 'not-allowed'
        }}
      >
        {isValid ? 'Create Account' : 'Fill all fields correctly'}
      </button>
    </form>
  );
}

render(<RegistrationForm />);`}
  height={550}
/>

<ProgressCheckpoint section="form-inputs" xpReward={20} />

## Validation Patterns

There are several approaches to form validation:

### 1. Validate on Change (Real-time)
```jsx
const handleChange = (e) => {
  const { name, value } = e.target;
  setFormData(prev => ({ ...prev, [name]: value }));
  setErrors(prev => ({ ...prev, [name]: validate(name, value) }));
};
```

### 2. Validate on Blur (When leaving field)
```jsx
const handleBlur = (e) => {
  const { name, value } = e.target;
  setErrors(prev => ({ ...prev, [name]: validate(name, value) }));
};
```

### 3. Validate on Submit
```jsx
const handleSubmit = (e) => {
  e.preventDefault();
  const newErrors = {};
  Object.keys(formData).forEach(key => {
    newErrors[key] = validate(key, formData[key]);
  });
  setErrors(newErrors);
  
  if (Object.values(newErrors).every(e => !e)) {
    // Submit form
  }
};
```

<KeyConcept title="Best Practice: Combine Approaches">
Show errors on blur (not while typing), validate on change after first blur, and always validate on submit.
</KeyConcept>

<ProgressCheckpoint section="validation" xpReward={20} />

## Controlled vs Uncontrolled: When to Use Each

<ControlledVsUncontrolledDemo 
  showCode={true}
/>

### Use Controlled Components When:
- You need instant validation
- You need to conditionally disable the submit button
- You need to format input (e.g., phone numbers, credit cards)
- Multiple inputs depend on each other

### Use Uncontrolled Components When:
- Building simple forms without validation
- Working with file inputs (always uncontrolled)
- Integrating with non-React code
- Performance is critical (rare)

<ProgressCheckpoint section="form-submission" xpReward={15} />

## Introduction to Form Libraries

For complex forms, consider using a form library. Here's a comparison:

| Library | Best For | Key Features |
|---------|----------|--------------|
| **React Hook Form** | Performance | Minimal re-renders, easy validation |
| **Formik** | Complex forms | Built-in validation, field arrays |
| **Zod + React Hook Form** | Type safety | Schema validation, TypeScript |

### React Hook Form Example

```jsx
import { useForm } from 'react-hook-form';

function MyForm() {
  const { register, handleSubmit, formState: { errors } } = useForm();
  
  const onSubmit = (data) => console.log(data);
  
  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input {...register('email', { required: 'Email is required' })} />
      {errors.email && <span>{errors.email.message}</span>}
      
      <input {...register('password', { minLength: 8 })} type="password" />
      {errors.password && <span>Password must be 8+ characters</span>}
      
      <button type="submit">Submit</button>
    </form>
  );
}
```

<KeyConcept title="When to Use a Library">
If your form has more than 5-6 fields, complex validation, or dynamic fields, a form library will save you time and reduce bugs.
</KeyConcept>

<ProgressCheckpoint section="form-libraries" xpReward={15} />

## Quick Quiz

<Quiz>
  <Question text="What's the advantage of using [name]: value in your change handler?">
    <Answer>It's faster</Answer>
    <Answer correct>It lets you handle all inputs with one handler</Answer>
    <Answer>It provides better validation</Answer>
    <Answer>It's required by React</Answer>
  </Question>
  
  <Question text="When should you show validation errors to the user?">
    <Answer>Immediately as they type</Answer>
    <Answer correct>After they leave the field (on blur) or on submit</Answer>
    <Answer>Only on form submission</Answer>
    <Answer>Never, let the server validate</Answer>
  </Question>
  
  <Question text="What's the main benefit of form libraries like React Hook Form?">
    <Answer>They're required for forms to work</Answer>
    <Answer>They make forms look better</Answer>
    <Answer correct>They reduce boilerplate and improve performance</Answer>
    <Answer>They replace React state entirely</Answer>
  </Question>
  
  <Question text="Which input type is always uncontrolled in React?">
    <Answer>text</Answer>
    <Answer>checkbox</Answer>
    <Answer correct>file</Answer>
    <Answer>select</Answer>
  </Question>
  
  <Question text="What does 'touched' mean in form validation?">
    <Answer>The input has a value</Answer>
    <Answer correct>The user has interacted with and left the field</Answer>
    <Answer>The input is focused</Answer>
    <Answer>The input has an error</Answer>
  </Question>
</Quiz>

<ProgressCheckpoint section="summary" xpReward={10} />

---

**Excellent progress!**  You've learned how to build robust forms with validation. In the advanced level, we'll explore refs for uncontrolled components, complex validation schemas, and accessibility best practices.
