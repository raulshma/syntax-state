# Blazor Hosting Models: Architecture Deep Dive

Understanding the architectural differences between Blazor Server and WebAssembly is crucial for making informed decisions about which hosting model to use for your application.

## Blazor Server Architecture

### Connection-Based Architecture

Blazor Server maintains a **persistent SignalR connection** between the browser and server. This connection is called a **circuit**.

```csharp
// On the server, each client has a circuit
public class BlazorCircuit
{
    public string ConnectionId { get; set; }
    public ComponentState State { get; set; }
    public DateTime Created { get; set; }
}
```

### How It Works

1. **Initial Request**: Browser requests the Blazor app
2. **Server Response**: Server sends minimal HTML + Blazor JavaScript
3. **SignalR Connection**: JavaScript establishes WebSocket connection
4. **Event Flow**:
   ```
   User clicks button
     â†“
   Browser sends event via SignalR
     â†“
   Server processes in C#
     â†“
   Server calculates UI diff
     â†“
   Server sends diff via SignalR
     â†“
   Browser updates DOM
   ```

### Circuit Lifecycle

```csharp
// Circuit states
public enum CircuitState
{
    Connected,      // Active connection
    Disconnected,   // Network issue
    Reconnecting,   // Attempting reconnect
    Disposed        // User closed tab
}
```

**Default Timeouts:**
- Disconnection grace period: **90 seconds**
- Reconnection attempts: **8 tries**
- Maximum retained circuits: **100**

### Benefits & Limitations

**Benefits:**
-  Fast initial load (< 500KB typically)
-  Server-side code protection
- ï¸ Full .NET API access
-  Thin client requirements

**Limitations:**
-  Requires constant connection
- ï¸ Higher latency (network round-trips)
-  Server resources scale with user count
-  No offline capability

<BlazorHostingVisualizer mode="server-detailed" />

## Blazor WebAssembly Architecture

### Download-and-Run Architecture

Blazor WebAssembly downloads the **.NET runtime compiled to WebAssembly** along with your app DLLs.

### Initial Download Breakdown

Typical Blazor WASM app size:
```
Component                    Size
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
.NET Runtime (dotnet.wasm)   ~2.5 MB
System libraries             ~1.5 MB
Your app DLLs                ~500 KB
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Total (gzipped)              ~4.5 MB
```

### Execution Flow

```
Browser starts
  â†“
Downloads blazor.webassembly.js
  â†“
Downloads .NET runtime (dotnet.wasm)
  â†“
Initializes WebAssembly runtime
  â†“
Loads app assemblies (YourApp.dll)
  â†“
Boots .NET runtime in browser
  â†“
Starts Blazor app
  â†“
All C# code runs client-side!
```

### Optimization Techniques

#### 1. Ahead-of-Time (AOT) Compilation

```xml
<!-- YourApp.csproj -->
<PropertyGroup>
  <RunAOTCompilation>true</RunAOTCompilation>
</PropertyGroup>
```

**Impact:**
- Compile C# â†’ WebAssembly ahead of time
- Runtime performance: **+30-50%**
- Download size: **+2-3 MB** (trade-off)

#### 2. IL Trimming

```xml
<PropertyGroup>
  <PublishTrimmed>true</PublishTrimmed>
  <TrimMode>full</TrimMode>
</PropertyGroup>
```

Removes unused code from assemblies.

#### 3. Lazy Loading

```csharp
// Router.razor
<Router AppAssembly="@typeof(App).Assembly"
        AdditionalAssemblies="@lazyLoadedAssemblies">
    ...
</Router>

@code {
    private List<Assembly> lazyLoadedAssemblies = new();
    
    async Task OnNavigateAsync(NavigationContext context)
    {
        if (context.Path.Contains("admin"))
        {
            var assemblies = await LazyLoader
                .LoadAssembliesAsync(new[] { "Admin.dll" });
            lazyLoadedAssemblies.AddRange(assemblies);
        }
    }
}
```

### Benefits & Limitations

**Benefits:**
-  Zero latency after load
-  Offline capable (with PWA)
-  Scales infinitely (CDN hosting)
-  Minimal server costs

**Limitations:**
-  Slower initial load
- ï¸ Code visible in browser
-  Limited to browser APIs
-  Larger download size

## Performance Comparison

### Real-World Metrics

| Metric | Blazor Server | Blazor WASM |
|:-------|:-------------|:-----------|
| **Initial load** | 300-500ms | 2-4 seconds |
| **Click response** | 50-200ms | 1-5ms |
| **Data fetch** | Fast (server-side) | Depends on API |
| **UI updates** | Network limited | Instant |
| **Memory (client)** | ~5 MB | ~50-100 MB |
| **Memory (server)** | ~500 KB/user | N/A |

### Latency Impact Example

```csharp
// Button click on Blazor Server
User clicks (0ms)
  â†’ Network send (25ms)
  â†’ Server process (2ms)
  â†’ Network return (25ms)
  â†’ DOM update (3ms)
Total: ~55ms âš¡

// Button click on Blazor WASM
User clicks (0ms)
  â†’ In-browser process (2ms)
  â†’ DOM update (3ms)
Total: ~5ms ğŸš€
```

## Choosing Based on Requirements

### Decision Matrix

```
Need offline? 
  Yes â†’ WASM
  No â†’ Continue

Sensitive code?
  Yes â†’ Server
  No â†’ Continue

High interactivity?
  Yes â†’ WASM
  No â†’ Continue

Many concurrent users?
  Yes â†’ WASM
  No â†’ Server
```

### Hybrid Strategy (.NET 8+)

Modern Blazor apps can mix both:

```csharp
// Public pages: Server (fast load)
@page "/"
@rendermode InteractiveServer

// Interactive features: WASM (low latency)
@page "/editor"
@rendermode InteractiveWebAssembly

// Static content: Static SSR (no interactivity needed)
@page "/about"
// No render mode = static
```

**Progressive Enhancement:**
1. Start with Server rendering (fast)
2. Download WASM runtime in background
3. Switch to WASM when ready
4. Best user experience! 

## Architecture Patterns

### Server Pattern: Hub Architecture

```csharp
public class DataService
{
    // Singleton on server, shared by all users
    public async Task<List<Product>> GetProducts()
    {
        // Direct database access
        return await _dbContext.Products.ToListAsync();
    }
}
```

### WASM Pattern: API-Driven Architecture

```csharp
public class DataService
{
    private readonly HttpClient _http;
    
    // Scoped per user in browser
    public async Task<List<Product>> GetProducts()
    {
        // Must call Web API
        return await _http
            .GetFromJsonAsync<List<Product>>("/api/products");
    }
}
```

<ProgressCheckpoint section="blazor-webassembly-architecture" xpReward={40} />

## Summary

| Aspect | Server | WebAssembly |
|:-------|:-------|:-----------|
| **Architecture** | Thin client + stateful server | Thick client + stateless APIs |
| **Communication** | SignalR (WebSockets) | HTTP/REST APIs |
| **State** | Server-managed circuits | Client-managed memory |
| **Scaling** | Vertical (more server power) | Horizontal (CDN + APIs) |
| **Best for** | Enterprise apps, LOB apps | Public apps, SPAs, PWAs |

The choice isn't always binaryâ€”.NET 8+ allows mixing both for optimal results! 

<ProgressCheckpoint section="choosing-hosting-model" xpReward={40} />
