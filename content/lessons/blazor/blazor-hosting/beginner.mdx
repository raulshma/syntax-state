# Blazor Hosting: Server or WebAssembly? 

Imagine you're ordering a pizza. You have two options:

> ** Dine-in (Blazor Server)**: The chef cooks in the kitchen, and servers bring you slices as you order them. You stay connected to the restaurant the whole time.

> ** Takeout (Blazor WebAssembly)**: You get the whole pizza to take home. Once you have it, you can eat it anywhere, even if the restaurant closes!

That's the essence of Blazor's two hosting models! Both let you build web apps with C#, but they work very differently.

## What is Blazor?

Blazor is Microsoft's framework for building **interactive web UIs using C# instead of JavaScript**. You write your frontend code in C#, and Blazor handles the rest!

```csharp
// Yes, this is C# running in a web browser! ğŸ‰
<button @onclick="IncrementCount">Click me</button>

@code {
    private int count = 0;

    void IncrementCount() {
        count++;  // C# in the browser!
    }
}
```

## The Two Hosting Models

###  Blazor Server: "Stay Connected"

Think of it like a **video game streaming service** (like Google Stadia):

- Your code runs on the **server**
- The browser just displays what the server tells it to
- Every click sends a message to the server via **SignalR** (a real-time connection)

**Visual Flow:**

```
Browser                    Server
   ğŸ‘† Click! â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶   ğŸ–¥ï¸ Runs C# code
   â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€   ğŸ“¤ Sends UI update
   ğŸ–¼ï¸ Updates display
```

### ğŸŸ¢ Blazor WebAssembly: "Full Independence"

Think of it like a **native mobile app**:

- Your C# code is **downloaded to the browser**
- It runs completely **client-side** using WebAssembly
- No constant server connection needed

**Visual Flow:**

```
Initial Load:
Server â”€â”€â”€â”€â”€â–¶ ğŸ“¦ Downloads .NET runtime + your app
              Browser runs everything locally!

After Load:
Browser: ğŸ‘† Click! â”€â”€â–¶ ğŸ–¥ï¸ Runs C# in browser
         â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  ğŸ–¼ï¸ Updates instantly
```

<HostingTypeSelector />

## Quick Comparison

| Feature               | Blazor Server    | Blazor WebAssembly ğŸŸ¢         |
| :-------------------- | :----------------- | :---------------------------- |
| **Where code runs**   | Server             | Browser                       |
| **Initial load time** |  Fast            |  Slower (downloads runtime) |
| **Offline support**   |  No              |  Yes (after initial load)   |
| **Server required**   |  Yes, always     |  No (after download)        |
| **Latency**           |  Network delay   |  Instant responses          |
| **Code protection**   |  Stays on server | ï¸ Visible in browser         |

## Real-World Analogies

### Blazor Server = Remote Desktop

- You control a computer from far away
- Every action requires communication
- If internet disconnects, you're stuck
- **Great for:** Internal business apps, apps with sensitive logic

### Blazor WebAssembly = Installed Program

- Everything runs on your machine
- Works offline once downloaded
- Takes longer to install initially
- **Great for:** Public apps, PWAs, offline-capable apps

<ProgressCheckpoint section="hosting-models-overview" xpReward={25} />

## When Should You Use Each?

### Choose Blazor Server when:

-  Building **internal company apps**
-  You have **sensitive business logic** to protect
-  You need **fast initial load**
-  Supporting **older browsers** or devices

### Choose Blazor WebAssembly when:

- Building **public-facing apps**
- You need **offline capability**
- You want **instant interactions** (no network latency)
- You're building a **Progressive Web App (PWA)**

## The Hybrid Approach

Good news! You can actually **combine both** in a Blazor Web App (.NET 8+):

- Start with Server rendering for fast load
- Switch to WebAssembly for certain components
- Best of both worlds! 

```csharp
// This component runs on the server
@rendermode InteractiveServer

// This component runs in the browser
@rendermode InteractiveWebAssembly
```

## Try It Yourself! ğŸ§ª

Here's the simplest Blazor counter component that works in BOTH hosting models:

```razor
@page "/counter"

<h1>Counter</h1>
<p>Current count: @currentCount</p>
<button @onclick="IncrementCount">Click me</button>

@code {
    private int currentCount = 0;

    private void IncrementCount()
    {
        currentCount++;
    }
}
```

**Same code, different hosting!** That's the Blazor magic. 

<InteractiveCodeEditor
  initialCode={`@page "/counter"

<h1>Counter</h1>

<p>Current count: @currentCount</p>

<button class="btn btn-primary" @onclick="IncrementCount">Click me</button>

@code {
private int currentCount = 0;

    private void IncrementCount()
    {
        currentCount++;
    }

}`}
language="razor"
runMode="blazor"
/>
