# JavaScript Interop: Bridging C# and JavaScript üåâ

Imagine Blazor and JavaScript are two countries that speak different languages. **JS Interop** is the translator that lets them talk to each other!

```
C# Land üè∞                JavaScript Land üóº
   ‚Üì                            ‚Üë
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ JS Interop ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        (The Translator!)
```

## Why Do We Need JS Interop?

While Blazor lets you write C#, sometimes you need JavaScript for:

- üì¶ Using existing JavaScript libraries (Chart.js, Leaflet maps, etc.)
- üåê Browser APIs not available in .NET (local storage, geolocation)
- üé® Manipulating the DOM directly
- üîå Integrating third-party widgets

**Good news:** Blazor makes calling JavaScript from C# (and vice versa) super easy!

## Calling JavaScript from C#

### The IJSRuntime Service

This is your magic tool for calling JavaScript:

```csharp
@inject IJSRuntime JS

<button @onclick="ShowAlert">Click Me!</button>

@code {
    async Task ShowAlert()
    {
        // Call JavaScript's alert() function
        await JS.InvokeVoidAsync("alert", "Hello from C#!");
    }
}
```

**What's happening?**

1. `@inject IJSRuntime JS` = Get the JS interop service
2. `InvokeVoidAsync` = Call a JS function (returns nothing)
3. `"alert"` = JavaScript function name
4. `"Hello from C#!"` = Parameter passed to JS

### JavaScript Functions with Return Values

```csharp
<button @onclick="GetConfirmation">Ask User</button>
<p>User said: @userResponse</p>

@code {
    private string userResponse = "Not answered yet";

    async Task GetConfirmation()
    {
        // Call JavaScript confirm() and get result
        bool confirmed = await JS.InvokeAsync<bool>(
            "confirm",
            "Do you like Blazor?"
        );

        userResponse = confirmed ? "Yes! üëç" : "No üëé";
    }
}
```

**Notice:**

- `InvokeAsync<bool>` = Expecting a boolean return value
- JavaScript's `confirm()` returns true/false
- C# receives it as `bool`

## Your First Custom JavaScript Function

### 1. Create a JavaScript File

Create `wwwroot/js/myFunctions.js`:

```javascript
// myFunctions.js
window.myFunctions = {
  showMessage: function (message) {
    alert("Message from C#: " + message);
  },

  getCurrentTime: function () {
    return new Date().toLocaleTimeString();
  },

  addNumbers: function (a, b) {
    return a + b;
  },
};
```

### 2. Reference It in Your HTML

In `wwwroot/index.html` (WASM) or `Pages/_Host.cshtml` (Server):

```html
<script src="js/myFunctions.js"></script>
```

### 3. Call from Blazor!

```razor
@inject IJSRuntime JS

<button @onclick="ShowTime">What Time Is It?</button>
<p>Time: @currentTime</p>

<button @onclick="AddNumbers">Add 5 + 3</button>
<p>Result: @sum</p>

@code {
    private string currentTime = "";
    private int sum = 0;

    async Task ShowTime()
    {
        currentTime = await JS.InvokeAsync<string>(
            "myFunctions.getCurrentTime"
        );
    }

    async Task AddNumbers()
    {
        sum = await JS.InvokeAsync<int>(
            "myFunctions.addNumbers",
            5, 3
        );
    }
}
```

<ProgressCheckpoint section="js-interop-basics" xpReward={25} />

## Calling C# from JavaScript

Yes, JavaScript can call your C# methods too!

### 1. Create a C# Method

```csharp
public class Greeting
{
    [JSInvokable]  // Make it callable from JS
    public static string GetGreeting(string name)
    {
        return $"Hello, {name}, from C#!";
    }
}
```

**Important:** Must be `public static` and marked with `[JSInvokable]`

### 2. Call from JavaScript

```javascript
// JavaScript code
async function callCSharp() {
  const greeting = await DotNet.invokeMethodAsync(
    "YourAppName", // Assembly name
    "GetGreeting", // Method name
    "Alice" // Parameter
  );

  console.log(greeting); // "Hello, Alice, from C#!"
}
```

<JSInteropVisualizer mode="bisymmetric" />

## Common JS Interop Scenarios

### 1. Local Storage

```csharp
// Save to local storage
await JS.InvokeVoidAsync(
    "localStorage.setItem",
    "username",
    "Alice"
);

// Read from local storage
string? username = await JS.InvokeAsync<string>(
    "localStorage.getItem",
    "username"
);
```

### 2. Console Logging

```csharp
await JS.InvokeVoidAsync("console.log", "Debug message");
await JS.InvokeVoidAsync("console.error", "Error!");
await JS.InvokeVoidAsync("console.warn", "Warning!");
```

### 3. Page Navigation

```csharp
// Open URL in new tab
await JS.InvokeVoidAsync(
    "open",
    "https://example.com",
    "_blank"
);
```

### 4. Focus an Element

```javascript
// myFunctions.js
window.myFunctions = {
  focusElement: function (elementId) {
    document.getElementById(elementId).focus();
  },
};
```

```csharp
// Component.razor
<input id="nameInput" @bind="name" />
<button @onclick="FocusInput">Focus Input</button>

@code {
    private string name = "";

    async Task FocusInput()
    {
        await JS.InvokeVoidAsync(
            "myFunctions.focusElement",
            "nameInput"
        );
    }
}
```

<ProgressCheckpoint section="calling-js-from-csharp" xpReward={25} />

## Real-World Example: Using Chart.js

Let's integrate a popular JavaScript charting library!

### 1. Add Chart.js CDN

```html
<!-- In index.html or _Host.cshtml -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
```

### 2. Create Helper JavaScript

```javascript
// wwwroot/js/chartHelper.js
window.chartHelper = {
  createChart: function (canvasId, data) {
    const ctx = document.getElementById(canvasId);
    new Chart(ctx, {
      type: "bar",
      data: {
        labels: data.labels,
        datasets: [
          {
            label: "Sales",
            data: data.values,
            backgroundColor: "rgba(75, 192, 192, 0.6)",
          },
        ],
      },
    });
  },
};
```

### 3. Use in Blazor Component

```razor
@inject IJSRuntime JS

<canvas id="myChart" width="400" height="200"></canvas>
<button @onclick="LoadChart">Load Chart</button>

@code {
    async Task LoadChart()
    {
        var chartData = new
        {
            labels = new[] { "Jan", "Feb", "Mar", "Apr" },
            values = new[] { 10, 20, 15, 30 }
        };

        await JS.InvokeVoidAsync(
            "chartHelper.createChart",
            "myChart",
            chartData
        );
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await LoadChart();
        }
    }
}
```

**Note:** Use `OnAfterRenderAsync` because the DOM must exist before calling JS!

## Important Tips ‚ö†Ô∏è

### 1. Async is Required

```csharp
// ‚ùå Wrong - will throw error
var result = JS.InvokeAsync<string>("myFunction");

// ‚úÖ Correct - always await
var result = await JS.InvokeAsync<string>("myFunction");
```

### 2. Wait for DOM with OnAfterRender

```csharp
protected override async Task OnAfterRenderAsync(bool firstRender)
{
    if (firstRender)
    {
        // DOM is ready, safe to call JS that manipulates elements
        await JS.InvokeVoidAsync("initializeWidget");
    }
}
```

### 3. Check for Null

```csharp
// JavaScript might not be loaded yet
if (JS != null)
{
    await JS.InvokeVoidAsync("myFunction");
}
```

<ProgressCheckpoint section="calling-csharp-from-js" xpReward={25} />

## Summary: The JS Interop Cheat Sheet

| Task                         | Code                                                   |
| :--------------------------- | :----------------------------------------------------- |
| **Call JS (no return)**      | `await JS.InvokeVoidAsync("functionName", param1)`     |
| **Call JS (with return)**    | `var result = await JS.InvokeAsync<T>("functionName")` |
| **Make C# callable from JS** | `[JSInvokable] public static ...`                      |
| **Call C# from JS**          | `DotNet.invokeMethodAsync('App', 'MethodName')`        |
| **Wait for DOM**             | Use `OnAfterRenderAsync(bool firstRender)`             |

## Try It Yourself! üé®

Create a simple color picker that uses JS and C#:

```razor
@inject IJSRuntime JS

<input type="color" id="colorPicker" />
<button @onclick="GetSelectedColor">Get Color</button>
<p>Selected color: @selectedColor</p>

@code {
    private string selectedColor = "";

    async Task GetSelectedColor()
    {
        selectedColor = await JS.InvokeAsync<string>(
            "eval",
            "document.getElementById('colorPicker').value"
        );
    }
}
```

JavaScript Interop opens infinite possibilities - you get the best of both C# and JavaScript! üåü
