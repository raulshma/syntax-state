# JavaScript Interop: Advanced Patterns

Master module-based JS interop, instance methods, and complex data passing between C# and JavaScript.

## JavaScript Modules (Recommended Approach)

Instead of global functions, use ES6 modules for better encapsulation and lazy loading.

### Component-Scoped JavaScript Modules

Create a JS file alongside your component:

```
Components/
  ├── WeatherChart.razor
  └── WeatherChart.razor.js  ← Same name!
```

**WeatherChart.razor.js:**

```javascript
export function initializeChart(canvasId, dataPoints) {
    const canvas = document.getElementById(canvasId);
    const ctx = canvas.getContext('2d');
    
    // Draw chart logic
    dataPoints.forEach((point, index) => {
        const x = index * 50;
        const y = canvas.height - point;
        ctx.fillRect(x, y, 40, point);
    });
    
    return {
        update: function(newData) {
            // Update chart with new data
        },
        destroy: function() {
            // Cleanup
        }
    };
}

export function highlightElement(element, color) {
    element.style.backgroundColor = color;
}
```

**WeatherChart.razor:**

```csharp
@inject IJSRuntime JS
@implements IAsyncDisposable

<canvas id="weatherChart" width="600" height="400"></canvas>

@code {
    private IJSObjectReference? module;
    private IJSObjectReference? chartInstance;
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Import the module
            module = await JS.InvokeAsync<IJSObjectReference>(
                "import",
                "./Components/WeatherChart.razor.js"
            );
            
            // Call module function
            chartInstance = await module.InvokeAsync<IJSObjectReference>(
                "initializeChart",
                "weatherChart",
                new[] { 10, 25, 15, 30, 20 }
            );
        }
    }
    
    async ValueTask IAsyncDisposable.DisposeAsync()
    {
        if (chartInstance != null)
        {
            await chartInstance.InvokeVoidAsync("destroy");
            await chartInstance.DisposeAsync();
        }
        
        if (module != null)
        {
            await module.DisposeAsync();
        }
    }
}
```

**Benefits:**
-  Scoped to component (no global pollution)
-  Lazy loaded (only when component used)
-  Better IntelliSense support
-  Proper cleanup with Dispose

<JSModuleVisualizer />

## Passing Complex Objects

### C# → JavaScript

```csharp
public class ProductData
{
    public string Name { get; set; } = "";
    public decimal Price { get; set; }
    public List<string> Tags { get; set; } = new();
    public Dictionary<string, object> Metadata { get; set; } = new();
}

// Usage
var product = new ProductData
{
    Name = "Laptop",
    Price = 999.99m,
    Tags = new List<string> { "Electronics", "Computers" },
    Metadata = new Dictionary<string, object>
    {
        ["brand"] = "Dell",
        ["warranty"] = 2
    }
};

await JS.InvokeVoidAsync("displayProduct", product);
```

**JavaScript receives:**

```javascript
function displayProduct(product) {
    console.log(product);
    /*
    {
        name: "Laptop",
        price: 999.99,
        tags: ["Electronics", "Computers"],
        metadata: { brand: "Dell", warranty: 2 }
    }
    */
}
```

**Note:** Property names are camelCased automatically!

### JavaScript → C#

```javascript
// JavaScript
const userData = {
    firstName: "John",
    lastName: "Doe",
    age: 30,
    hobbies: ["Reading", "Gaming"]
};

await DotNet.invokeMethodAsync('YourApp', 'ProcessUser', userData);
```

```csharp
// C#
public class UserData
{
    public string FirstName { get; set; } = "";
    public string LastName { get; set; } = "";
    public int Age { get; set; }
    public List<string> Hobbies { get; set; } = new();
}

[JSInvokable]
public static void ProcessUser(UserData user)
{
    Console.WriteLine($"{user.FirstName} {user.LastName}, {user.Age}");
    // John Doe, 30
}
```

## Instance Methods (Non-Static)

To call instance methods from JavaScript:

```csharp
@inject IJSRuntime JS

<button id="notifyBtn">Notify Me</button>

@code {
    private DotNetObjectReference<NotificationComponent>? objRef;
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Create reference to THIS instance
            objRef = DotNetObjectReference.Create(this);
            
            await JS.InvokeVoidAsync(
                "setupNotifications",
                objRef
            );
        }
    }
    
    [JSInvokable]
    public void ShowNotification(string message)
    {
        // Instance method callable from JS!
        Console.WriteLine($"Notification: {message}");
    }
    
    public void Dispose()
    {
        objRef?.Dispose();
    }
}
```

**JavaScript:**

```javascript
let dotnetHelper;

window.setupNotifications = function (dotNetObject) {
    dotnetHelper = dotNetObject;
    
    document.getElementById('notifyBtn').addEventListener('click', () => {
        // Call C# instance method
        dotnetHelper.invokeMethodAsync('ShowNotification', 'Button clicked!');
    });
};
```

<ProgressCheckpoint section="calling-csharp-from-js" xpReward={40} />

## JavaScript Promises & Async

Handle JavaScript promises properly:

```javascript
// JavaScript with Promise
export async function fetchWeatherData(city) {
    const response = await fetch(`/api/weather/${city}`);
    const data = await response.json();
    return data;
}
```

```csharp
// C# automatically awaits JavaScript promises
var weatherData = await module.InvokeAsync<WeatherData>(
    "fetchWeatherData",
    "London"
);
```

## Error Handling

### Try-Catch in C#

```csharp
try
{
    await JS.InvokeVoidAsync("riskyJavaScriptFunction");
}
catch (JSException ex)
{
    // JavaScript threw an error
    Console.WriteLine($"JS Error: {ex.Message}");
}
catch (JSDisconnectedException ex)
{
    // Connection lost (Blazor Server only)
    Console.WriteLine("Connection lost");
}
```

### Try-Catch in JavaScript

```javascript
export async function callDotNet(dotNetObj) {
    try {
        const result = await dotNetObj.invokeMethodAsync('GetData');
        return result;
    } catch (error) {
        console.error('C# threw an error:', error);
        return null;
    }
}
```

## Performance Optimization

### 1. Batch Multiple Calls

```csharp
// ❌ Bad: Multiple round trips
await JS.InvokeVoidAsync("setColor", "red");
await JS.InvokeVoidAsync("setSize", 16);
await JS.InvokeVoidAsync("setText", "Hello");

// ✅ Good: Single call with all data
await JS.InvokeVoidAsync("updateElement", new
{
    color = "red",
    size = 16,
    text = "Hello"
});
```

```javascript
// JavaScript
window.updateElement = function(options) {
    element.style.color = options.color;
    element.style.fontSize = options.size + 'px';
    element.textContent = options.text;
};
```

### 2. Use ValueTask for Synchronous Operations

```csharp
[JSInvokable]
public static ValueTask<int> Add(int a, int b)
{
    // Synchronous operation, but JS interop expects Task
    return ValueTask.FromResult(a + b);
}
```

### 3. Dispose Modules

Always dispose JS modules to prevent memory leaks:

```csharp
@implements IAsyncDisposable

private IJSObjectReference? module;

async ValueTask IAsyncDisposable.DisposeAsync()
{
    if (module != null)
    {
        await module.DisposeAsync();
    }
}
```

## Real-World: Third-Party Library Integration

### Example: Integrating Leaflet Maps

**1. Install Leaflet:**

```html
<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
```

**2. Create Wrapper Module (LeafletMap.razor.js):**

```javascript
let map = null;

export function initializeMap(elementId, lat, lng, zoom) {
    map = L.map(elementId).setView([lat, lng], zoom);
    
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '© OpenStreetMap contributors'
    }).addTo(map);
    
    return {
        addMarker: function(lat, lng, popup) {
            L.marker([lat, lng]).addTo(map)
                .bindPopup(popup);
        },
        setView: function(lat, lng, zoom) {
            map.setView([lat, lng], zoom);
        }
    };
}
```

**3. Use in Component:**

```razor
@inject IJSRuntime JS
@implements IAsyncDisposable

<div id="map" style="height: 400px;"></div>
<button @onclick="AddMarker">Add Marker</button>

@code {
    private IJSObjectReference? module;
    private IJSObjectReference? mapInstance;
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            module = await JS.InvokeAsync<IJSObjectReference>(
                "import", "./Components/LeafletMap.razor.js");
            
            mapInstance = await module.InvokeAsync<IJSObjectReference>(
                "initializeMap", "map", 51.505, -0.09, 13);
        }
    }
    
    async Task AddMarker()
    {
        if (mapInstance != null)
        {
            await mapInstance.InvokeVoidAsync(
                "addMarker", 
                51.5, -0.1, 
                "Hello from Blazor!");
        }
    }
    
    async ValueTask IAsyncDisposable.DisposeAsync()
    {
        if (mapInstance != null) await mapInstance.DisposeAsync();
        if (module != null) await module.DisposeAsync();
    }
}
```

<ProgressCheckpoint section="best-practices" xpReward={40} />

## Best Practices Summary

| Practice | Reason |
|:---------|:-------|
| **Use JS modules** | Better scoping, lazy loading |
| **Dispose properly** | Prevent memory leaks |
| **Batch operations** | Reduce overhead |
| **Handle errors** | Graceful failure |
| **Use OnAfterRender** | Ensure DOM exists |
| **Avoid eval()** | Security risk |

Master these patterns to seamlessly integrate JavaScript libraries into your Blazor apps! 
