# Creating Your Own Middleware 

Sometimes the built-in tools aren't enough. What if you want to log every request? Or block certain IP addresses? **You create your own middleware!**

## Section 1: Inline Middleware

### The Checkpoint Analogy

Think of custom middleware like creating your own **checkpoint at the airport**:

| **You Decide...** | **In Middleware...** |
| :---------------- | :------------------- |
| What to check | `if` statements |
| What to allow through | Call `next()` |
| What to block | Return without calling `next` |

<InfoBox type="tip">
  Every middleware has THREE chances to act:
  1. **Before** the next middleware (inspect request)
  2. **Decide** whether to call next or block
  3. **After** the next middleware (modify response)
</InfoBox>

### Your First Custom Middleware

```csharp
app.Use(async (context, next) =>
{
    // üîµ BEFORE: Runs on every incoming request
    Console.WriteLine($"üì• Request: {context.Request.Path}");
    
    await next();  // üü¢ Call the next middleware
    
    // üü° AFTER: Runs on the way back out
    Console.WriteLine($"üì§ Response: {context.Response.StatusCode}");
});
```

<CustomMiddlewareBuilder mode="beginner" />

<ProgressCheckpoint section="inline-middleware" xpReward={12} />

---

## Section 2: Convention-Based Middleware

### Creating a Middleware Class

For production, use class-based middleware:

```csharp
public class RequestTimingMiddleware
{
    private readonly RequestDelegate _next;

    public RequestTimingMiddleware(RequestDelegate next)
    {
        _next = next;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        var stopwatch = Stopwatch.StartNew();
        
        await _next(context);
        
        stopwatch.Stop();
        Console.WriteLine($"Request took {stopwatch.ElapsedMilliseconds}ms");
    }
}

// Usage
app.UseMiddleware<RequestTimingMiddleware>();
```

### Extension Method for Clean Registration

```csharp
public static class RequestTimingMiddlewareExtensions
{
    public static IApplicationBuilder UseRequestTiming(
        this IApplicationBuilder builder)
    {
        return builder.UseMiddleware<RequestTimingMiddleware>();
    }
}

// Clean usage
app.UseRequestTiming();
```

<ProgressCheckpoint section="convention-middleware" xpReward={12} />

---

## Section 3: Short-Circuiting

### Blocking Requests

Block certain paths without calling `next()`:

```csharp
app.Use(async (context, next) =>
{
    if (context.Request.Path.StartsWithSegments("/admin"))
    {
        context.Response.StatusCode = 403;
        await context.Response.WriteAsync("üö´ Access Denied!");
        return;  // üõë DON'T call next() - request stops here!
    }
    
    await next();  // All other requests continue
});
```

<InfoBox type="warning">
  **Important:** When you DON'T call `await next()`, the request stops! This is called **short-circuiting**.
</InfoBox>

### The Simple Pattern

```csharp
app.Use(async (context, next) =>
{
    // 1Ô∏è‚É£ Do something BEFORE (inspect/modify request)
    
    // 2Ô∏è‚É£ Call next (or don't, to block the request)
    await next();
    
    // 3Ô∏è‚É£ Do something AFTER (inspect/modify response)
});
```

### Key Takeaways

| Concept | Description |
| :------ | :---------- |
|  **Custom middleware** | Handle things built-in can't |
| ‚èØÔ∏è **Three phases** | Before ‚Üí Next ‚Üí After |
|  **Short-circuit** | Don't call `next()` to block |
|  **Common uses** | Logging, blocking, timing, headers |

<ProgressCheckpoint section="factory-middleware" xpReward={11} />
