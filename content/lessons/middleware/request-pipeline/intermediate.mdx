# The ASP.NET Core Request Pipeline

The request pipeline is the heart of ASP.NET Core. It's a sequence of **request delegates** that process HTTP requests and generate responses.

## Section 1: Pipeline Overview

### How the Pipeline Works

When an HTTP request arrives, it travels through a series of middleware components. Each middleware can:

1. **Inspect or modify** the incoming request
2. **Call the next** middleware in the pipeline
3. **Inspect or modify** the outgoing response
4. **Short-circuit** (stop the request and return early)

<MiddlewarePipelineSimulator mode="intermediate" />

### The Three Middleware Methods

#### 1. `Use()` — Pass-Through Middleware

```csharp
app.Use(async (context, next) =>
{
    // Before: Runs on the way IN
    Console.WriteLine($"Request: {context.Request.Path}");
    
    await next();  // Call the next middleware
    
    // After: Runs on the way OUT
    Console.WriteLine($"Response: {context.Response.StatusCode}");
});
```

#### 2. `Run()` — Terminal Middleware

```csharp
app.Run(async context =>
{
    // Terminal - request ends here
    await context.Response.WriteAsync("Hello World!");
    // No next() call
});
```

#### 3. `Map()` — Branch the Pipeline

```csharp
app.Map("/api", apiApp =>
{
    apiApp.UseAuthentication();
    apiApp.MapControllers();
});
```

<ProgressCheckpoint section="pipeline-overview" xpReward={13} />

---

## Section 2: Pipeline Flow and Short-Circuiting

### Short-Circuiting the Pipeline

Sometimes you want to **stop the request early**:

```csharp
app.Use(async (context, next) =>
{
    if (context.Request.Path.StartsWithSegments("/blocked"))
    {
        context.Response.StatusCode = 403;
        await context.Response.WriteAsync("Forbidden!");
        return;  // Don't call next() - request stops here
    }
    
    await next();  // Continue for other paths
});
```

**Common short-circuit scenarios:**
-  Authentication failures
-  Serving static files
-  Returning cached responses
-  Blocking unauthorized requests

### Branching with MapWhen

```csharp
app.MapWhen(
    context => context.Request.Query.ContainsKey("debug"),
    debugApp =>
    {
        debugApp.Run(async ctx =>
            await ctx.Response.WriteAsync("Debug mode!"));
    }
);
```

<ProgressCheckpoint section="pipeline-flow" xpReward={13} />

---

## Section 3: Pipeline Order

### The Recommended Middleware Order

Microsoft recommends this order:

```csharp
var app = builder.Build();

// 1. Exception handling (catch everything)
app.UseExceptionHandler("/Error");

// 2. HSTS (production only)
app.UseHsts();

// 3. HTTPS Redirection
app.UseHttpsRedirection();

// 4. Static Files (short-circuits for files)
app.UseStaticFiles();

// 5. Routing (matches URL to endpoint)
app.UseRouting();

// 6. CORS (before auth)
app.UseCors();

// 7. Authentication (who are you?)
app.UseAuthentication();

// 8. Authorization (what can you do?)
app.UseAuthorization();

// 9. Custom middleware

// 10. Endpoint execution
app.MapControllers();
```

<InfoBox type="tip">
  **Pro Tip:** Exception Handler should be first so it can catch errors from ALL subsequent middleware!
</InfoBox>

### Key Takeaways

| Method | Behavior |
| :----- | :------- |
| `Use()` | Processes and passes to next |
| `Run()` | Terminal — ends the pipeline |
| `Map()` | Creates branches based on paths |
| `MapWhen()` | Branches based on any condition |

<ProgressCheckpoint section="pipeline-order" xpReward={14} />
