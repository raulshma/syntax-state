# Instance Methods: Giving Objects Behavior

If properties are what an object **has**, methods are what an object **does**. Instance methods are functions that belong to each object created from a class - they define the actions and behaviors that objects can perform.

---

## Section 1: What Are Instance Methods?

### The Robot Analogy ü§ñ

Imagine you're building robots. Each robot has:
- **Properties**: battery level, name, color (what it HAS)
- **Methods**: walk, talk, dance (what it DOES)

```javascript
class Robot {
  constructor(name) {
    this.name = name;
    this.battery = 100;
  }
  
  // Instance methods - actions the robot can do
  walk() {
    this.battery -= 10;
    return `${this.name} is walking. Battery: ${this.battery}%`;
  }
  
  talk(message) {
    this.battery -= 5;
    return `${this.name} says: "${message}"`;
  }
  
  recharge() {
    this.battery = 100;
    return `${this.name} is fully charged!`;
  }
}
```

<InfoBox type="info">
**Instance methods** are functions defined inside a class that operate on individual instances. Each object created from the class can call these methods, and they have access to that specific object's properties via `this`.
</InfoBox>

<CodePlayground
  initialCode={`// Instance methods in action

class Robot {
  constructor(name) {
    this.name = name;
    this.battery = 100;
  }
  
  walk() {
    if (this.battery < 10) {
      return \`\${this.name} needs charging!\`;
    }
    this.battery -= 10;
    return \`\${this.name} walks. Battery: \${this.battery}%\`;
  }
  
  talk(message) {
    this.battery -= 5;
    return \`\${this.name}: "\${message}"\`;
  }
  
  recharge() {
    this.battery = 100;
    return \`\${this.name} fully charged! \`;
  }
}

// Create robots
const robo1 = new Robot('R2-D2');
const robo2 = new Robot('C-3PO');

// Each robot has its own state
console.log(robo1.walk());
console.log(robo1.walk());
console.log(robo2.talk('Hello there!'));

// robo1's battery is different from robo2's
console.log(\`R2-D2 battery: \${robo1.battery}%\`);
console.log(\`C-3PO battery: \${robo2.battery}%\`);`}
  height={400}
/>

<ProgressCheckpoint section="what-are-methods" xpReward={15} />

---

## Section 2: Method Syntax and Patterns

### Defining Methods

Methods are defined without the `function` keyword:

```javascript
class Example {
  // ‚úÖ Correct - concise method syntax
  doSomething() {
    return 'done';
  }
  
  // ‚ùå Old syntax - don't use in classes
  // doSomething: function() { }
}
```

<CodePlayground
  initialCode={`// Different method patterns

class Calculator {
  constructor(initialValue = 0) {
    this.value = initialValue;
  }
  
  // Basic method
  add(n) {
    this.value += n;
    return this; // Return 'this' for chaining!
  }
  
  subtract(n) {
    this.value -= n;
    return this;
  }
  
  multiply(n) {
    this.value *= n;
    return this;
  }
  
  // Method with multiple parameters
  addMany(...numbers) {
    for (const n of numbers) {
      this.value += n;
    }
    return this;
  }
  
  // Method that returns a value (not 'this')
  getResult() {
    return this.value;
  }
  
  // Method that resets state
  reset() {
    this.value = 0;
    return this;
  }
}

const calc = new Calculator(10);

// Method chaining - possible because methods return 'this'
const result = calc
  .add(5)
  .multiply(2)
  .subtract(10)
  .getResult();

console.log('Chained result:', result); // (10 + 5) * 2 - 10 = 20

// Using rest parameters
calc.reset().addMany(1, 2, 3, 4, 5);
console.log('Sum of 1-5:', calc.getResult()); // 15`}
  height={450}
/>

<KeyConcept title="Method Chaining">
By returning `this` from methods, you enable **method chaining** - calling multiple methods in sequence on the same object. This creates fluent, readable APIs!
</KeyConcept>

### Method Parameters

| Pattern | Example | Use Case |
|:--------|:--------|:---------|
| No params | `reset()` | Actions without input |
| Single param | `add(n)` | Simple operations |
| Multiple params | `setPosition(x, y)` | Related values |
| Default params | `greet(name = 'friend')` | Optional values |
| Rest params | `sum(...nums)` | Variable arguments |
| Object param | `configure({ speed, color })` | Many options |

<ProgressCheckpoint section="method-syntax" xpReward={20} />

---

## Section 3: The `this` Keyword in Methods

### Understanding `this`

Inside instance methods, `this` refers to the object calling the method:

<CodePlayground
  initialCode={`// 'this' in instance methods

class Player {
  constructor(name) {
    this.name = name;
    this.score = 0;
    this.level = 1;
  }
  
  // 'this' refers to the player instance
  earnPoints(points) {
    this.score += points;
    console.log(\`\${this.name} earned \${points} points! Total: \${this.score}\`);
    
    // Can call other methods using 'this'
    this.checkLevelUp();
  }
  
  checkLevelUp() {
    const newLevel = Math.floor(this.score / 100) + 1;
    if (newLevel > this.level) {
      this.level = newLevel;
      console.log(\` \${this.name} reached level \${this.level}!\`);
    }
  }
  
  getStatus() {
    return \`\${this.name} | Level \${this.level} | Score: \${this.score}\`;
  }
}

const player1 = new Player('Alice');
const player2 = new Player('Bob');

// 'this' is different for each instance
player1.earnPoints(50);
player1.earnPoints(60); // Level up!

player2.earnPoints(30);

console.log('\\n' + player1.getStatus());
console.log(player2.getStatus());`}
  height={420}
/>

### The `this` Binding Problem

<InfoBox type="warning">
**Watch out!** When you pass a method as a callback, `this` can become `undefined`. This is a common source of bugs!
</InfoBox>

<CodePlayground
  initialCode={`// The 'this' binding problem

class Timer {
  constructor(name) {
    this.name = name;
    this.seconds = 0;
  }
  
  // Regular method
  tick() {
    this.seconds++;
    console.log(\`\${this.name}: \${this.seconds}s\`);
  }
  
  // Arrow function as class field - 'this' is always bound!
  tickArrow = () => {
    this.seconds++;
    console.log(\`\${this.name} (arrow): \${this.seconds}s\`);
  }
  
  // Method that uses bind
  startWithBind() {
    // Bind 'this' to the method
    setInterval(this.tick.bind(this), 1000);
  }
  
  // Method using arrow function
  startWithArrow() {
    setInterval(this.tickArrow, 1000);
  }
}

const timer = new Timer('MyTimer');

// Problem demonstration
const tickRef = timer.tick;
// tickRef(); // Would throw error - 'this' is undefined!

// Solution 1: Use bind
const boundTick = timer.tick.bind(timer);
boundTick(); // Works!

// Solution 2: Arrow function class field
timer.tickArrow(); // Always works!

// Solution 3: Call directly on object
timer.tick(); // Works!`}
  height={420}
/>

### Solutions for `this` Binding

| Solution | Syntax | Pros | Cons |
|:---------|:-------|:-----|:-----|
| Arrow class field | `method = () => {}` | Always bound | More memory per instance |
| `.bind()` | `this.method.bind(this)` | Explicit | Verbose |
| Arrow in callback | `() => this.method()` | Clear intent | Extra wrapper |

<ProgressCheckpoint section="this-keyword" xpReward={20} />

---

## Section 4: Methods on the Prototype

### How Methods Are Shared

Instance methods are defined on the class's **prototype**, meaning all instances share the same method function:

<CodePlayground
  initialCode={`// Methods live on the prototype

class Dog {
  constructor(name) {
    this.name = name;
  }
  
  bark() {
    return \`\${this.name} says: Woof!\`;
  }
  
  // Arrow function class field - NOT on prototype!
  barkArrow = () => {
    return \`\${this.name} says: Woof! (arrow)\`;
  }
}

const dog1 = new Dog('Buddy');
const dog2 = new Dog('Max');

// Regular methods are shared (same function)
console.log('Same bark method?', dog1.bark === dog2.bark); // true

// Arrow class fields are NOT shared (different functions)
console.log('Same barkArrow?', dog1.barkArrow === dog2.barkArrow); // false

// Check the prototype
console.log('\\nbark on prototype?', 'bark' in Dog.prototype); // true
console.log('barkArrow on prototype?', 'barkArrow' in Dog.prototype); // false

// Methods work the same way
console.log('\\n' + dog1.bark());
console.log(dog2.bark());`}
  height={380}
/>

<KeyConcept title="Prototype Efficiency">
Regular methods are defined once on the prototype and shared by all instances. Arrow function class fields create a new function for each instance, using more memory. Use regular methods unless you need guaranteed `this` binding.
</KeyConcept>

<Quiz id="instance-method-quiz">
  <Question>Where are regular instance methods stored?</Question>
  <Answer>On each instance object</Answer>
  <Answer correct>On the class prototype</Answer>
  <Answer>In a separate methods object</Answer>
  <Answer>In global scope</Answer>
</Quiz>

<Quiz id="this-binding-quiz">
  <Question>Which method definition always has 'this' bound to the instance?</Question>
  <Answer>Regular method: `method() {}`</Answer>
  <Answer correct>Arrow class field: `method = () => {}`</Answer>
  <Answer>Both have automatic binding</Answer>
  <Answer>Neither has automatic binding</Answer>
</Quiz>

### Summary

| Concept | Key Point |
|:--------|:----------|
| **Instance Methods** | Functions that operate on object instances |
| **Syntax** | `methodName() { }` (no `function` keyword) |
| **`this`** | Refers to the calling object |
| **Prototype** | Regular methods are shared via prototype |
| **Method Chaining** | Return `this` to enable chaining |
| **Arrow Fields** | Use for guaranteed `this` binding |

<ProgressCheckpoint section="prototype-methods" xpReward={20} />
