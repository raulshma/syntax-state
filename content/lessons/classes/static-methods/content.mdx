# Static Methods and Properties: Class-Level Features

While instance methods belong to individual objects, **static** members belong to the class itself. Think of them as features of the factory, not the products it makes. You don't need to create an object to use them!

---

## Section 1: Understanding Static Members

### The Factory vs Product Analogy 

Imagine a car factory:
- **Instance properties**: Each car's color, VIN number, mileage
- **Instance methods**: Each car can start(), accelerate(), brake()
- **Static properties**: Total cars produced (factory-wide count)
- **Static methods**: Factory utilities like `Car.compare(car1, car2)`

```javascript
class Car {
  // Static - belongs to the Car class itself
  static totalCarsProduced = 0;
  
  constructor(model) {
    this.model = model;
    this.mileage = 0;
    Car.totalCarsProduced++; // Access static via class name
  }
  
  // Instance method - each car can drive
  drive(miles) {
    this.mileage += miles;
  }
  
  // Static method - utility that doesn't need an instance
  static compare(car1, car2) {
    return car1.mileage - car2.mileage;
  }
}
```

<InfoBox type="info">
**Static members** are defined with the `static` keyword. They belong to the class itself, not to instances. Access them using the class name: `ClassName.staticMember`.
</InfoBox>

<CodePlayground
  initialCode={`// Static vs Instance members

class Car {
  // Static property - shared across all instances
  static totalCarsProduced = 0;
  static brand = 'AutoCorp';
  
  constructor(model, year) {
    this.model = model;
    this.year = year;
    this.mileage = 0;
    
    // Increment the class-level counter
    Car.totalCarsProduced++;
  }
  
  // Instance method
  drive(miles) {
    this.mileage += miles;
    return \`\${this.model} drove \${miles} miles\`;
  }
  
  // Static method - doesn't use 'this' for instance data
  static getTotalCars() {
    return \`Total \${Car.brand} cars: \${Car.totalCarsProduced}\`;
  }
}

// Access static members WITHOUT creating an instance
console.log('Brand:', Car.brand);
console.log(Car.getTotalCars());

// Create some cars
const car1 = new Car('Sedan', 2024);
const car2 = new Car('SUV', 2024);
const car3 = new Car('Truck', 2023);

console.log('\\nAfter creating 3 cars:');
console.log(Car.getTotalCars());

// Instance members are per-object
car1.drive(100);
car2.drive(50);
console.log('\\nCar1 mileage:', car1.mileage);
console.log('Car2 mileage:', car2.mileage);`}
  height={450}
/>

<ProgressCheckpoint section="understanding-static" xpReward={15} />

---

## Section 2: Static Methods

### Common Use Cases for Static Methods

Static methods are perfect for:
1. **Utility functions** that don't need instance data
2. **Factory methods** that create instances in special ways
3. **Comparison functions** between instances

<CodePlayground
  initialCode={`// Static method patterns

class MathHelper {
  // Utility methods - pure functions
  static add(a, b) {
    return a + b;
  }
  
  static multiply(a, b) {
    return a * b;
  }
  
  static clamp(value, min, max) {
    return Math.min(Math.max(value, min), max);
  }
  
  static randomBetween(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }
}

// Use without creating an instance!
console.log('Add:', MathHelper.add(5, 3));
console.log('Multiply:', MathHelper.multiply(4, 7));
console.log('Clamp 150 to 0-100:', MathHelper.clamp(150, 0, 100));
console.log('Random 1-10:', MathHelper.randomBetween(1, 10));

// Factory method pattern
class User {
  constructor(name, email, role) {
    this.name = name;
    this.email = email;
    this.role = role;
  }
  
  // Factory methods - alternative ways to create instances
  static createAdmin(name, email) {
    return new User(name, email, 'admin');
  }
  
  static createGuest() {
    return new User('Guest', 'guest@example.com', 'guest');
  }
  
  static fromJSON(json) {
    const data = JSON.parse(json);
    return new User(data.name, data.email, data.role);
  }
}

const admin = User.createAdmin('Alice', 'alice@company.com');
const guest = User.createGuest();
const fromData = User.fromJSON('{"name":"Bob","email":"bob@test.com","role":"user"}');

console.log('\\nAdmin:', admin);
console.log('Guest:', guest);
console.log('From JSON:', fromData);`}
  height={500}
/>

<KeyConcept title="Factory Methods">
Static factory methods provide alternative ways to create instances. They can have descriptive names, perform validation, or create pre-configured objects. Examples: `Date.now()`, `Array.from()`, `Object.create()`.
</KeyConcept>

### Static Methods Can't Access `this` (Instance)

<InfoBox type="warning">
Inside static methods, `this` refers to the **class itself**, not an instance. You cannot access instance properties from static methods!
</InfoBox>

```javascript
class Example {
  instanceProp = 'instance';
  static staticProp = 'static';
  
  static tryAccessInstance() {
    // console.log(this.instanceProp); // undefined!
    console.log(this.staticProp);      // 'static' - this is the class
  }
}
```

<ProgressCheckpoint section="static-methods" xpReward={20} />

---

## Section 3: Static Properties

### Class-Level Data

Static properties store data that's shared across all instances or belongs to the class concept itself:

<CodePlayground
  initialCode={`// Static properties

class Config {
  // Configuration constants
  static API_URL = 'https://api.example.com';
  static MAX_RETRIES = 3;
  static TIMEOUT = 5000;
  
  // Mutable static property
  static currentEnvironment = 'development';
  
  static setEnvironment(env) {
    const validEnvs = ['development', 'staging', 'production'];
    if (validEnvs.includes(env)) {
      Config.currentEnvironment = env;
    }
  }
  
  static getApiUrl() {
    const prefix = Config.currentEnvironment === 'production' ? '' : '/dev';
    return Config.API_URL + prefix;
  }
}

console.log('API URL:', Config.API_URL);
console.log('Max retries:', Config.MAX_RETRIES);
console.log('Environment:', Config.currentEnvironment);
console.log('Full API URL:', Config.getApiUrl());

Config.setEnvironment('production');
console.log('\\nAfter switching to production:');
console.log('Environment:', Config.currentEnvironment);
console.log('Full API URL:', Config.getApiUrl());`}
  height={380}
/>

### Tracking Instances with Static Properties

<CodePlayground
  initialCode={`// Using static properties to track instances

class Player {
  static allPlayers = [];
  static nextId = 1;
  
  constructor(name) {
    this.id = Player.nextId++;
    this.name = name;
    this.score = 0;
    
    // Register this player
    Player.allPlayers.push(this);
  }
  
  addScore(points) {
    this.score += points;
  }
  
  // Static method to find a player
  static findById(id) {
    return Player.allPlayers.find(p => p.id === id);
  }
  
  // Static method to get leaderboard
  static getLeaderboard() {
    return [...Player.allPlayers]
      .sort((a, b) => b.score - a.score)
      .map((p, i) => \`\${i + 1}. \${p.name}: \${p.score}\`);
  }
  
  // Static method to reset all
  static resetAll() {
    Player.allPlayers.forEach(p => p.score = 0);
  }
}

// Create players
const p1 = new Player('Alice');
const p2 = new Player('Bob');
const p3 = new Player('Charlie');

// Add scores
p1.addScore(150);
p2.addScore(200);
p3.addScore(175);

console.log('All players:', Player.allPlayers.length);
console.log('\\nLeaderboard:');
Player.getLeaderboard().forEach(line => console.log(line));

console.log('\\nFind player 2:', Player.findById(2)?.name);`}
  height={450}
/>

<ProgressCheckpoint section="static-properties" xpReward={20} />

---

## Section 4: Static Initialization Blocks

### Complex Static Setup (ES2022+)

For complex static initialization, use static initialization blocks:

<CodePlayground
  initialCode={`// Static initialization blocks (ES2022+)

class Database {
  static connections = [];
  static isInitialized = false;
  static config;
  
  // Static initialization block
  static {
    console.log(' Initializing Database class...');
    
    // Complex initialization logic
    this.config = {
      host: 'localhost',
      port: 5432,
      maxConnections: 10
    };
    
    // Can have multiple statements
    for (let i = 0; i < 3; i++) {
      this.connections.push({
        id: i,
        status: 'idle'
      });
    }
    
    this.isInitialized = true;
    console.log(' Database class initialized!');
  }
  
  static getConnection() {
    const idle = this.connections.find(c => c.status === 'idle');
    if (idle) {
      idle.status = 'busy';
      return idle;
    }
    return null;
  }
  
  static releaseConnection(conn) {
    conn.status = 'idle';
  }
}

// Static block runs when class is defined!
console.log('\\nConfig:', Database.config);
console.log('Connections:', Database.connections.length);
console.log('Initialized:', Database.isInitialized);

const conn = Database.getConnection();
console.log('\\nGot connection:', conn);`}
  height={450}
/>

<KeyConcept title="Static Initialization Blocks">
Static blocks run once when the class is first evaluated. They're useful for:
- Complex initialization that can't be done in a single expression
- Try/catch around initialization
- Initializing multiple related static properties
</KeyConcept>

<Quiz id="static-quiz">
  <Question>How do you access a static method?</Question>
  <Answer>instance.staticMethod()</Answer>
  <Answer correct>ClassName.staticMethod()</Answer>
  <Answer>this.staticMethod()</Answer>
  <Answer>super.staticMethod()</Answer>
</Quiz>

<Quiz id="static-this-quiz">
  <Question>What does 'this' refer to inside a static method?</Question>
  <Answer>The instance calling the method</Answer>
  <Answer correct>The class itself</Answer>
  <Answer>undefined</Answer>
  <Answer>The global object</Answer>
</Quiz>

### Built-in Static Methods You Already Know

| Class | Static Method | Purpose |
|:------|:--------------|:--------|
| `Math` | `Math.max()`, `Math.random()` | Math utilities |
| `Array` | `Array.from()`, `Array.isArray()` | Array utilities |
| `Object` | `Object.keys()`, `Object.assign()` | Object utilities |
| `JSON` | `JSON.parse()`, `JSON.stringify()` | JSON conversion |
| `Number` | `Number.parseInt()`, `Number.isNaN()` | Number utilities |

### Summary

| Concept | Key Point |
|:--------|:----------|
| **Static Keyword** | `static` before method/property |
| **Access** | Via class name: `Class.member` |
| **`this` in Static** | Refers to the class, not instance |
| **Use Cases** | Utilities, factories, counters, config |
| **Static Blocks** | Complex initialization (ES2022+) |

<ProgressCheckpoint section="static-blocks" xpReward={20} />
