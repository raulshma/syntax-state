# for...in Loop: Advanced Property Enumeration

Deep dive into property descriptors, Symbols, and advanced iteration patterns.

## Enumerable vs Non-Enumerable Properties

Not all properties show up in `for...in`. Only **enumerable** properties are iterated:

```javascript
const obj = {};

// Define an enumerable property (default)
obj.visible = 'I show up';

// Define a non-enumerable property
Object.defineProperty(obj, 'hidden', {
  value: 'I am hidden',
  enumerable: false
});

for (const key in obj) {
  console.log(key);
}
// Output: "visible" (hidden is not shown!)

console.log(obj.hidden); // "I am hidden" - still accessible!
```

<ProgressCheckpoint section="intro" xpReward={15} />

## Property Descriptors Explained

Every property has a descriptor that controls its behavior:

```javascript
const user = { name: 'Alice' };

console.log(Object.getOwnPropertyDescriptor(user, 'name'));
// {
//   value: "Alice",
//   writable: true,
//   enumerable: true,    ‚Üê This controls for...in visibility
//   configurable: true
// }
```

### Creating Properties with Specific Descriptors

```javascript
const config = {};

Object.defineProperties(config, {
  apiKey: {
    value: 'secret123',
    enumerable: false,  // Hide from iteration
    writable: false     // Make read-only
  },
  endpoint: {
    value: 'https://api.example.com',
    enumerable: true
  }
});

for (const key in config) {
  console.log(key);
}
// Output: "endpoint" only

// But apiKey is still there!
console.log(config.apiKey); // "secret123"
```

<CodePlayground 
  code={`const obj = {};

// Regular property - enumerable
obj.public = 'visible';

// Non-enumerable property
Object.defineProperty(obj, 'internal', {
  value: 'hidden from loops',
  enumerable: false
});

console.log('for...in sees:');
for (const key in obj) {
  console.log('-', key);
}

console.log('\\nAll own properties:');
Object.getOwnPropertyNames(obj).forEach(key => {
  console.log('-', key, '(enumerable:', 
    Object.getOwnPropertyDescriptor(obj, key).enumerable + ')');
});`}
  title="Enumerable Properties"
/>

<ProgressCheckpoint section="object-iteration" xpReward={15} />

## Symbol Properties

`for...in` does **not** iterate over Symbol-keyed properties:

```javascript
const id = Symbol('id');
const secret = Symbol('secret');

const user = {
  name: 'Alice',
  [id]: 12345,
  [secret]: 'password123'
};

for (const key in user) {
  console.log(key);
}
// Output: "name" only - Symbols are not shown!

// Access Symbols explicitly
console.log(user[id]); // 12345
console.log(Object.getOwnPropertySymbols(user)); // [Symbol(id), Symbol(secret)]
```

### Getting ALL Properties

```javascript
function getAllProperties(obj) {
  return {
    enumerable: Object.keys(obj),
    nonEnumerable: Object.getOwnPropertyNames(obj)
      .filter(key => !obj.propertyIsEnumerable(key)),
    symbols: Object.getOwnPropertySymbols(obj)
  };
}

const sym = Symbol('test');
const example = { visible: 1, [sym]: 2 };
Object.defineProperty(example, 'hidden', {
  value: 3,
  enumerable: false
});

console.log(getAllProperties(example));
// {
//   enumerable: ["visible"],
//   nonEnumerable: ["hidden"],
//   symbols: [Symbol(test)]
// }
```

<ProgressCheckpoint section="caveats" xpReward={15} />

## Proxy and for...in

Proxies can intercept and customize `for...in` behavior:

```javascript
const target = { a: 1, b: 2, c: 3 };

const proxy = new Proxy(target, {
  ownKeys(target) {
    // Filter or modify which keys are returned
    return Object.keys(target).filter(key => target[key] > 1);
  },
  getOwnPropertyDescriptor(target, key) {
    // Must return descriptor for keys to be enumerable
    return {
      enumerable: true,
      configurable: true
    };
  }
});

for (const key in proxy) {
  console.log(key);
}
// Output: "b", "c" (a is filtered out!)
```

## Performance Considerations

### for...in Performance Characteristics

```javascript
// for...in must check the prototype chain
// This has a small performance cost

const base = { inherited: true };
const obj = Object.create(base);
obj.own = true;

// Checking prototype chain on each iteration
for (const key in obj) {
  if (Object.hasOwn(obj, key)) {  // Additional check
    // process
  }
}

// Object.keys() is often faster for own properties
// because it pre-computes the own key list
for (const key of Object.keys(obj)) {
  // No need to check hasOwn
}
```

### Benchmark Comparison

```javascript
const obj = {};
for (let i = 0; i < 1000; i++) {
  obj[`key${i}`] = i;
}

console.time('for...in');
for (const key in obj) {
  const val = obj[key];
}
console.timeEnd('for...in');

console.time('Object.keys');
for (const key of Object.keys(obj)) {
  const val = obj[key];
}
console.timeEnd('Object.keys');

console.time('Object.entries');
for (const [key, val] of Object.entries(obj)) {
  // Already have both
}
console.timeEnd('Object.entries');
```

## Quiz: Advanced Concepts

<Quiz id="for-in-advanced">
  <Question
    id="q1"
    text="Which property descriptor controls for...in visibility?"
  >
    <Answer id="a" text="writable" />
    <Answer id="b" text="configurable" />
    <Answer id="c" text="enumerable" isCorrect />
  </Question>
  <Question
    id="q2"
    text="Do Symbol-keyed properties appear in for...in?"
  >
    <Answer id="a" text="Yes, always" />
    <Answer id="b" text="No, never" isCorrect />
    <Answer id="c" text="Only if enumerable is true" />
  </Question>
</Quiz>

<ProgressCheckpoint section="best-practices" xpReward={25} />

## Complete Property Iteration Reference

| Method | Own Props | Inherited | Non-Enum | Symbols |
|:-------|:---------:|:---------:|:--------:|:-------:|
| `for...in` |  |  |  |  |
| `Object.keys()` |  |  |  |  |
| `Object.getOwnPropertyNames()` |  |  |  |  |
| `Object.getOwnPropertySymbols()` |  |  |  |  |
| `Reflect.ownKeys()` |  |  |  |  |

<InfoBox type="tip" title="Professional Recommendation">
In modern JavaScript:
- Use `Object.entries()` for most object iteration
- Use `for...in` only when you specifically need inherited properties
- Use `Reflect.ownKeys()` when you need ALL properties including Symbols
- Always be explicit about what you're iterating over
</InfoBox>
