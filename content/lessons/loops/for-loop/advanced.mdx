# for Loop: Advanced Techniques and Optimization

Master advanced for loop patterns, understand performance implications, and learn when to use alternatives.

## Performance Optimization

### Cache Array Length

When iterating arrays, accessing `.length` on every iteration has a small cost. For performance-critical code:

```javascript
// Less optimal - accesses length each iteration
for (let i = 0; i < array.length; i++) { ... }

// Optimized - caches length once
for (let i = 0, len = array.length; i < len; i++) { ... }
```

<InfoBox type="tip" title="When to Cache Length">
Modern JavaScript engines optimize this well, so caching is usually unnecessary. However, it matters when:
- The array is very large (millions of elements)
- The loop body is very simple (length access becomes proportionally significant)
- You're modifying the array during iteration (caching preserves original length)
</InfoBox>

<ProgressCheckpoint section="intro" xpReward={15} />

## Edge Cases and Gotchas

### Empty Condition = Infinite Loop

All three parts of a for loop are optional:

```javascript
// Infinite loop - be careful!
for (;;) {
  // runs forever unless you break
  if (someCondition) break;
}

// Equivalent to:
while (true) { ... }
```

### Modifying Array During Iteration

This is a common source of bugs:

```javascript
const arr = [1, 2, 3, 4, 5];

// BUG: Skips elements when removing!
for (let i = 0; i < arr.length; i++) {
  if (arr[i] % 2 === 0) {
    arr.splice(i, 1); // Removes element, shifts indices
  }
}
console.log(arr); // [1, 3, 5]? No! [1, 3, 5] only if lucky

// CORRECT: Iterate backwards when removing
for (let i = arr.length - 1; i >= 0; i--) {
  if (arr[i] % 2 === 0) {
    arr.splice(i, 1);
  }
}
```

### Block Scope with let vs var

```javascript
// Using var - closure problem
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100);
}
// Output: 3, 3, 3 (all reference same i)

// Using let - each iteration has its own i
for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100);
}
// Output: 0, 1, 2 (correct!)
```

<ProgressCheckpoint section="syntax" xpReward={15} />

## for vs forEach vs for...of

Understanding when to use each:

```javascript
const numbers = [1, 2, 3, 4, 5];

// Traditional for - most control
for (let i = 0; i < numbers.length; i++) {
  if (numbers[i] === 3) break; // Can break
  console.log(numbers[i]);
}

// forEach - cleaner, but can't break
numbers.forEach((num, i) => {
  // Can't use break or continue here!
  console.log(num);
});

// for...of - modern, clean, can break
for (const num of numbers) {
  if (num === 3) break; // Can break
  console.log(num);
}
```

| Feature | for | forEach | for...of |
|:--------|:---:|:-------:|:--------:|
| Break/Continue |  |  |  |
| Access Index |  |  | * |
| Async/Await |  |  |  |
| Performance | Fastest | Slower | Medium |
| Readability | Medium | High | High |

*Use `entries()` for index: `for (const [i, val] of arr.entries())`

<CodePlayground 
  code={`const items = ['a', 'b', 'c', 'd', 'e'];

console.log('=== for loop (can break) ===');
for (let i = 0; i < items.length; i++) {
  if (items[i] === 'c') break;
  console.log(items[i]);
}

console.log('\\n=== for...of with entries ===');
for (const [index, value] of items.entries()) {
  console.log(\`[\${index}]: \${value}\`);
}`}
  title="Comparing Loop Styles"
/>

<ProgressCheckpoint section="examples" xpReward={15} />

## Advanced Patterns

### Loop Unrolling (Manual Optimization)

For performance-critical code, processing multiple elements per iteration:

```javascript
// Standard loop
for (let i = 0; i < arr.length; i++) {
  process(arr[i]);
}

// Unrolled (processes 4 at a time)
const len = arr.length;
const remainder = len % 4;
let i = 0;

// Handle remainder
while (i < remainder) {
  process(arr[i++]);
}

// Process 4 at a time
while (i < len) {
  process(arr[i++]);
  process(arr[i++]);
  process(arr[i++]);
  process(arr[i++]);
}
```

<InfoBox type="warning" title="Modern Engines are Smart">
Loop unrolling is rarely needed in JavaScript. Modern JIT compilers (V8, SpiderMonkey) often optimize loops automatically. Only unroll after profiling shows a genuine bottleneck.
</InfoBox>

### Generator-Based Iteration

For memory-efficient iteration over large sequences:

```javascript
function* range(start, end, step = 1) {
  for (let i = start; i < end; i += step) {
    yield i;
  }
}

// Iterate without creating a full array
for (const num of range(0, 1000000)) {
  if (num > 10) break;
  console.log(num);
}
```

### Parallel Processing with Indices

Distribute work across logical partitions:

```javascript
async function processInChunks(items, chunkSize = 100) {
  for (let i = 0; i < items.length; i += chunkSize) {
    const chunk = items.slice(i, i + chunkSize);
    await processChunk(chunk);
    
    // Yield to event loop between chunks
    await new Promise(resolve => setTimeout(resolve, 0));
  }
}
```

## Quiz: Advanced Concepts

<Quiz id="for-loop-advanced">
  <Question
    id="q1"
    text="Why iterate backwards when removing array elements?"
  >
    <Answer id="a" text="It's faster" />
    <Answer id="b" text="Removing shifts later indices, not earlier ones" isCorrect />
    <Answer id="c" text="JavaScript requires it" />
  </Question>
  <Question
    id="q2"
    text="Which loop type supports async/await inside the body?"
  >
    <Answer id="a" text="Only for loops" />
    <Answer id="b" text="for and for...of" isCorrect />
    <Answer id="c" text="All loop types including forEach" />
  </Question>
</Quiz>

<ProgressCheckpoint section="exercises" xpReward={25} />

## Performance Comparison

```javascript
// Benchmarking different approaches
const arr = Array.from({ length: 100000 }, (_, i) => i);

console.time('for loop');
let sum1 = 0;
for (let i = 0; i < arr.length; i++) sum1 += arr[i];
console.timeEnd('for loop');

console.time('for...of');
let sum2 = 0;
for (const n of arr) sum2 += n;
console.timeEnd('for...of');

console.time('forEach');
let sum3 = 0;
arr.forEach(n => sum3 += n);
console.timeEnd('forEach');

console.time('reduce');
const sum4 = arr.reduce((a, b) => a + b, 0);
console.timeEnd('reduce');
```

Typical results (varies by engine):
- **for loop**: ~1-2ms (fastest)
- **for...of**: ~2-3ms
- **forEach**: ~3-5ms
- **reduce**: ~4-6ms

> **Remember:** Readability often matters more than micro-optimizations. Use `for` when you need performance or control, use higher-order methods when you want clean, functional code.
