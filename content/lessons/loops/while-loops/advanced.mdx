# while and do...while: Advanced Patterns

Explore advanced uses of conditional loops including async patterns, state machines, and performance considerations.

## Async/Await with while

Unlike `forEach`, `while` loops work seamlessly with async/await:

```javascript
async function processQueue(queue) {
  while (queue.length > 0) {
    const item = queue.shift();
    await processItem(item); // Properly awaited!
    console.log(`Processed: ${item}`);
  }
}

// With forEach, this would NOT work as expected:
// queue.forEach(async (item) => {
//   await processItem(item); // Runs in parallel, not sequential!
// });
```

### Polling Pattern

```javascript
async function pollForResult(checkFn, interval = 1000, timeout = 30000) {
  const startTime = Date.now();
  
  while (Date.now() - startTime < timeout) {
    const result = await checkFn();
    
    if (result.ready) {
      return result.data;
    }
    
    await new Promise(resolve => setTimeout(resolve, interval));
  }
  
  throw new Error('Polling timeout exceeded');
}

// Usage
const result = await pollForResult(async () => {
  const response = await fetch('/api/status');
  return response.json();
});
```

<ProgressCheckpoint section="while-intro" xpReward={15} />

## State Machine Implementation

`while` loops are excellent for implementing state machines:

```javascript
function processStateMachine(input) {
  let state = 'START';
  let position = 0;
  const output = [];
  
  while (state !== 'END' && position < input.length) {
    const char = input[position];
    
    switch (state) {
      case 'START':
        if (char === '"') {
          state = 'IN_STRING';
        } else if (char === ' ') {
          // Skip whitespace
        } else {
          state = 'IN_WORD';
          output.push(char);
        }
        break;
        
      case 'IN_WORD':
        if (char === ' ' || char === '"') {
          state = char === '"' ? 'IN_STRING' : 'START';
        } else {
          output.push(char);
        }
        break;
        
      case 'IN_STRING':
        if (char === '"') {
          state = 'START';
        } else {
          output.push(char);
        }
        break;
    }
    
    position++;
  }
  
  return output.join('');
}
```

<ProgressCheckpoint section="do-while" xpReward={15} />

## Infinite Loop Patterns (Intentional)

### Event Loop / Server Pattern

```javascript
// Conceptual server loop
async function startServer() {
  let running = true;
  
  // Handle shutdown gracefully
  process.on('SIGTERM', () => {
    console.log('Shutdown signal received');
    running = false;
  });
  
  while (running) {
    try {
      const request = await waitForRequest();
      await handleRequest(request);
    } catch (error) {
      console.error('Error handling request:', error);
      // Continue running despite errors
    }
  }
  
  await cleanup();
  console.log('Server stopped');
}
```

### Animation Frame Loop

```javascript
function gameLoop() {
  let lastTime = performance.now();
  let running = true;
  
  function loop(currentTime) {
    if (!running) return;
    
    const deltaTime = currentTime - lastTime;
    lastTime = currentTime;
    
    update(deltaTime);
    render();
    
    requestAnimationFrame(loop);
  }
  
  requestAnimationFrame(loop);
  
  return {
    stop: () => { running = false; }
  };
}
```

<CodePlayground 
  code={`// Simulated async processing with while
async function simulateAsyncProcess() {
  const tasks = ['Load', 'Parse', 'Validate', 'Save'];
  let index = 0;
  
  while (index < tasks.length) {
    console.log(\`Processing: \${tasks[index]}...\`);
    
    // Simulate async operation
    await new Promise(r => setTimeout(r, 500));
    
    console.log(\` \${tasks[index]} complete\`);
    index++;
  }
  
  console.log('All tasks finished!');
}

simulateAsyncProcess();`}
  title="Async While Loop"
/>

<ProgressCheckpoint section="comparison" xpReward={15} />

## Performance Considerations

### Avoiding Tight Loops

A "tight loop" with no async operations blocks the event loop:

```javascript
// BAD: Blocks event loop completely
while (Date.now() < targetTime) {
  // Busy waiting - blocks everything!
}

// GOOD: Yield to event loop
async function waitUntil(targetTime) {
  while (Date.now() < targetTime) {
    await new Promise(resolve => setTimeout(resolve, 10));
  }
}

// BETTER: Use setTimeout directly for waiting
function waitUntil(targetTime) {
  return new Promise(resolve => {
    const remaining = targetTime - Date.now();
    setTimeout(resolve, Math.max(0, remaining));
  });
}
```

### Loop Optimization

```javascript
// Pre-calculate loop-invariant values
const items = /* large array */;
const length = items.length; // Cache outside loop
let i = 0;

while (i < length) {
  // Process items[i]
  i++;
}
```

## Advanced Control Flow

### Multiple Exit Conditions

```javascript
function findPattern(data, pattern, maxIterations = 1000) {
  let i = 0;
  let found = false;
  let timedOut = false;
  
  while (i < data.length && i < maxIterations && !found) {
    if (matchesPattern(data[i], pattern)) {
      found = true;
    }
    i++;
  }
  
  timedOut = i >= maxIterations && !found;
  
  return {
    found,
    index: found ? i - 1 : -1,
    timedOut,
    iterations: i
  };
}
```

### Backtracking Algorithm

```javascript
function solveMaze(maze, start, end) {
  const stack = [start];
  const visited = new Set();
  
  while (stack.length > 0) {
    const current = stack.pop();
    const key = `${current.x},${current.y}`;
    
    if (current.x === end.x && current.y === end.y) {
      return true; // Found path!
    }
    
    if (visited.has(key)) continue;
    visited.add(key);
    
    // Add valid neighbors to stack
    for (const neighbor of getNeighbors(maze, current)) {
      if (!visited.has(`${neighbor.x},${neighbor.y}`)) {
        stack.push(neighbor);
      }
    }
  }
  
  return false; // No path found
}
```

## Quiz: Advanced Concepts

<Quiz id="while-advanced">
  <Question
    id="q1"
    text="Why is 'while' better than 'forEach' for async sequential processing?"
  >
    <Answer id="a" text="It's faster" />
    <Answer id="b" text="forEach can't handle async/await properly" isCorrect />
    <Answer id="c" text="forEach doesn't work with arrays" />
  </Question>
  <Question
    id="q2"
    text="What's the danger of a 'tight loop' without async operations?"
  >
    <Answer id="a" text="It uses too much memory" />
    <Answer id="b" text="It blocks the event loop" isCorrect />
    <Answer id="c" text="It runs too slowly" />
  </Question>
</Quiz>

<ProgressCheckpoint section="use-cases" xpReward={25} />

## Summary: while vs do...while Decision Tree

```
Need at least one iteration?
├── Yes → do...while
└── No → while

Known iteration count?
├── Yes → Consider for loop
└── No → while or do...while

Async processing?
├── Yes → while (with await)
└── No → Any loop works

User input validation?
└── Usually → do...while
```

<InfoBox type="tip" title="Professional Tip">
In production code, always add safeguards against infinite loops:
- Maximum iteration counters
- Timeout mechanisms
- Graceful shutdown handlers
- Logging for debugging
</InfoBox>
