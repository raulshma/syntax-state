# Promise Internals and Advanced Patterns

Understanding Promises at a deeper level helps you write better async code and debug complex scenarios effectively.

## Promise States and Fates

A Promise has:

- **State**: `pending`, `fulfilled`, or `rejected`
- **Fate**: `resolved` (settled or "locked in" to another promise) or `unresolved`

```javascript
// A promise can be resolved but still pending!
const p1 = new Promise((resolve) => setTimeout(resolve, 1000));
const p2 = new Promise((resolve) => resolve(p1)); // Resolved to p1, but pending!

// p2 is "resolved" (locked to p1) but still "pending"
```

## The Microtask Queue

Promise callbacks always run as microtasks, giving them priority over macrotasks:

```javascript
console.log("1: Sync");

setTimeout(() => console.log("4: Macrotask"), 0);

Promise.resolve()
  .then(() => console.log("2: Microtask"))
  .then(() => console.log("3: Microtask"));

// Output: 1, 2, 3, 4
```

<PromiseChainBuilder showExecutionOrder={true} />

## All Static Methods Compared

```javascript
const fast = Promise.resolve("fast");
const slow = new Promise((r) => setTimeout(() => r("slow"), 100));
const fail = Promise.reject(new Error("fail"));

// Promise.all - All must succeed
Promise.all([fast, slow]).then(console.log); // ['fast', 'slow']

// Promise.allSettled - All results, success or failure
Promise.allSettled([fast, fail]).then(console.log);
// [{status: 'fulfilled', value: 'fast'}, {status: 'rejected', reason: Error}]

// Promise.race - First to settle
Promise.race([slow, fast]).then(console.log); // 'fast'

// Promise.any - First to fulfill (ES2021)
Promise.any([fail, slow, fast]).then(console.log); // 'fast' (ignores rejection)
```

## Custom Thenable Objects

Any object with a `.then()` method can be used with Promise methods:

```javascript
const thenable = {
  then(resolve, reject) {
    setTimeout(() => resolve("I am thenable!"), 100);
  },
};

Promise.resolve(thenable).then(console.log); // 'I am thenable!'

// Useful for interop with other promise libraries
```

## Anti-Patterns and Solutions

### Anti-Pattern 1: Nested Promises

```javascript
// ❌ Bad - unnecessary nesting
getUser().then((user) => {
  getPosts(user.id).then((posts) => {
    console.log(posts);
  });
});

// ✅ Good - flat chain
getUser()
  .then((user) => getPosts(user.id))
  .then((posts) => console.log(posts));
```

### Anti-Pattern 2: Missing Return

```javascript
// ❌ Bad - forgot to return
getUser()
  .then((user) => {
    getPosts(user.id); // Not returned!
  })
  .then((posts) => {
    console.log(posts); // undefined!
  });

// ✅ Good - return the promise
getUser()
  .then((user) => getPosts(user.id))
  .then((posts) => console.log(posts));
```

### Anti-Pattern 3: Swallowed Errors

```javascript
// ❌ Bad - error disappears
getUser().then((user) => {
  throw new Error("Oops");
}); // No .catch() - unhandled rejection!

// ✅ Good - always handle errors
getUser()
  .then((user) => {
    throw new Error("Oops");
  })
  .catch(console.error);
```

## Advanced Patterns

### Sequential Execution

```javascript
const urls = ["/api/1", "/api/2", "/api/3"];

// Sequential (one after another)
async function sequential(urls) {
  const results = [];
  for (const url of urls) {
    results.push(await fetch(url));
  }
  return results;
}

// Using reduce
urls.reduce(
  (promise, url) =>
    promise.then((results) =>
      fetch(url).then((result) => [...results, result])
    ),
  Promise.resolve([])
);
```

### Parallel with Concurrency Limit

```javascript
async function parallelLimit(tasks, limit) {
  const results = [];
  const executing = [];

  for (const task of tasks) {
    const p = Promise.resolve().then(task);
    results.push(p);

    if (limit <= tasks.length) {
      const e = p.then(() => executing.splice(executing.indexOf(e), 1));
      executing.push(e);
      if (executing.length >= limit) {
        await Promise.race(executing);
      }
    }
  }

  return Promise.all(results);
}
```

### Retry Pattern

```javascript
function retry(fn, maxAttempts = 3, delay = 1000) {
  return new Promise((resolve, reject) => {
    function attempt(n) {
      fn()
        .then(resolve)
        .catch((error) => {
          if (n >= maxAttempts) {
            reject(error);
          } else {
            setTimeout(() => attempt(n + 1), delay * n);
          }
        });
    }
    attempt(1);
  });
}

// Usage
retry(() => fetch("/flaky-api"))
  .then((response) => console.log("Success!"))
  .catch((error) => console.log("All retries failed"));
```

## Promise.withResolvers() (ES2024)

The newest addition simplifies creating deferred promises:

```javascript
// Old way
let resolve, reject;
const p = new Promise((res, rej) => {
  resolve = res;
  reject = rej;
});

// New way (ES2024)
const { promise, resolve, reject } = Promise.withResolvers();

// Resolve later
setTimeout(() => resolve("done"), 1000);
```

<ProgressCheckpoint section="promise-methods" xpReward={60} />
