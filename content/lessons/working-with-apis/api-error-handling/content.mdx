# Error Handling in API Calls: Building Resilient Apps

Network requests can fail in many ways - servers go down, connections drop, and APIs return errors. Proper error handling separates amateur code from production-ready applications. Let's build bulletproof API calls!

---

## Section 1: Types of API Errors

### The Error Landscape

When making API calls, you'll encounter different types of errors:

| Error Type | Cause | Example |
|:-----------|:------|:--------|
| **Network Error** | No connection, DNS failure | `fetch()` throws |
| **HTTP Error** | Server returned error status | 404, 500, 503 |
| **Parse Error** | Invalid response format | Bad JSON |
| **Timeout** | Request took too long | No response |
| **CORS Error** | Cross-origin blocked | Browser security |

```javascript
// Fetch does NOT throw on HTTP errors!
const response = await fetch('/api/data');

// This could be a 404 or 500, but no error thrown
console.log(response.status); // 404
console.log(response.ok);     // false

// You must check manually!
if (!response.ok) {
  throw new Error(`HTTP ${response.status}`);
}
```

<CodePlayground
  initialCode={`// Understanding different error types

async function demonstrateErrors() {
  // 1. HTTP Error (fetch succeeds, but status is error)
  console.log("=== HTTP Error ===");
  try {
    const response = await fetch('https://jsonplaceholder.typicode.com/posts/9999');
    console.log("Status:", response.status); // 404
    console.log("OK?:", response.ok);        // false
    // Fetch didn't throw! We must check ourselves
  } catch (e) {
    console.log("This won't run for 404");
  }
  
  // 2. Network Error (fetch throws)
  console.log("\\n=== Network Error ===");
  try {
    await fetch('https://this-domain-does-not-exist-12345.com/api');
  } catch (error) {
    console.log("Caught:", error.name);
    console.log("Message:", error.message);
  }
  
  // 3. Parse Error
  console.log("\\n=== Parse Error ===");
  try {
    JSON.parse("not valid json");
  } catch (error) {
    console.log("Caught:", error.name);
    console.log("Message:", error.message);
  }
}

demonstrateErrors();`}
  height={400}
/>

<KeyConcept title="Fetch Doesn't Throw on HTTP Errors!">
Unlike XHR or Axios, `fetch()` only throws on network failures. A 404 or 500 response is considered a "successful" fetch. Always check `response.ok` or `response.status`!
</KeyConcept>

<ProgressCheckpoint section="error-types" xpReward={20} />

---

## Section 2: Try-Catch Patterns

### Proper Error Handling Structure

```javascript
async function fetchData(url) {
  try {
    const response = await fetch(url);
    
    // Check HTTP status
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    
    // Parse response
    const data = await response.json();
    return data;
    
  } catch (error) {
    // Handle different error types
    if (error.name === 'TypeError') {
      console.error('Network error:', error.message);
    } else if (error.name === 'SyntaxError') {
      console.error('Invalid JSON:', error.message);
    } else {
      console.error('Request failed:', error.message);
    }
    throw error; // Re-throw or return fallback
  }
}
```


<CodePlayground
  initialCode={`// Comprehensive error handling

class ApiError extends Error {
  constructor(message, status, data = null) {
    super(message);
    this.name = 'ApiError';
    this.status = status;
    this.data = data;
  }
}

async function fetchWithErrorHandling(url, options = {}) {
  try {
    const response = await fetch(url, options);
    
    // Try to parse response body (might be error details)
    let data;
    const contentType = response.headers.get('content-type');
    
    if (contentType?.includes('application/json')) {
      data = await response.json();
    } else {
      data = await response.text();
    }
    
    // Check for HTTP errors
    if (!response.ok) {
      throw new ApiError(
        data.message || 'Request failed',
        response.status,
        data
      );
    }
    
    return data;
    
  } catch (error) {
    // Network error (fetch threw)
    if (error.name === 'TypeError') {
      throw new ApiError('Network error - check your connection', 0);
    }
    
    // Re-throw ApiError as-is
    if (error instanceof ApiError) {
      throw error;
    }
    
    // Unknown error
    throw new ApiError(error.message, 0);
  }
}

// Usage
async function demo() {
  try {
    // This will work
    const post = await fetchWithErrorHandling(
      'https://jsonplaceholder.typicode.com/posts/1'
    );
    console.log(" Success:", post.title);
    
    // This will throw ApiError (404)
    await fetchWithErrorHandling(
      'https://jsonplaceholder.typicode.com/posts/99999'
    );
  } catch (error) {
    console.log(" Error:", error.name);
    console.log("   Status:", error.status);
    console.log("   Message:", error.message);
  }
}

demo();`}
  height={500}
/>

<ProgressCheckpoint section="try-catch-patterns" xpReward={25} />

---

## Section 3: HTTP Status Codes

### Understanding Response Codes

| Range | Category | Common Codes |
|:------|:---------|:-------------|
| 2xx | Success | 200 OK, 201 Created, 204 No Content |
| 3xx | Redirect | 301 Moved, 304 Not Modified |
| 4xx | Client Error | 400 Bad Request, 401 Unauthorized, 403 Forbidden, 404 Not Found, 429 Too Many Requests |
| 5xx | Server Error | 500 Internal Error, 502 Bad Gateway, 503 Service Unavailable |

<CodePlayground
  initialCode={`// Handling different status codes

async function handleApiResponse(url) {
  const response = await fetch(url);
  
  switch (response.status) {
    case 200:
    case 201:
      console.log(" Success!");
      return response.json();
      
    case 204:
      console.log(" Success (no content)");
      return null;
      
    case 400:
      console.log(" Bad request - check your data");
      throw new Error("Invalid request data");
      
    case 401:
      console.log(" Unauthorized - please log in");
      // Redirect to login?
      throw new Error("Authentication required");
      
    case 403:
      console.log(" Forbidden - you don't have permission");
      throw new Error("Access denied");
      
    case 404:
      console.log(" Not found");
      throw new Error("Resource not found");
      
    case 429:
      console.log("â³ Too many requests - slow down!");
      const retryAfter = response.headers.get('Retry-After');
      throw new Error("Rate limited. Retry after: " + retryAfter);
      
    case 500:
    case 502:
    case 503:
      console.log(" Server error - try again later");
      throw new Error("Server error");
      
    default:
      console.log(" Unexpected status:", response.status);
      throw new Error("Unexpected response: " + response.status);
  }
}

// Test with different endpoints
async function demo() {
  try {
    await handleApiResponse('https://jsonplaceholder.typicode.com/posts/1');
  } catch (e) {
    console.log("Caught:", e.message);
  }
  
  try {
    await handleApiResponse('https://jsonplaceholder.typicode.com/posts/99999');
  } catch (e) {
    console.log("Caught:", e.message);
  }
}

demo();`}
  height={500}
/>

<ProgressCheckpoint section="http-status-codes" xpReward={20} />

---

## Section 4: Building Resilient Requests

### Retry Logic with Exponential Backoff

<CodePlayground
  initialCode={`// Production-ready fetch with retries and timeout

async function resilientFetch(url, options = {}) {
  const {
    retries = 3,
    timeout = 10000,
    retryDelay = 1000,
    retryOn = [408, 429, 500, 502, 503, 504],
    ...fetchOptions
  } = options;
  
  let lastError;
  
  for (let attempt = 0; attempt <= retries; attempt++) {
    // Create abort controller for timeout
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);
    
    try {
      console.log("Attempt " + (attempt + 1) + "...");
      
      const response = await fetch(url, {
        ...fetchOptions,
        signal: controller.signal
      });
      
      clearTimeout(timeoutId);
      
      // Check if we should retry this status
      if (!response.ok && retryOn.includes(response.status)) {
        throw new Error("HTTP " + response.status);
      }
      
      if (!response.ok) {
        throw new Error("HTTP " + response.status + " (no retry)");
      }
      
      return response;
      
    } catch (error) {
      clearTimeout(timeoutId);
      lastError = error;
      
      // Don't retry on abort or if out of retries
      if (error.name === 'AbortError') {
        lastError = new Error('Request timeout');
      }
      
      if (attempt < retries) {
        // Exponential backoff: 1s, 2s, 4s...
        const delay = retryDelay * Math.pow(2, attempt);
        console.log("Retrying in " + delay + "ms...");
        await new Promise(r => setTimeout(r, delay));
      }
    }
  }
  
  throw lastError;
}

// Usage
async function demo() {
  try {
    const response = await resilientFetch(
      'https://jsonplaceholder.typicode.com/posts/1',
      { retries: 2, timeout: 5000 }
    );
    const data = await response.json();
    console.log(" Got data:", data.title);
  } catch (error) {
    console.log(" All retries failed:", error.message);
  }
}

demo();`}
  height={520}
/>

### Complete API Client Pattern

```javascript
class ApiClient {
  constructor(baseUrl, options = {}) {
    this.baseUrl = baseUrl;
    this.defaultHeaders = options.headers || {};
    this.timeout = options.timeout || 10000;
  }
  
  async request(endpoint, options = {}) {
    const url = this.baseUrl + endpoint;
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), this.timeout);
    
    try {
      const response = await fetch(url, {
        ...options,
        headers: { ...this.defaultHeaders, ...options.headers },
        signal: controller.signal
      });
      
      clearTimeout(timeoutId);
      
      if (!response.ok) {
        const error = await response.json().catch(() => ({}));
        throw new ApiError(error.message || 'Request failed', response.status);
      }
      
      return response.json();
    } catch (error) {
      clearTimeout(timeoutId);
      if (error.name === 'AbortError') {
        throw new ApiError('Request timeout', 408);
      }
      throw error;
    }
  }
  
  get(endpoint) { return this.request(endpoint); }
  post(endpoint, data) {
    return this.request(endpoint, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data)
    });
  }
}
```

<Quiz id="error-handling-quiz">
  <Question>When does fetch() throw an error?</Question>
  <Answer>When the server returns a 404</Answer>
  <Answer>When the server returns a 500</Answer>
  <Answer correct>When there's a network failure</Answer>
  <Answer>When the response is not JSON</Answer>
</Quiz>

### Error Handling Checklist

-  Always check `response.ok` or `response.status`
-  Wrap fetch in try-catch for network errors
-  Handle JSON parse errors separately
-  Implement timeouts with AbortController
-  Add retry logic for transient failures
-  Show user-friendly error messages
-  Log errors for debugging

<ProgressCheckpoint section="resilient-requests" xpReward={20} />
