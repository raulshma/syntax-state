# Database Providers Overview

One of EF Core's greatest strengths is its **provider model** - you can switch between different databases with minimal code changes. Let's explore the available providers and learn how to choose the right one for your project.

---

## Section 1: What Are Database Providers?

### The Universal Adapter Analogy 

Imagine you're traveling internationally with your laptop. Different countries have different electrical outlets:
- USA uses Type A/B plugs
- Europe uses Type C/F plugs
- UK uses Type G plugs

You don't buy a different laptop for each country - you use a **universal adapter** that translates between your device and the local outlet.

**Database providers work the same way!**

| Travel | EF Core |
|:-------|:--------|
| Your laptop | Your C# code |
| Universal adapter | Database provider |
| Local outlet | Database server |
| Electricity | Your data |

<InfoBox type="info">
A **database provider** is a NuGet package that translates EF Core operations into database-specific SQL and handles communication with that database system.
</InfoBox>

### How Providers Work

<DotnetCodePreview
  title="Provider Architecture"
  code={`// Your code stays the same regardless of database!
var customers = await context.Customers
    .Where(c => c.IsActive)
    .OrderBy(c => c.Name)
    .ToListAsync();

// SQL Server provider generates:
// SELECT * FROM Customers WHERE IsActive = 1 ORDER BY Name

// PostgreSQL provider generates:
// SELECT * FROM "Customers" WHERE "IsActive" = true ORDER BY "Name"

// SQLite provider generates:
// SELECT * FROM Customers WHERE IsActive = 1 ORDER BY Name

// Same C# code, different SQL dialects!`}
  steps={[
    {
      lineNumbers: [2, 3, 4, 5],
      highlight: "Your LINQ Code",
      explanation: "Write database-agnostic C# code using LINQ"
    },
    {
      lineNumbers: [8],
      highlight: "SQL Server",
      explanation: "SQL Server uses 1/0 for booleans, no quotes on identifiers"
    },
    {
      lineNumbers: [11],
      highlight: "PostgreSQL",
      explanation: "PostgreSQL uses true/false, quotes identifiers"
    },
    {
      lineNumbers: [14],
      highlight: "SQLite",
      explanation: "SQLite has its own dialect - provider handles it"
    }
  ]}
/>

<KeyConcept title="Write Once, Run Anywhere">
EF Core's provider model means you can write your data access code once and run it against different databases. This is powerful for testing (SQLite in-memory) and flexibility (switching databases later).
</KeyConcept>

<ProgressCheckpoint section="what-are-providers" xpReward={15} />

---

## Section 2: Popular Database Providers

### Microsoft SQL Server

The most common choice for .NET applications, especially in enterprise environments.

<DotnetCodePreview
  title="SQL Server Provider Setup"
  code={`// Install NuGet package
// dotnet add package Microsoft.EntityFrameworkCore.SqlServer

// Configure in Program.cs
builder.Services.AddDbContext<AppDbContext>(options =>
    options.UseSqlServer(
        builder.Configuration.GetConnectionString("DefaultConnection"),
        sqlOptions =>
        {
            sqlOptions.EnableRetryOnFailure();
            sqlOptions.CommandTimeout(60);
            sqlOptions.UseQuerySplittingBehavior(QuerySplittingBehavior.SplitQuery);
        }));

// Connection string examples
// LocalDB: Server=(localdb)\\mssqllocaldb;Database=MyApp;Trusted_Connection=True;
// Azure SQL: Server=tcp:myserver.database.windows.net;Database=MyApp;...`}
  steps={[
    {
      lineNumbers: [2],
      highlight: "Install Package",
      explanation: "Add the SQL Server provider NuGet package"
    },
    {
      lineNumbers: [5, 6, 7],
      highlight: "UseSqlServer",
      explanation: "Configure DbContext to use SQL Server"
    },
    {
      lineNumbers: [10, 11, 12],
      highlight: "Provider Options",
      explanation: "SQL Server-specific options like retry logic and timeouts"
    }
  ]}
/>

| Pros | Cons |
|:-----|:-----|
|  Best .NET integration |  Licensing costs (except Express) |
|  Excellent tooling (SSMS) |  Windows-centric (though Linux supported) |
|  Azure SQL integration |  Resource-heavy for small projects |
|  Advanced features (temporal tables, JSON) | |

### PostgreSQL

Open-source, powerful, and increasingly popular for .NET applications.

<DotnetCodePreview
  title="PostgreSQL Provider Setup"
  code={`// Install NuGet package
// dotnet add package Npgsql.EntityFrameworkCore.PostgreSQL

// Configure in Program.cs
builder.Services.AddDbContext<AppDbContext>(options =>
    options.UseNpgsql(
        builder.Configuration.GetConnectionString("DefaultConnection"),
        npgsqlOptions =>
        {
            npgsqlOptions.EnableRetryOnFailure();
            npgsqlOptions.CommandTimeout(60);
            // PostgreSQL-specific: Use NodaTime for dates
            // npgsqlOptions.UseNodaTime();
        }));

// Connection string
// Host=localhost;Database=myapp;Username=postgres;Password=secret;`}
  steps={[
    {
      lineNumbers: [2],
      highlight: "Npgsql Package",
      explanation: "Npgsql is the official PostgreSQL provider for EF Core"
    },
    {
      lineNumbers: [6],
      highlight: "UseNpgsql",
      explanation: "Configure DbContext to use PostgreSQL"
    },
    {
      lineNumbers: [13],
      highlight: "NodaTime Support",
      explanation: "PostgreSQL provider has excellent date/time handling with NodaTime"
    }
  ]}
/>

| Pros | Cons |
|:-----|:-----|
|  Free and open-source |  Less .NET-specific tooling |
|  Excellent performance |  Different SQL dialect to learn |
|  Advanced features (JSONB, arrays) |  Smaller .NET community |
|  Great for cloud deployments | |

### SQLite

Lightweight, file-based database - perfect for development, testing, and mobile apps.

<DotnetCodePreview
  title="SQLite Provider Setup"
  code={`// Install NuGet package
// dotnet add package Microsoft.EntityFrameworkCore.Sqlite

// Configure in Program.cs
builder.Services.AddDbContext<AppDbContext>(options =>
    options.UseSqlite(
        builder.Configuration.GetConnectionString("DefaultConnection")));

// Connection strings
// File-based: Data Source=app.db;
// In-memory (testing): Data Source=:memory:;

// For testing with in-memory SQLite
builder.Services.AddDbContext<AppDbContext>(options =>
{
    var connection = new SqliteConnection("Data Source=:memory:");
    connection.Open(); // Keep connection open for in-memory
    options.UseSqlite(connection);
});`}
  steps={[
    {
      lineNumbers: [2],
      highlight: "SQLite Package",
      explanation: "Microsoft's official SQLite provider"
    },
    {
      lineNumbers: [10],
      highlight: "File-Based",
      explanation: "SQLite stores everything in a single file - no server needed!"
    },
    {
      lineNumbers: [11],
      highlight: "In-Memory",
      explanation: "Perfect for unit tests - fast and isolated"
    },
    {
      lineNumbers: [15, 16, 17],
      highlight: "Keep Connection Open",
      explanation: "In-memory databases disappear when connection closes"
    }
  ]}
/>

| Pros | Cons |
|:-----|:-----|
|  Zero configuration |  Limited concurrency |
|  Perfect for testing |  No stored procedures |
|  Embedded/mobile apps |  Limited data types |
|  Single file deployment |  Not for high-traffic web apps |

### MySQL / MariaDB

Popular open-source database with strong community support.

<DotnetCodePreview
  title="MySQL Provider Setup"
  code={`// Install NuGet package (Pomelo is recommended)
// dotnet add package Pomelo.EntityFrameworkCore.MySql

// Configure in Program.cs
var serverVersion = new MySqlServerVersion(new Version(8, 0, 31));

builder.Services.AddDbContext<AppDbContext>(options =>
    options.UseMySql(
        builder.Configuration.GetConnectionString("DefaultConnection"),
        serverVersion,
        mySqlOptions =>
        {
            mySqlOptions.EnableRetryOnFailure();
        }));

// Connection string
// Server=localhost;Database=myapp;User=root;Password=secret;`}
  steps={[
    {
      lineNumbers: [2],
      highlight: "Pomelo Provider",
      explanation: "Pomelo is the most popular MySQL provider for EF Core"
    },
    {
      lineNumbers: [5],
      highlight: "Server Version",
      explanation: "MySQL provider needs to know the server version for compatibility"
    },
    {
      lineNumbers: [8, 9, 10],
      highlight: "UseMySql",
      explanation: "Pass connection string and server version"
    }
  ]}
/>

### In-Memory Provider (Testing Only)

<DotnetCodePreview
  title="In-Memory Provider for Testing"
  code={`// Install NuGet package
// dotnet add package Microsoft.EntityFrameworkCore.InMemory

// Configure for testing
services.AddDbContext<AppDbContext>(options =>
    options.UseInMemoryDatabase("TestDatabase"));

// ️ WARNING: In-Memory provider has limitations!
// - No referential integrity
// - No transactions
// - Different behavior than real databases
// - Use SQLite in-memory for more realistic tests`}
  steps={[
    {
      lineNumbers: [5, 6],
      highlight: "UseInMemoryDatabase",
      explanation: "Creates a fast in-memory database for testing"
    },
    {
      lineNumbers: [8, 9, 10, 11, 12],
      highlight: "Limitations",
      explanation: "In-Memory doesn't behave like a real database - use carefully!"
    }
  ]}
/>

<InfoBox type="warning">
**Testing Tip:** The In-Memory provider doesn't enforce foreign keys or constraints. For more realistic tests, use SQLite in-memory mode instead!
</InfoBox>

<ProgressCheckpoint section="popular-providers" xpReward={25} />

---

## Section 3: Choosing the Right Provider

### Decision Matrix

<Comparison
  title="When to Use Each Provider"
  items={[
    {
      label: "SQL Server",
      description: "Enterprise apps, Azure deployments, need advanced features like temporal tables",
      isCorrect: true
    },
    {
      label: "PostgreSQL",
      description: "Open-source preference, need JSONB/arrays, Linux deployments, cost-conscious",
      isCorrect: true
    },
    {
      label: "SQLite",
      description: "Desktop apps, mobile apps, unit testing, prototyping, embedded scenarios",
      isCorrect: true
    },
    {
      label: "MySQL",
      description: "Existing MySQL infrastructure, WordPress/PHP migration, shared hosting",
      isCorrect: true
    },
    {
      label: "In-Memory",
      description: "Quick unit tests only - not for integration tests or production!",
      isCorrect: true
    }
  ]}
/>

### Feature Comparison

| Feature | SQL Server | PostgreSQL | SQLite | MySQL |
|:--------|:-----------|:-----------|:-------|:------|
| **Cost** | Licensed* | Free | Free | Free |
| **Hosting** | Windows/Linux/Azure | Any | Embedded | Any |
| **JSON Support** |  Good |  Excellent | ️ Limited |  Good |
| **Full-Text Search** |  Built-in |  Built-in |  No |  Built-in |
| **Spatial Data** |  Yes |  PostGIS |  SpatiaLite |  Yes |
| **Temporal Tables** |  Yes |  No |  No |  No |

*SQL Server Express is free with limitations

### Questions to Ask

When choosing a provider, consider:

1. **What's your budget?** SQL Server licensing can be expensive
2. **Where will you host?** Azure favors SQL Server, Linux favors PostgreSQL
3. **What features do you need?** Temporal tables? JSONB? Full-text search?
4. **What does your team know?** Familiarity reduces learning curve
5. **What's your scale?** SQLite for small, PostgreSQL/SQL Server for large

<ProgressCheckpoint section="choosing-provider" xpReward={20} />

---

## Section 4: Switching Providers

### The Power of Abstraction

One of EF Core's best features is the ability to switch providers with minimal code changes:

<DotnetCodePreview
  title="Multi-Provider Configuration"
  code={`// Program.cs - Choose provider based on configuration
var provider = builder.Configuration["DatabaseProvider"];
var connectionString = builder.Configuration.GetConnectionString("DefaultConnection");

builder.Services.AddDbContext<AppDbContext>(options =>
{
    switch (provider)
    {
        case "SqlServer":
            options.UseSqlServer(connectionString);
            break;
        case "PostgreSQL":
            options.UseNpgsql(connectionString);
            break;
        case "SQLite":
            options.UseSqlite(connectionString);
            break;
        default:
            throw new InvalidOperationException($"Unknown provider: {provider}");
    }
});

// appsettings.json
{
  "DatabaseProvider": "SqlServer",
  "ConnectionStrings": {
    "DefaultConnection": "Server=..."
  }
}`}
  steps={[
    {
      lineNumbers: [2],
      highlight: "Read Provider",
      explanation: "Store the provider choice in configuration"
    },
    {
      lineNumbers: [6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
      highlight: "Switch Provider",
      explanation: "Configure the appropriate provider based on settings"
    },
    {
      lineNumbers: [24],
      highlight: "Config Setting",
      explanation: "Change this value to switch databases!"
    }
  ]}
/>

### What Changes When Switching

<DotnetCodePreview
  title="Provider-Specific Considerations"
  code={`// Most LINQ queries work across all providers
var customers = await context.Customers
    .Where(c => c.IsActive)
    .ToListAsync(); //  Works everywhere

// Some features are provider-specific
var results = await context.Products
    .Where(p => EF.Functions.Like(p.Name, "%phone%"))
    .ToListAsync(); //  Works everywhere (translated differently)

// SQL Server specific
var temporal = await context.Orders
    .TemporalAll()
    .ToListAsync(); //  Only SQL Server!

// PostgreSQL specific
var jsonQuery = await context.Documents
    .Where(d => d.Data.RootElement.GetProperty("status").GetString() == "active")
    .ToListAsync(); // ️ JSONB works best in PostgreSQL

// Migrations are provider-specific!
// You'll need separate migrations for each provider`}
  steps={[
    {
      lineNumbers: [2, 3, 4],
      highlight: "Universal LINQ",
      explanation: "Basic LINQ queries work on all providers"
    },
    {
      lineNumbers: [7, 8, 9],
      highlight: "EF.Functions",
      explanation: "Some functions translate differently per provider"
    },
    {
      lineNumbers: [12, 13, 14],
      highlight: "Provider-Specific",
      explanation: "Some features only exist in certain databases"
    },
    {
      lineNumbers: [21, 22],
      highlight: "Migrations",
      explanation: "Each provider generates different migration SQL"
    }
  ]}
/>

<InfoBox type="tip">
**Pro Tip:** If you plan to support multiple databases, avoid provider-specific features in your core code. Use the repository pattern to isolate database-specific logic.
</InfoBox>

### Quick Knowledge Check

<Quiz id="provider-purpose-quiz">
  <Question>What is the main purpose of a database provider in EF Core?</Question>
  <Answer>To create database backups</Answer>
  <Answer correct>To translate EF Core operations into database-specific SQL</Answer>
  <Answer>To encrypt database connections</Answer>
  <Answer>To manage database users</Answer>
</Quiz>

<Quiz id="sqlite-use-case-quiz">
  <Question>Which scenario is SQLite best suited for?</Question>
  <Answer>High-traffic e-commerce website</Answer>
  <Answer>Enterprise data warehouse</Answer>
  <Answer correct>Unit testing and desktop applications</Answer>
  <Answer>Real-time multiplayer game server</Answer>
</Quiz>

<Quiz id="provider-switching-quiz">
  <Question>What typically needs to change when switching database providers?</Question>
  <Answer>All your LINQ queries</Answer>
  <Answer>Your entity classes</Answer>
  <Answer correct>Connection string and migrations</Answer>
  <Answer>Your entire application architecture</Answer>
</Quiz>

### Summary

| Provider | Best For | NuGet Package |
|:---------|:---------|:--------------|
| **SQL Server** | Enterprise, Azure | Microsoft.EntityFrameworkCore.SqlServer |
| **PostgreSQL** | Open-source, Linux | Npgsql.EntityFrameworkCore.PostgreSQL |
| **SQLite** | Testing, embedded | Microsoft.EntityFrameworkCore.Sqlite |
| **MySQL** | Existing MySQL apps | Pomelo.EntityFrameworkCore.MySql |
| **In-Memory** | Quick unit tests | Microsoft.EntityFrameworkCore.InMemory |

<KeyConcept title="Milestone Complete!">
Congratulations! You've completed the **DbContext and DbSet** milestone! You now understand:
- How DbContext manages database sessions
- DbSet as your gateway to data
- Secure connection string configuration
- Different database providers and when to use them

Next up: **Entity Configuration** - learn to shape your database schema with conventions, annotations, and Fluent API!
</KeyConcept>

<ProgressCheckpoint section="switching-providers" xpReward={15} />
