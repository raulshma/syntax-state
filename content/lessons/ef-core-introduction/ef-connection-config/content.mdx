# Connection Strings and Configuration

Every database connection starts with a **connection string** - the address and credentials that tell EF Core how to reach your database. Getting this right is essential for both development and production environments.

---

## Section 1: Connection String Basics

### The Address Analogy 

Think of a connection string like a detailed mailing address:

| Address Part | Connection String Part |
|:-------------|:-----------------------|
| Street address | Server name/address |
| Apartment number | Database name |
| Access code | Username/Password |
| Special instructions | Additional options |

Just like you need the complete address to deliver a package, EF Core needs a complete connection string to connect to your database.

<InfoBox type="info">
A **connection string** is a semicolon-separated list of key-value pairs that specify how to connect to a database. Each database provider has its own format.
</InfoBox>

### SQL Server Connection Strings

<DotnetCodePreview
  title="SQL Server Connection String Formats"
  code={`// Local development with LocalDB
Server=(localdb)\\mssqllocaldb;Database=MyApp;Trusted_Connection=True;

// SQL Server with Windows Authentication
Server=myserver;Database=MyApp;Trusted_Connection=True;

// SQL Server with SQL Authentication
Server=myserver;Database=MyApp;User Id=myuser;Password=mypassword;

// Azure SQL Database
Server=tcp:myserver.database.windows.net,1433;Database=MyApp;User Id=myuser;Password=mypassword;Encrypt=True;

// With additional options
Server=myserver;Database=MyApp;User Id=myuser;Password=mypassword;
MultipleActiveResultSets=True;TrustServerCertificate=True;
Connection Timeout=30;`}
  steps={[
    {
      lineNumbers: [2],
      highlight: "LocalDB",
      explanation: "LocalDB is perfect for development - no installation needed!"
    },
    {
      lineNumbers: [5],
      highlight: "Windows Auth",
      explanation: "Trusted_Connection=True uses your Windows credentials"
    },
    {
      lineNumbers: [8],
      highlight: "SQL Auth",
      explanation: "Explicit username and password for SQL Server authentication"
    },
    {
      lineNumbers: [11],
      highlight: "Azure SQL",
      explanation: "Azure requires TCP protocol, port, and encryption"
    },
    {
      lineNumbers: [14, 15, 16],
      highlight: "Options",
      explanation: "Additional options for MARS, certificates, and timeouts"
    }
  ]}
/>

### Other Database Providers

<DotnetCodePreview
  title="Connection Strings for Different Databases"
  code={`// PostgreSQL
Host=localhost;Database=myapp;Username=postgres;Password=secret;

// MySQL
Server=localhost;Database=myapp;User=root;Password=secret;

// SQLite (file-based)
Data Source=app.db;

// SQLite (in-memory for testing)
Data Source=:memory:;

// Cosmos DB
AccountEndpoint=https://myaccount.documents.azure.com:443/;
AccountKey=mykey;Database=myapp;`}
  steps={[
    {
      lineNumbers: [2],
      highlight: "PostgreSQL",
      explanation: "Uses Host instead of Server, Username instead of User Id"
    },
    {
      lineNumbers: [5],
      highlight: "MySQL",
      explanation: "Similar to SQL Server but with slight naming differences"
    },
    {
      lineNumbers: [8],
      highlight: "SQLite File",
      explanation: "Just specify the file path - SQLite is serverless!"
    },
    {
      lineNumbers: [11],
      highlight: "SQLite Memory",
      explanation: "In-memory database - great for unit testing"
    },
    {
      lineNumbers: [14, 15],
      highlight: "Cosmos DB",
      explanation: "NoSQL database with endpoint and account key"
    }
  ]}
/>

<KeyConcept title="Provider-Specific Formats">
Each database provider has its own connection string format. Always check the provider's documentation for the correct syntax and available options.
</KeyConcept>

<ProgressCheckpoint section="connection-string-basics" xpReward={20} />

---

## Section 2: Configuration Sources

### Where to Store Connection Strings

In .NET applications, you have several options for storing connection strings:

| Source | Best For | Security |
|:-------|:---------|:---------|
| appsettings.json | Development defaults | ️ Low (in source control) |
| appsettings.{Environment}.json | Environment-specific | ️ Low |
| User Secrets | Local development |  Good (not in source) |
| Environment Variables | Production |  Good |
| Azure Key Vault | Production secrets |  Excellent |

### Using appsettings.json

<DotnetCodePreview
  title="Configuration in appsettings.json"
  code={`// appsettings.json
{
  "ConnectionStrings": {
    "DefaultConnection": "Server=(localdb)\\\\mssqllocaldb;Database=MyApp;Trusted_Connection=True;"
  }
}

// appsettings.Development.json (overrides for dev)
{
  "ConnectionStrings": {
    "DefaultConnection": "Server=(localdb)\\\\mssqllocaldb;Database=MyApp_Dev;Trusted_Connection=True;"
  }
}

// Program.cs - Reading the connection string
var connectionString = builder.Configuration.GetConnectionString("DefaultConnection");

builder.Services.AddDbContext<AppDbContext>(options =>
    options.UseSqlServer(connectionString));`}
  steps={[
    {
      lineNumbers: [2, 3, 4, 5, 6],
      highlight: "Base Config",
      explanation: "appsettings.json contains default/fallback values"
    },
    {
      lineNumbers: [9, 10, 11, 12, 13],
      highlight: "Environment Override",
      explanation: "Environment-specific files override base settings"
    },
    {
      lineNumbers: [16],
      highlight: "Read Config",
      explanation: "GetConnectionString is a shortcut for ConnectionStrings section"
    },
    {
      lineNumbers: [18, 19],
      highlight: "Use in DbContext",
      explanation: "Pass the connection string to your database provider"
    }
  ]}
/>

### Using User Secrets (Development)

<DotnetCodePreview
  title="User Secrets for Development"
  code={`// Step 1: Initialize user secrets (run in terminal)
// dotnet user-secrets init

// Step 2: Set a secret
// dotnet user-secrets set "ConnectionStrings:DefaultConnection" "Server=...;Password=secret123"

// Step 3: Access in code (automatic in ASP.NET Core)
// User secrets are automatically loaded in Development environment

// Program.cs
var builder = WebApplication.CreateBuilder(args);

// In Development, this reads from:
// 1. appsettings.json
// 2. appsettings.Development.json
// 3. User Secrets (highest priority)
// 4. Environment variables

var connectionString = builder.Configuration.GetConnectionString("DefaultConnection");`}
  steps={[
    {
      lineNumbers: [2],
      highlight: "Initialize",
      explanation: "Creates a secrets.json file outside your project"
    },
    {
      lineNumbers: [5],
      highlight: "Set Secret",
      explanation: "Store sensitive values that won't be committed to git"
    },
    {
      lineNumbers: [13, 14, 15, 16, 17],
      highlight: "Priority Order",
      explanation: "Configuration sources are layered - later sources override earlier ones"
    }
  ]}
/>

<InfoBox type="tip">
**Pro Tip:** User Secrets are stored in your user profile folder, not in your project. They're perfect for keeping passwords out of source control during development!
</InfoBox>

### Using Environment Variables

<DotnetCodePreview
  title="Environment Variables Configuration"
  code={`// Set environment variable (Windows PowerShell)
// $env:ConnectionStrings__DefaultConnection = "Server=prod;Database=MyApp;..."

// Set environment variable (Linux/Mac)
// export ConnectionStrings__DefaultConnection="Server=prod;Database=MyApp;..."

// Docker / docker-compose.yml
services:
  myapp:
    environment:
      - ConnectionStrings__DefaultConnection=Server=db;Database=MyApp;...

// Azure App Service - Application Settings
// Name: ConnectionStrings__DefaultConnection
// Value: Server=...

// Note: Use double underscore (__) to represent nested JSON
// ConnectionStrings__DefaultConnection = ConnectionStrings:DefaultConnection`}
  steps={[
    {
      lineNumbers: [2],
      highlight: "Windows",
      explanation: "Set environment variable in PowerShell"
    },
    {
      lineNumbers: [5],
      highlight: "Linux/Mac",
      explanation: "Export environment variable in bash"
    },
    {
      lineNumbers: [8, 9, 10, 11],
      highlight: "Docker",
      explanation: "Set in docker-compose for containerized apps"
    },
    {
      lineNumbers: [17],
      highlight: "Naming Convention",
      explanation: "Double underscore represents JSON nesting in env vars"
    }
  ]}
/>

<ProgressCheckpoint section="configuration-sources" xpReward={20} />

---

## Section 3: Secure Configuration

### Never Hardcode Secrets!

<Comparison
  title="Connection String Security"
  items={[
    {
      label: " Hardcoded in code",
      description: "options.UseSqlServer(\"Server=...;Password=secret\") - Exposed in source control!",
      isCorrect: false
    },
    {
      label: " In appsettings.json with password",
      description: "Committed to git, visible to anyone with repo access",
      isCorrect: false
    },
    {
      label: " User Secrets (dev)",
      description: "Stored outside project, not in source control",
      isCorrect: true
    },
    {
      label: " Environment Variables (prod)",
      description: "Set at deployment time, not in code",
      isCorrect: true
    },
    {
      label: " Azure Key Vault (prod)",
      description: "Centralized secret management with access control",
      isCorrect: true
    }
  ]}
/>

### The "name=" Syntax

EF Core supports a special syntax to read connection strings directly from configuration:

<DotnetCodePreview
  title="Using name= Syntax"
  code={`// Instead of reading the connection string yourself...
var connectionString = builder.Configuration.GetConnectionString("DefaultConnection");
builder.Services.AddDbContext<AppDbContext>(options =>
    options.UseSqlServer(connectionString));

// You can use the name= syntax
builder.Services.AddDbContext<AppDbContext>(options =>
    options.UseSqlServer("name=ConnectionStrings:DefaultConnection"));

// Or the shorthand version
builder.Services.AddDbContext<AppDbContext>(options =>
    options.UseSqlServer("name=DefaultConnection"));

// This is especially useful in OnConfiguring
protected override void OnConfiguring(DbContextOptionsBuilder options)
{
    // EF Core reads from IConfiguration automatically
    options.UseSqlServer("name=DefaultConnection");
}`}
  steps={[
    {
      lineNumbers: [2, 3, 4],
      highlight: "Traditional Way",
      explanation: "Manually read connection string, then pass to provider"
    },
    {
      lineNumbers: [7, 8],
      highlight: "name= Syntax",
      explanation: "EF Core reads from configuration automatically"
    },
    {
      lineNumbers: [11, 12],
      highlight: "Shorthand",
      explanation: "For ConnectionStrings section, you can omit the prefix"
    },
    {
      lineNumbers: [15, 16, 17, 18],
      highlight: "In OnConfiguring",
      explanation: "Works in DbContext too when IConfiguration is available"
    }
  ]}
/>

### Azure Key Vault Integration

<DotnetCodePreview
  title="Azure Key Vault for Production Secrets"
  code={`// Install package: Azure.Extensions.AspNetCore.Configuration.Secrets

// Program.cs
var builder = WebApplication.CreateBuilder(args);

// Add Azure Key Vault as configuration source
if (builder.Environment.IsProduction())
{
    var keyVaultUrl = builder.Configuration["KeyVault:Url"];
    builder.Configuration.AddAzureKeyVault(
        new Uri(keyVaultUrl!),
        new DefaultAzureCredential());
}

// Now secrets from Key Vault are available like any other config
var connectionString = builder.Configuration.GetConnectionString("DefaultConnection");

// In Key Vault, create a secret named:
// "ConnectionStrings--DefaultConnection"
// (Azure Key Vault uses -- instead of : or __)`}
  steps={[
    {
      lineNumbers: [6, 7, 8, 9, 10, 11, 12],
      highlight: "Add Key Vault",
      explanation: "Only add Key Vault in production for security"
    },
    {
      lineNumbers: [11],
      highlight: "Managed Identity",
      explanation: "DefaultAzureCredential uses managed identity in Azure"
    },
    {
      lineNumbers: [15],
      highlight: "Transparent Access",
      explanation: "Access secrets the same way as any configuration"
    },
    {
      lineNumbers: [18, 19],
      highlight: "Naming Convention",
      explanation: "Key Vault uses -- for nested keys"
    }
  ]}
/>

<ProgressCheckpoint section="secure-configuration" xpReward={25} />

---

## Section 4: Advanced Options

### Connection Resiliency

Databases can have temporary failures. Configure retry logic:

<DotnetCodePreview
  title="Connection Resiliency Options"
  code={`builder.Services.AddDbContext<AppDbContext>(options =>
    options.UseSqlServer(
        connectionString,
        sqlOptions =>
        {
            // Retry on transient failures
            sqlOptions.EnableRetryOnFailure(
                maxRetryCount: 5,
                maxRetryDelay: TimeSpan.FromSeconds(30),
                errorNumbersToAdd: null);
            
            // Command timeout
            sqlOptions.CommandTimeout(60);
            
            // Connection timeout is in the connection string
            // Connection Timeout=30;
        }));

// For PostgreSQL
builder.Services.AddDbContext<AppDbContext>(options =>
    options.UseNpgsql(
        connectionString,
        npgsqlOptions =>
        {
            npgsqlOptions.EnableRetryOnFailure(
                maxRetryCount: 5,
                maxRetryDelay: TimeSpan.FromSeconds(30),
                errorCodesToAdd: null);
        }));`}
  steps={[
    {
      lineNumbers: [7, 8, 9, 10],
      highlight: "Retry Logic",
      explanation: "Automatically retry failed operations due to transient errors"
    },
    {
      lineNumbers: [13],
      highlight: "Command Timeout",
      explanation: "How long to wait for a query to complete"
    },
    {
      lineNumbers: [20, 21, 22, 23, 24, 25, 26, 27],
      highlight: "PostgreSQL",
      explanation: "Each provider has similar but slightly different options"
    }
  ]}
/>

### Logging and Diagnostics

<DotnetCodePreview
  title="Enable EF Core Logging"
  code={`builder.Services.AddDbContext<AppDbContext>(options =>
{
    options.UseSqlServer(connectionString);
    
    // Log SQL queries to console (development only!)
    if (builder.Environment.IsDevelopment())
    {
        options.LogTo(Console.WriteLine, LogLevel.Information);
        
        // Or log to ILogger
        options.LogTo(
            message => logger.LogInformation(message),
            LogLevel.Information);
        
        // Enable sensitive data logging (shows parameter values)
        options.EnableSensitiveDataLogging();
        
        // Enable detailed errors
        options.EnableDetailedErrors();
    }
});`}
  steps={[
    {
      lineNumbers: [6, 7, 8],
      highlight: "Log to Console",
      explanation: "See generated SQL queries during development"
    },
    {
      lineNumbers: [15],
      highlight: "Sensitive Data",
      explanation: "Shows actual parameter values - NEVER enable in production!"
    },
    {
      lineNumbers: [18],
      highlight: "Detailed Errors",
      explanation: "More descriptive error messages for debugging"
    }
  ]}
/>

<InfoBox type="warning">
**Security Warning:** Never enable `EnableSensitiveDataLogging()` in production! It exposes actual data values in logs, which could include passwords, personal information, and other sensitive data.
</InfoBox>

### Quick Knowledge Check

<Quiz id="connection-string-quiz">
  <Question>What is the safest way to store database passwords in production?</Question>
  <Answer>In appsettings.json</Answer>
  <Answer>Hardcoded in the DbContext</Answer>
  <Answer correct>In environment variables or Azure Key Vault</Answer>
  <Answer>In a text file on the server</Answer>
</Quiz>

<Quiz id="user-secrets-quiz">
  <Question>What is the purpose of User Secrets in .NET?</Question>
  <Answer>To encrypt the database</Answer>
  <Answer correct>To store sensitive configuration outside the project during development</Answer>
  <Answer>To create database users</Answer>
  <Answer>To generate random passwords</Answer>
</Quiz>

<Quiz id="retry-logic-quiz">
  <Question>Why should you enable retry logic for database connections?</Question>
  <Answer>To make queries faster</Answer>
  <Answer>To reduce database size</Answer>
  <Answer correct>To handle temporary network or database failures gracefully</Answer>
  <Answer>To enable multiple database connections</Answer>
</Quiz>

### Summary

| Concept | Key Takeaway |
|:--------|:-------------|
| **Connection String** | Address + credentials to reach your database |
| **appsettings.json** | Good for non-sensitive defaults |
| **User Secrets** | Development-only sensitive data storage |
| **Environment Variables** | Production secret storage |
| **Azure Key Vault** | Enterprise-grade secret management |
| **Retry Logic** | Handle transient failures gracefully |

<KeyConcept title="What's Next?">
Now that you know how to configure connections securely, let's explore the different **database providers** available for EF Core and when to use each one!
</KeyConcept>

<ProgressCheckpoint section="advanced-options" xpReward={15} />
