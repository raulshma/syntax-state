# Loading Related Data Patterns

You've learned **eager**, **lazy**, and **explicit** loading. But when should you use each? Let's compare them side-by-side and explore decision patterns for real-world scenarios.

---

## Section 1: Strategy Comparison Overview

### The Three Strategies at a Glance

| Aspect | Eager Loading | Lazy Loading | Explicit Loading |
|:-------|:--------------|:-------------|:-----------------|
| **How** | Include() / ThenInclude() | Auto on property access | Entry().Load() |
| **When Loaded** | With initial query | On first access | When you call Load() |
| **Queries** | 1 (or split) | 1 + N | 1 per Load() call |
| **Predictability** | High | Low | High |
| **Control** | Upfront | None | On-demand |
| **Code Visibility** | In query | Hidden | At load site |

### Visual Comparison

```
                    EAGER LOADING
    ┌─────────────────────────────────┐
    │  Time ──────────────────────▶   │
    │                                  │
    │  Query 1: [Blog + Posts + Author]│
    │  ████████████████████████████   │
    │                                  │
    │  ✅ All data in one trip         │
    └─────────────────────────────────┘

                    LAZY LOADING
    ┌─────────────────────────────────┐
    │  Time ──────────────────────▶   │
    │                                  │
    │  Query 1: [Blog]        access  │
    │  ████                   │       │
    │                         ▼       │
    │  Query 2:    [Posts]    access  │
    │              ████       │       │
    │                         ▼       │
    │  Query 3:        [Author]       │
    │                  ████           │
    │                                  │
    │  ⚠️ Multiple trips, on-demand    │
    └─────────────────────────────────┘

                    EXPLICIT LOADING
    ┌─────────────────────────────────┐
    │  Time ──────────────────────▶   │
    │                                  │
    │  Query 1: [Blog]   your choice  │
    │  ████              │            │
    │                    ▼            │
    │  Query 2:  [Posts] your choice  │
    │            ████    │            │
    │                    ▼            │
    │  Query 3:      [Author]         │
    │                ████             │
    │                                  │
    │  ✅ Multiple trips, controlled   │
    └─────────────────────────────────┘
```

<KeyConcept title="Key Insight">
The main difference is **when** and **how** you decide what data to load. Eager is upfront, lazy is automatic, explicit is on-demand.
</KeyConcept>

### Pros and Cons

<Comparison
  title="Eager Loading"
  items={[
    {
      label: " Single database round-trip",
      description: "All data fetched in one query",
      isCorrect: true
    },
    {
      label: " Predictable and explicit",
      description: "You know exactly what's loaded",
      isCorrect: true
    },
    {
      label: " May load unused data",
      description: "Wastes resources if you don't use everything",
      isCorrect: false
    },
    {
      label: " Can create large queries",
      description: "Many includes = complex SQL with JOINs",
      isCorrect: false
    }
  ]}
/>

<Comparison
  title="Lazy Loading"
  items={[
    {
      label: " Automatic and convenient",
      description: "Just access properties—data appears",
      isCorrect: true
    },
    {
      label: " Loads only what's accessed",
      description: "Unused relationships stay unloaded",
      isCorrect: true
    },
    {
      label: " N+1 query problem",
      description: "Can explode into hundreds of queries",
      isCorrect: false
    },
    {
      label: " Hidden behavior",
      description: "Hard to know when queries happen",
      isCorrect: false
    }
  ]}
/>

<Comparison
  title="Explicit Loading"
  items={[
    {
      label: " Full control with visibility",
      description: "You see every Load() call in code",
      isCorrect: true
    },
    {
      label: " Supports filtering",
      description: "Use Query() to filter/limit data",
      isCorrect: true
    },
    {
      label: " More code to write",
      description: "Must manually call Load() for each navigation",
      isCorrect: false
    },
    {
      label: " Multiple round-trips",
      description: "Each Load() is a separate query",
      isCorrect: false
    }
  ]}
/>

<ProgressCheckpoint section="comparison-overview" xpReward={20} />

---

## Section 2: Pattern Selection Guide

### The Decision Flowchart

```
              START: Need related data?
                         │
           ┌─────────────┴──────────────┐
           │                            │
      Yes, always              Sometimes/maybe
           │                            │
           ▼                            ▼
   ┌───────────────┐           ┌───────────────┐
   │ Do you know   │           │ Need to filter│
   │ which data?   │           │ the data?     │
   └───────┬───────┘           └───────┬───────┘
           │                            │
     ┌─────┴─────┐               ┌─────┴─────┐
     │           │               │           │
    Yes         No              Yes         No
     │           │               │           │
     ▼           ▼               ▼           ▼
┌─────────┐ ┌─────────┐   ┌─────────┐ ┌─────────┐
│  EAGER  │ │  LAZY   │   │EXPLICIT │ │  LAZY   │
│ LOADING │ │ LOADING │   │ LOADING │ │ LOADING │
└─────────┘ └─────────┘   └─────────┘ └─────────┘
```

### Quick Reference Table

| Scenario | Best Strategy | Why |
|:---------|:--------------|:----|
| API endpoint returning full object | **Eager** | Need all data in the response |
| Interactive UI exploration | **Lazy** | User-driven, unpredictable access |
| Dashboard with summaries | **Explicit + Query** | Need aggregates, not full entities |
| Report generation | **Eager** | Known data requirements upfront |
| Conditional data loading | **Explicit** | Load only if condition is true |
| Form editing single entity | **Eager** | Need related dropdowns immediately |
| Search results listing | **Eager (limited)** | Preview data with Take() filters |

<InfoBox type="tip">
**Rule of thumb:** Start with eager loading. Switch to explicit when you need control. Use lazy only when you truly can't predict access patterns.
</InfoBox>

<ProgressCheckpoint section="pattern-selection" xpReward={25} />

---

## Section 3: Real-World Scenarios

### Scenario 1: REST API Endpoint

**Requirement:** Return a blog with its recent posts and author info

<DotnetCodePreview
  title="API Endpoint - Eager Loading"
  code={`[HttpGet("{id}")]
public async Task<ActionResult<BlogDto>> GetBlog(int id)
{
    //  EAGER: Known data requirements, single response
    var blog = await context.Blogs
        .Include(b => b.Posts
            .OrderByDescending(p => p.CreatedDate)
            .Take(10))
            .ThenInclude(p => p.Author)
        .Include(b => b.Owner)
        .FirstOrDefaultAsync(b => b.Id == id);
    
    if (blog == null) return NotFound();
    
    return new BlogDto(blog);  // Map to DTO
}`}
  steps={[
    {
      lineNumbers: [5, 6, 7, 8, 9, 10, 11],
      highlight: "Eager Loading",
      explanation: "API knows exactly what data the response needs"
    }
  ]}
/>

**Why Eager?** API responses typically have fixed shapes. You know what data you need.

---

### Scenario 2: Dashboard with Counts

**Requirement:** Show blog list with post counts, without loading all posts

<DotnetCodePreview
  title="Dashboard - Explicit Loading with Query"
  code={`public async Task<List<BlogSummaryDto>> GetDashboard()
{
    var blogs = await context.Blogs
        .OrderByDescending(b => b.CreatedDate)
        .Take(10)
        .ToListAsync();
    
    var summaries = new List<BlogSummaryDto>();
    
    foreach (var blog in blogs)
    {
        //  EXPLICIT: Get count without loading entities
        var postCount = await context.Entry(blog)
            .Collection(b => b.Posts)
            .Query()
            .CountAsync();  // SQL: SELECT COUNT(*) ...
            
        summaries.Add(new BlogSummaryDto
        {
            Id = blog.Id,
            Name = blog.Name,
            PostCount = postCount
        });
    }
    
    return summaries;
}`}
  steps={[
    {
      lineNumbers: [13, 14, 15, 16],
      highlight: "Count Only",
      explanation: "Query().CountAsync() doesn't load posts—just gets the count!"
    }
  ]}
/>

**Why Explicit?** We only need counts, not full post entities. Major memory savings!

<InfoBox type="tip">
**Better approach:** Use projection to get counts in a single query:
```csharp
var summaries = await context.Blogs
    .Select(b => new BlogSummaryDto {
        Id = b.Id,
        Name = b.Name,
        PostCount = b.Posts.Count()
    }).ToListAsync();
```
</InfoBox>

---

### Scenario 3: Detail Page with Optional Sections

**Requirement:** Blog page with optional "Show Comments" button

<DotnetCodePreview
  title="Detail Page - Conditional Loading"
  code={`[HttpGet("{id}")]
public async Task<ActionResult<BlogDetailDto>> GetBlogDetail(
    int id, 
    [FromQuery] bool includeComments = false)
{
    // Initial load with essential data
    var blog = await context.Blogs
        .Include(b => b.Posts.Take(5))
        .Include(b => b.Owner)
        .FirstOrDefaultAsync(b => b.Id == id);
    
    if (blog == null) return NotFound();
    
    //  EXPLICIT: Conditionally load comments if requested
    if (includeComments)
    {
        await context.Entry(blog)
            .Collection(b => b.Comments)
            .Query()
            .OrderByDescending(c => c.CreatedDate)
            .Take(20)
            .LoadAsync();
    }
    
    return new BlogDetailDto(blog);
}`}
  steps={[
    {
      lineNumbers: [7, 8, 9, 10],
      highlight: "Essential Data",
      explanation: "Eager load what we always need"
    },
    {
      lineNumbers: [15, 16, 17, 18, 19, 20, 21, 22],
      highlight: "Conditional Load",
      explanation: "Explicit load only when user requested comments"
    }
  ]}
/>

**Why Hybrid?** Combine eager for essentials + explicit for optional data.

---

### Scenario 4: Interactive Desktop App

**Requirement:** User browses entities, expanding details on click

<DotnetCodePreview
  title="Desktop App - Lazy Loading"
  code={`// Desktop app with long-lived context
public class BlogBrowser
{
    private readonly AppDbContext _context;
    
    public async Task<List<Blog>> LoadBlogs()
    {
        // Just load blogs - posts will lazy load on demand
        return await _context.Blogs.ToListAsync();
    }
    
    public void DisplayBlogDetails(Blog blog)
    {
        Console.WriteLine($"Blog: {blog.Name}");
        
        //  LAZY: User clicked expand - posts load automatically
        Console.WriteLine($"Posts ({blog.Posts.Count}):");
        foreach (var post in blog.Posts)  // Triggers query
        {
            Console.WriteLine($"  - {post.Title}");
        }
    }
}`}
  steps={[
    {
      lineNumbers: [8, 9],
      highlight: "Initial Load",
      explanation: "Load only blogs—posts not needed yet"
    },
    {
      lineNumbers: [17, 18],
      highlight: "Auto-Load on Access",
      explanation: "User clicks expand—lazy loading fetches posts"
    }
  ]}
/>

**Why Lazy?** Interactive UIs where users drive exploration. But beware N+1!

<ProgressCheckpoint section="real-world-scenarios" xpReward={20} />

---

## Section 4: Hybrid Approaches

### Combining Strategies

The best solutions often combine multiple strategies:

<DotnetCodePreview
  title="Hybrid Strategy Example"
  code={`public async Task<OrderDetailDto> GetOrderDetail(int orderId)
{
    // EAGER: Load order with essential related data
    var order = await context.Orders
        .Include(o => o.Customer)
        .Include(o => o.Items.Take(10))  // First 10 items
            .ThenInclude(i => i.Product)
        .FirstOrDefaultAsync(o => o.Id == orderId);
    
    if (order == null) return null;
    
    // EXPLICIT: Check if there are more items
    var totalItems = await context.Entry(order)
        .Collection(o => o.Items)
        .Query()
        .CountAsync();
    
    // EXPLICIT: Load shipping info only if order is shipped
    if (order.Status == OrderStatus.Shipped)
    {
        await context.Entry(order)
            .Reference(o => o.ShippingInfo)
            .LoadAsync();
    }
    
    return new OrderDetailDto
    {
        Order = order,
        HasMoreItems = totalItems > 10,
        TotalItemCount = totalItems
    };
}`}
  steps={[
    {
      lineNumbers: [4, 5, 6, 7, 8],
      highlight: "Eager for Essentials",
      explanation: "Load what we always need upfront"
    },
    {
      lineNumbers: [13, 14, 15, 16],
      highlight: "Explicit for Metadata",
      explanation: "Get count without loading all items"
    },
    {
      lineNumbers: [19, 20, 21, 22, 23],
      highlight: "Conditional Explicit",
      explanation: "Load shipping only if order is shipped"
    }
  ]}
/>

### Strategy Selection Matrix

Use this matrix to pick your strategy:

| Question | Yes → | No → |
|:---------|:------|:-----|
| Always need this data? | Eager | Continue ↓ |
| Need to filter/limit? | Explicit | Continue ↓ |
| User-driven exploration? | Lazy (cautiously) | Explicit |
| Performance critical? | Eager or Explicit | Lazy (maybe) |
| Long-lived DbContext? | Lazy works better | Eager/Explicit |
| Web API response? | Eager | Continue ↓ |

### Anti-Patterns to Avoid

<Comparison
  title="Loading Strategy Anti-Patterns"
  items={[
    {
      label: " Lazy Loading in APIs",
      description: "Short-lived contexts + serialization = disposed context exceptions and N+1 nightmares.",
      isCorrect: false
    },
    {
      label: " Over-Including",
      description: "Don't Include everything 'just in case'. Load only what you actually need.",
      isCorrect: false
    },
    {
      label: " Ignoring the N+1 Problem",
      description: "Loops with lazy loading = performance disaster. Use SQL logging to detect!",
      isCorrect: false
    },
    {
      label: " Not Using Projections",
      description: "When you need specific fields, Select into a DTO instead of loading full entities.",
      isCorrect: false
    }
  ]}
/>

<InfoBox type="tip">
**Pro tip:** Use EF Core's SQL logging to see exactly what queries are being generated. This helps you identify N+1 problems and optimize your loading strategy.
</InfoBox>

### Quick Knowledge Check

<Quiz id="patterns-api-quiz">
  <Question>Which loading strategy is best for a REST API that returns a fixed data shape?</Question>
  <Answer>Lazy Loading</Answer>
  <Answer correct>Eager Loading</Answer>
  <Answer>Explicit Loading only</Answer>
  <Answer>No loading strategy needed</Answer>
</Quiz>

<Quiz id="patterns-count-quiz">
  <Question>What's the most efficient way to get a count of related items without loading them?</Question>
  <Answer>Use Include() then .Count property</Answer>
  <Answer>Use lazy loading and count</Answer>
  <Answer correct>Use Entry().Collection().Query().CountAsync()</Answer>
  <Answer>Load all and count in memory</Answer>
</Quiz>

<Quiz id="patterns-combine-quiz">
  <Question>When should you combine multiple loading strategies?</Question>
  <Answer>Never - pick one and stick with it</Answer>
  <Answer correct>When different parts of your function have different data needs</Answer>
  <Answer>Only for performance testing</Answer>
  <Answer>Only in desktop applications</Answer>
</Quiz>

### Summary

| Pattern | When to Use |
|:--------|:------------|
| **Eager Only** | Fixed data requirements, API responses, reports |
| **Lazy Only** | Interactive exploration with long-lived context |
| **Explicit Only** | Conditional loading, aggregations without entities |
| **Eager + Explicit** | Essential data upfront + optional data on demand |
| **Projection** | When you need specific fields, not full entities |

<KeyConcept title="What's Next?">
Now you know the patterns. But how do loading strategies affect performance? Let's dive into **Performance Considerations** with query analysis and optimization tips!
</KeyConcept>

<ProgressCheckpoint section="hybrid-approaches" xpReward={20} />
