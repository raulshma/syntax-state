# Avoiding N+1 Problems

Stop the query explosion! Learn to identify and fix the sneaky N+1 problem—the #1 cause of slow EF Core applications.

---

## Section 1: Understanding the N+1 Problem

### The Kitchen Trips Analogy 

Imagine you're making breakfast for 10 people. You need eggs, but instead of getting all the eggs at once, you:

1. Walk to the kitchen, get 1 egg
2. Walk back, cook it
3. Walk to the kitchen, get another egg
4. Repeat... 10 times!

That's the **N+1 problem**! One trip to identify what you need, then N more trips to get each item.

<InfoBox type="warning">
**The N+1 Problem:** Loading N parent entities results in N additional queries to load their related children. Instead of 1-2 queries, you end up with N+1 queries!
</InfoBox>

### Seeing It in Action

<DotnetCodePreview
  title="The N+1 Problem Exposed"
  code={`//  THE N+1 PROBLEM
// This looks innocent...
var blogs = await context.Blogs.ToListAsync();  // Query 1

foreach (var blog in blogs)
{
    //  EACH access to Posts triggers a database query!
    Console.WriteLine($"{blog.Title}: {blog.Posts.Count} posts");
    
    // With 100 blogs:
    // Query 2: SELECT * FROM Posts WHERE BlogId = 1
    // Query 3: SELECT * FROM Posts WHERE BlogId = 2
    // Query 4: SELECT * FROM Posts WHERE BlogId = 3
    // ... 
    // Query 101: SELECT * FROM Posts WHERE BlogId = 100
}

// Result: 101 database queries for a simple list! 

// Each query has:
// - Network round-trip latency
// - Connection overhead
// - Database execution time
// Total: Maybe 50ms per query × 100 = 5 SECONDS!`}
  steps={[
    {
      lineNumbers: [3],
      highlight: "Initial Query",
      explanation: "Query 1: Loads all blogs (no posts yet)"
    },
    {
      lineNumbers: [8],
      highlight: "The Trigger",
      explanation: "Accessing blog.Posts triggers lazy loading—a NEW query!"
    },
    {
      lineNumbers: [11, 12, 13, 14, 15],
      highlight: "Query Explosion",
      explanation: "100 blogs = 100 additional queries to load posts"
    },
    {
      lineNumbers: [20, 21, 22, 23],
      highlight: "Real Cost",
      explanation: "Each query has overhead—multiply by N and it's devastating"
    }
  ]}
/>

<QueryExecutionVisualizer
  title="N+1 Query Pattern"
  steps={[
    {
      linq: `// Step 1: Load all blogs
var blogs = context.Blogs.ToList();`,
      sql: `-- Query 1: All blogs
SELECT [b].[Id], [b].[Title], [b].[Author]
FROM [Blogs] AS [b]

-- Returns: Blog 1, Blog 2, Blog 3...`,
      explanation: "First query loads the parent entities. Posts not loaded yet!"
    },
    {
      linq: `// Step 2: Touch Posts property
foreach (var blog in blogs)
{
    var count = blog.Posts.Count;  // Triggers!
}`,
      sql: `-- Query 2 (for Blog 1)
SELECT * FROM [Posts] WHERE [BlogId] = 1

-- Query 3 (for Blog 2)
SELECT * FROM [Posts] WHERE [BlogId] = 2

-- Query 4 (for Blog 3)
SELECT * FROM [Posts] WHERE [BlogId] = 3

-- ... continues for EVERY blog!`,
      explanation: "Each blog.Posts access fires a separate query. N blogs = N extra queries!"
    }
  ]}
/>

<ProgressCheckpoint section="n-plus-one-problem" xpReward={20} />

---

## Section 2: Eager Loading with Include

### The Shopping Cart Solution 

Instead of making 100 trips to the kitchen, bring a shopping cart and get everything in one trip!

<DotnetCodePreview
  title="Include() to the Rescue"
  code={`//  THE FIX: Eager loading with Include()
var blogs = await context.Blogs
    .Include(b => b.Posts)  //  Load posts WITH blogs!
    .ToListAsync();

// Now this works WITHOUT extra queries:
foreach (var blog in blogs)
{
    Console.WriteLine($"{blog.Title}: {blog.Posts.Count} posts");
    // No lazy loading triggered - Posts already loaded!
}

// Result: JUST 1 QUERY (with a JOIN)!

// The SQL:
// SELECT b.*, p.*
// FROM Blogs b
// LEFT JOIN Posts p ON b.Id = p.BlogId
// ORDER BY b.Id`}
  steps={[
    {
      lineNumbers: [2, 3, 4],
      highlight: "Include()",
      explanation: "Include tells EF to load related Posts in the SAME query"
    },
    {
      lineNumbers: [8, 9, 10],
      highlight: "No Extra Queries",
      explanation: "Posts are already in memory—no lazy loading needed"
    },
    {
      lineNumbers: [16, 17, 18, 19],
      highlight: "Single Query",
      explanation: "One query with a JOIN loads everything!"
    }
  ]}
/>

### Loading Multiple Relationships

<DotnetCodePreview
  title="Include Patterns"
  code={`// Multiple direct relationships
var orders = await context.Orders
    .Include(o => o.Customer)
    .Include(o => o.ShippingAddress)
    .Include(o => o.Items)
    .ToListAsync();

// Nested relationships with ThenInclude
var blogs = await context.Blogs
    .Include(b => b.Posts)
        .ThenInclude(p => p.Comments)
            .ThenInclude(c => c.Author)
    .ToListAsync();

// Multiple paths from the same root
var orders = await context.Orders
    .Include(o => o.Items)
        .ThenInclude(i => i.Product)
            .ThenInclude(p => p.Category)
    .Include(o => o.Items)
        .ThenInclude(i => i.Product)
            .ThenInclude(p => p.Supplier)
    .ToListAsync();

// Filtered Include (EF Core 5+)
var blogs = await context.Blogs
    .Include(b => b.Posts.Where(p => p.IsPublished))
    .ToListAsync();

// Ordered Include (EF Core 5+)
var blogs = await context.Blogs
    .Include(b => b.Posts.OrderByDescending(p => p.Date).Take(5))
    .ToListAsync();`}
  steps={[
    {
      lineNumbers: [2, 3, 4, 5, 6],
      highlight: "Multiple Includes",
      explanation: "Each Include adds a related collection to load"
    },
    {
      lineNumbers: [9, 10, 11, 12, 13],
      highlight: "ThenInclude",
      explanation: "Navigate deeper: Blogs → Posts → Comments → Author"
    },
    {
      lineNumbers: [25, 26, 27],
      highlight: "Filtered Include",
      explanation: "Only load posts that match a condition"
    },
    {
      lineNumbers: [30, 31, 32],
      highlight: "Ordered Include",
      explanation: "Control order and limit loaded items"
    }
  ]}
/>

<InfoBox type="tip">
**Pro Tip:** Projections with `Select()` often eliminate the need for `Include()`:
```csharp
var blogSummaries = await context.Blogs
    .Select(b => new {
        b.Title,
        PostCount = b.Posts.Count()  // No Include needed!
    }).ToListAsync();
```
EF Core builds the optimal query automatically!
</InfoBox>

<ProgressCheckpoint section="eager-loading" xpReward={25} />

---

## Section 3: Split Queries

### The Cartesian Explosion Problem 

Include() creates JOINs, which can cause data duplication:

<QueryExecutionVisualizer
  title="Cartesian Explosion"
  steps={[
    {
      linq: `// Including multiple collections
var blogs = context.Blogs
    .Include(b => b.Posts)
    .Include(b => b.Subscribers)
    .ToList();`,
      sql: `SELECT b.*, p.*, s.*
FROM Blogs b
LEFT JOIN Posts p ON b.Id = p.BlogId
LEFT JOIN Subscribers s ON b.Id = s.BlogId

-- Blog "Tech Tips" with:
--   5 Posts and 100 Subscribers
-- Returns: 5 × 100 = 500 rows!
-- Blog data repeated 500 times!`,
      explanation: "Cross-joining multiple collections explodes the row count!"
    },
    {
      linq: `// Solution: Split into separate queries
var blogs = context.Blogs
    .Include(b => b.Posts)
    .Include(b => b.Subscribers)
    .AsSplitQuery()
    .ToList();`,
      sql: `-- Query 1: Blogs
SELECT * FROM Blogs

-- Query 2: Posts
SELECT * FROM Posts WHERE BlogId IN (1, 2, 3...)

-- Query 3: Subscribers  
SELECT * FROM Subscribers WHERE BlogId IN (1, 2, 3...)

-- 3 small queries instead of 1 huge one!`,
      explanation: "AsSplitQuery runs separate queries—no data duplication!"
    }
  ]}
/>

<DotnetCodePreview
  title="When to Use Split Queries"
  code={`//  BAD: Multiple collections cause cartesian explosion
var orders = await context.Orders
    .Include(o => o.Items)           // 10 items per order
    .Include(o => o.Payments)        // 3 payments per order
    .Include(o => o.ShipmentUpdates) // 8 updates per order
    .ToListAsync();
// Each order: 10 × 3 × 8 = 240 rows of duplicated data!

//  GOOD: Split query avoids explosion
var orders = await context.Orders
    .Include(o => o.Items)
    .Include(o => o.Payments)
    .Include(o => o.ShipmentUpdates)
    .AsSplitQuery()
    .ToListAsync();
// 4 separate queries, no data duplication!

//  Configure as default for DbContext
protected override void OnConfiguring(DbContextOptionsBuilder options)
{
    options.UseSqlServer(connString, o => o.UseQuerySplittingBehavior(
        QuerySplittingBehavior.SplitQuery));
}

// Then override when you need single query:
var data = await context.Orders
    .Include(o => o.Items)
    .AsSingleQuery()  // Override split default
    .ToListAsync();`}
  steps={[
    {
      lineNumbers: [2, 3, 4, 5, 6, 7],
      highlight: "Cartesian Problem",
      explanation: "Multiple collections multiply row count dramatically"
    },
    {
      lineNumbers: [10, 11, 12, 13, 14, 15],
      highlight: "AsSplitQuery Solution",
      explanation: "Split queries load each collection in separate queries"
    },
    {
      lineNumbers: [18, 19, 20, 21, 22],
      highlight: "Default Configuration",
      explanation: "Make split the default if you have many multi-collection includes"
    }
  ]}
/>

<Comparison
  title="Single vs Split Queries"
  items={[
    {
      label: "AsSingleQuery (default)",
      description: "One query with JOINs. Best for single Include or when data is small. May cause cartesian explosion with multiple collections.",
      isCorrect: true
    },
    {
      label: "AsSplitQuery",
      description: "Multiple smaller queries. Best for multiple collection Includes. Avoids data duplication. Note: not transactionally consistent.",
      isCorrect: true
    }
  ]}
/>

<InfoBox type="warning">
**Split Query Caveat:** Multiple queries mean data could change between queries. If consistency is critical, use a transaction or stick with single query.
</InfoBox>

<ProgressCheckpoint section="split-queries" xpReward={20} />

---

## Section 4: Detection Strategies

### Finding N+1 in Your Code 

<DotnetCodePreview
  title="Detection Methods"
  code={`// Method 1: Enable query logging
protected override void OnConfiguring(DbContextOptionsBuilder options)
{
    options.UseSqlServer(connString)
           .LogTo(Console.WriteLine, LogLevel.Information);
}
// Watch for many similar queries in succession!

// Method 2: Use MiniProfiler or similar
// Shows all queries executed per request

// Method 3: Query tags for identification
var blogs = await context.Blogs
    .TagWith("Loading blogs for homepage")
    .ToListAsync();
// Now you can trace which code caused queries

// Method 4: Count queries in tests
public class N1Tests
{
    [Fact]
    public async Task BlogList_ShouldNotCauseN1()
    {
        var queryCount = 0;
        await using var context = CreateContext(logAction: sql => 
        {
            if (sql.Contains("SELECT")) queryCount++;
        });
        
        var result = await _service.GetBlogsWithPosts();
        
        // Should be 1-2 queries, not 100+
        Assert.InRange(queryCount, 1, 3);
    }
}`}
  steps={[
    {
      lineNumbers: [2, 3, 4, 5, 6, 7],
      highlight: "Logging",
      explanation: "See every query—spot repeated patterns indicating N+1"
    },
    {
      lineNumbers: [13, 14, 15],
      highlight: "Query Tags",
      explanation: "Tag queries to understand which code generated them"
    },
    {
      lineNumbers: [19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33],
      highlight: "Test Prevention",
      explanation: "Write tests that fail if too many queries are executed"
    }
  ]}
/>

### Common N+1 Patterns to Watch For

<DotnetCodePreview
  title="N+1 Anti-Patterns"
  code={`//  ANTI-PATTERN 1: Loop with database access
var customers = await context.Customers.ToListAsync();
foreach (var customer in customers)
{
    var orders = await context.Orders
        .Where(o => o.CustomerId == customer.Id)
        .ToListAsync();  // N+1 ALERT!
}

//  FIX: Include or join
var customers = await context.Customers
    .Include(c => c.Orders)
    .ToListAsync();

//  ANTI-PATTERN 2: Virtual navigation property access
public class Customer
{
    public virtual ICollection<Order> Orders { get; set; }  // Lazy loading!
}

// In code: customer.Orders triggers query!

//  FIX: Explicit loading or Include()

//  ANTI-PATTERN 3: Projection accessing navigation
var data = await context.Orders
    .Select(o => new {
        o.Id,
        CustomerName = o.Customer.Name  // Could be N+1 if not smart!
    })
    .ToListAsync();

//  Actually OK! EF Core is smart about projections
// It builds a single query with JOIN

//  ANTI-PATTERN 4: Async inside loop
foreach (var id in orderIds)
{
    var order = await context.Orders.FindAsync(id);  // N queries!
}

//  FIX: Single query with Where In
var orders = await context.Orders
    .Where(o => orderIds.Contains(o.Id))
    .ToListAsync();`}
  steps={[
    {
      lineNumbers: [2, 3, 4, 5, 6, 7, 8],
      highlight: "Loop DB Access",
      explanation: "Any database call inside a loop is a red flag!"
    },
    {
      lineNumbers: [16, 17, 18],
      highlight: "Lazy Loading",
      explanation: "Virtual navigation properties can trigger N+1 via lazy loading"
    },
    {
      lineNumbers: [35, 36, 37, 38],
      highlight: "FindAsync in Loop",
      explanation: "Multiple FindAsync calls = multiple queries"
    },
    {
      lineNumbers: [41, 42, 43],
      highlight: "Where Contains",
      explanation: "Load all needed entities in one query with WHERE IN"
    }
  ]}
/>

### Quick Knowledge Check

<Quiz id="n1-definition-quiz">
  <Question>What is the N+1 problem?</Question>
  <Answer>Making N queries instead of 1</Answer>
  <Answer correct>Loading N entities results in N+1 total queries (1 for parents, N for each child)</Answer>
  <Answer>Having N+1 entities in your database</Answer>
  <Answer>A database returning N+1 rows</Answer>
</Quiz>

<Quiz id="n1-fix-quiz">
  <Question>What's the primary way to fix N+1 in EF Core?</Question>
  <Answer>Use AsNoTracking()</Answer>
  <Answer>Add database indexes</Answer>
  <Answer correct>Use Include() to eager load related data</Answer>
  <Answer>Use raw SQL queries</Answer>
</Quiz>

<Quiz id="split-query-quiz">
  <Question>When is AsSplitQuery() most useful?</Question>
  <Answer>For queries with a single Include()</Answer>
  <Answer correct>For queries with multiple collection navigations that cause cartesian explosion</Answer>
  <Answer>For improving query performance in all cases</Answer>
  <Answer>For ensuring transactional consistency</Answer>
</Quiz>

### Summary

| Problem | Solution | When to Use |
|:--------|:---------|:------------|
| **N+1 (lazy load)** | `Include()` | Always when accessing related data |
| **Cartesian explosion** | `AsSplitQuery()` | Multiple collection Includes |
| **Deep navigation** | `ThenInclude()` | Nested relationships |
| **Conditional loading** | Filtered Include | Only load matching children |
| **Count only** | `Select()` projection | When you don't need the entities |

<KeyConcept title="The N+1 Prevention Checklist">
Before any code that loops over entities:
1.  Do I access navigation properties in the loop?
2.  Have I used Include() for those properties?
3.  Should I use AsSplitQuery() for multiple collections?
4.  Could I use a projection instead of loading entities?
5.  Am I calling the database inside the loop? (Always bad!)
</KeyConcept>

<ProgressCheckpoint section="detection-strategies" xpReward={25} />
