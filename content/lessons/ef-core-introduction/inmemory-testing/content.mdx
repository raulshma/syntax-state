# Testing with the InMemory Provider

One of the arguably coolest features of Entity Framework Core is how easily you can swap out your database provider. For testing, this means we can use an 'In-Memory' database that exists only in RAM. It's fast, disappears when the test ends, and requires no external setup!

---

## Section 1: The Magic of InMemory

### Why Use InMemory?

Typically, testing database code is hard. You have to:
1.  Spin up a local SQL Server or Postgres instance.
2.  Clean up the data after every test.
3.  Wait for slow network calls.

The **InMemory Provider** solves this by storing your data in standard C# collections (Lists, HashSets) behind the scenes.

| Real Database | InMemory Provider |
| :--- | :--- |
|  Slower (Disk I/O, Network) |  Blazing Fast (RAM only) |
| Ô∏è Requires Installation |  Just a NuGet Package |
| üßπ Hard to Cleanup |  Disappears on Dispose |

<InfoBox type="info">
    **Note:** The InMemory provider is *not* a relational database. It simulates one, but it doesn't enforce referential integrity (foreign keys) by default. Use it for **logic** tests, not **constraint** tests.
</InfoBox>

<ProgressCheckpoint section="intro-inmemory" xpReward={25} />

---

## Section 2: Setting It Up

### Dependencies

First, you need the NuGet package. It's usually a different package than your main provider.

`dotnet add package Microsoft.EntityFrameworkCore.InMemory`

### Configuring the DbContext

In your application code (e.g., `Program.cs`), you typically configure SQL Server. But in your **Unit Tests**, you can configure InMemory.

<DotnetCodePreview
    title="Configuring InMemory Context"
    code={`public class ApplicationDbContext : DbContext
{
    public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options)
        : base(options)
    {
    }

    public DbSet<User> Users { get; set; }
}

// In your Test Project:
public ApplicationDbContext CreateContext()
{
    var options = new DbContextOptionsBuilder<ApplicationDbContext>()
        .UseInMemoryDatabase(databaseName: "TestDb_" + Guid.NewGuid())
        .Options;

    return new ApplicationDbContext(options);
}`}
    steps={[
        {
            lineNumbers: [3, 4, 5],
            highlight: "Constructor Injection",
            explanation: "Ensure your DbContext accepts options in the constructor. This allows you to pass different options (like InMemory) during tests."
        },
        {
            lineNumbers: [14],
            highlight: "UseInMemoryDatabase",
            explanation: "This extension method tells EF to use the RAM-based provider."
        },
        {
            lineNumbers: [14],
            highlight: "Unique Name",
            explanation: "Give each test context a unique name (like a GUID) to ensure tests don't share data cleanly."
        }
    ]}
/>

<ProgressCheckpoint section="setup-inmemory" xpReward={25} />

---

## Section 3: Writing a Test

Let's write a simple unit test using xUnit. We want to verify that we can add a user and then retrieve them.

<DotnetCodePreview
    title="Unit Test Example"
    code={`[Fact]
public async Task Should_Add_And_Retrieve_User()
{
    // Arrange
    var options = new DbContextOptionsBuilder<AppDbContext>()
        .UseInMemoryDatabase("UserTestDb")
        .Options;

    // Use a clean context for the 'Act' to simulate a fresh request
    using (var context = new AppDbContext(options))
    {
        context.Users.Add(new User { Name = "Alice" });
        await context.SaveChangesAsync();
    }

    // Act & Assert
    using (var context = new AppDbContext(options))
    {
        var user = await context.Users.FirstOrDefaultAsync(u => u.Name == "Alice");
        
        Assert.NotNull(user);
        Assert.Equal("Alice", user.Name);
        Assert.NotEqual(0, user.Id); // ID generated automatically
    }
}`}
    steps={[
        {
            lineNumbers: [5],
            highlight: "Setup Options",
            explanation: "Create the options once to share between the content contexts."
        },
        {
            lineNumbers: [9, 10, 11, 12, 13],
            highlight: "Arrange Phase",
            explanation: "We add data using one instance of the context. This simulates the 'Setup' or 'Seed' phase."
        },
        {
            lineNumbers: [16, 17, 18],
            highlight: "Act & Assert Phase",
            explanation: "We create a NEW instance with the SAME name. This simulates a new web request reading the saved data."
        }
    ]}
/>

<Quiz id="testing-context-quiz">
    <Question>Why do we often use two different DbContext instances in a test?</Question>
    <Answer>Because InMemory requires it</Answer>
    <Answer correct>To verify data was actually saved and not just sitting in the local cache</Answer>
    <Answer>To improve performance</Answer>
    <Answer>Because one instance cannot read and write</Answer>
</Quiz>

<ProgressCheckpoint section="writing-tests" xpReward={25} />

---

## Section 4: Limitations & Best Practices

While great, InMemory isn't perfect. It is **not** a real relational database.

### What it DOESN'T do:
1.  **Referential Integrity**: It won't throw an error if you insert a child record with a non-existent parent ID (unless configured otherwise).
2.  **Transactions**: It ignores transactions.
3.  **Raw SQL**: Queries like `.FromSqlRaw("SELECT * ...")` often fail because it's not SQL-based.

<InfoBox type="warning">
    If your code relies heavily on specific SQL features (like stored procedures, specific date functions, or complex constraints), InMemory tests might pass even if the code fails in production!
</InfoBox>

For those scenarios, see the next lesson on **SQLite Testing** or **Integration Testing**.

<ProgressCheckpoint section="limitations" xpReward={25} />
