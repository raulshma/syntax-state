# Projections and Transformations

Why load 20 columns when you only need 3? Learn how to shape your data efficiently with EF Core projections!

---

## Section 1: Select() Basics

### The Sculptor Analogy 

Think of your database as a block of marble containing all your data. Without projections, you're carrying the entire heavy block back to your application. With `Select()`, you're a sculptor - you carve out exactly the shape you need and carry only that!

<QueryExecutionVisualizer
  title="Projection Power"
  steps={[
    {
      linq: `// Without projection - loads ALL columns
var customers = context.Customers
    .ToList();`,
      sql: `SELECT [c].[Id], [c].[FirstName], [c].[LastName], 
       [c].[Email], [c].[Phone], [c].[Address], 
       [c].[City], [c].[Country], [c].[CreatedAt], 
       [c].[LastLoginAt], [c].[ProfileImage]
FROM [Customers] AS [c]`,
      explanation: "Without Select(), EF Core fetches ALL columns. That ProfileImage blob could be megabytes per row!"
    },
    {
      linq: `// With projection - loads only what you need
var customerNames = context.Customers
    .Select(c => c.FirstName)
    .ToList();`,
      sql: `SELECT [c].[FirstName]
FROM [Customers] AS [c]`,
      explanation: "One column! The database only returns FirstName - dramatically faster and less memory!"
    }
  ]}
/>

<InfoBox type="info">
**Why It Matters:** Projecting fewer columns means:
- Less data transferred over the network
- Less memory used in your application  
- Faster query execution
- No change tracking overhead for the excluded columns
</InfoBox>

### Selecting Multiple Columns

<DotnetCodePreview
  title="Basic Projections"
  code={`// Single property - returns List<string>
var names = context.Customers
    .Select(c => c.Email)
    .ToList();

// Tuple projection - returns List<(string, string)>
var contactInfo = context.Customers
    .Select(c => new { c.FirstName, c.Email })
    .ToList();

// Computed values in projection
var displayNames = context.Customers
    .Select(c => c.FirstName + " " + c.LastName)
    .ToList();

// Multiple computed values
var customerData = context.Customers
    .Select(c => new 
    { 
        FullName = c.FirstName + " " + c.LastName,
        Domain = c.Email.Substring(c.Email.IndexOf("@") + 1)
    })
    .ToList();`}
  steps={[
    {
      lineNumbers: [2, 3, 4],
      highlight: "Single Column",
      explanation: "Returns a simple list of strings - the Email column"
    },
    {
      lineNumbers: [7, 8, 9],
      highlight: "Anonymous Type",
      explanation: "Create an object with just the properties you need"
    },
    {
      lineNumbers: [12, 13, 14],
      highlight: "Computed String",
      explanation: "Concatenation happens in SQL on the database server!"
    },
    {
      lineNumbers: [17, 18, 19, 20, 21, 22, 23],
      highlight: "Complex Expressions",
      explanation: "String methods like Substring translate to SQL functions"
    }
  ]}
/>

<ProgressCheckpoint section="select-basics" xpReward={20} />

---

## Section 2: Anonymous Types

### Quick Data Shapes

Anonymous types are perfect when you need a custom shape for a single method and don't want to create a full class.

<DotnetCodePreview
  title="Anonymous Type Projections"
  code={`// Basic anonymous type
var productCards = context.Products
    .Select(p => new 
    {
        p.Id,
        p.Name,
        p.Price,
        DisplayPrice = "$" + p.Price.ToString("F2")
    })
    .ToList();

// With related data (using navigation properties)
var productWithCategory = context.Products
    .Select(p => new 
    {
        ProductName = p.Name,
        CategoryName = p.Category.Name,  // Navigation property
        SupplierCount = p.Suppliers.Count()
    })
    .ToList();

// Nested anonymous types
var ordersWithCustomer = context.Orders
    .Select(o => new 
    {
        OrderId = o.Id,
        OrderDate = o.OrderDate,
        Customer = new 
        {
            Name = o.Customer.FirstName + " " + o.Customer.LastName,
            Email = o.Customer.Email
        }
    })
    .ToList();`}
  steps={[
    {
      lineNumbers: [2, 3, 4, 5, 6, 7, 8, 9, 10],
      highlight: "Property Shorthand",
      explanation: "new { p.Id } is shorthand for new { Id = p.Id }"
    },
    {
      lineNumbers: [13, 14, 15, 16, 17, 18, 19, 20],
      highlight: "Navigation Properties",
      explanation: "Access related data directly - EF Core generates efficient JOINs"
    },
    {
      lineNumbers: [23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33],
      highlight: "Nested Objects",
      explanation: "Create hierarchical shapes with nested anonymous types"
    }
  ]}
/>

<QueryExecutionVisualizer
  title="Navigation in Projections"
  steps={[
    {
      linq: `var data = context.Orders
    .Select(o => new 
    {
        o.Id,
        CustomerName = o.Customer.Name,
        ItemCount = o.LineItems.Count()
    })
    .ToList();`,
      sql: `SELECT [o].[Id], [c].[Name] AS [CustomerName], 
       (SELECT COUNT(*) FROM [OrderLineItems] AS [l] 
        WHERE [o].[Id] = [l].[OrderId]) AS [ItemCount]
FROM [Orders] AS [o]
INNER JOIN [Customers] AS [c] ON [o].[CustomerId] = [c].[Id]`,
      explanation: "EF Core automatically JOINs related tables and uses subqueries for counts - all in one trip to the database!"
    }
  ]}
/>

<InfoBox type="tip">
**Pro Tip:** With projections, you don't need `Include()` for related data! When you access navigation properties inside `Select()`, EF Core automatically generates the necessary JOINs.
</InfoBox>

<ProgressCheckpoint section="anonymous-types" xpReward={20} />

---

## Section 3: DTO Projections

### What's a DTO?

A **Data Transfer Object (DTO)** is a class specifically designed to carry data between layers of your application. Unlike anonymous types, DTOs are reusable and can be returned from methods.

<DotnetCodePreview
  title="DTO Classes and Projections"
  code={`// Define your DTO
public class CustomerSummaryDto
{
    public int Id { get; set; }
    public string FullName { get; set; } = "";
    public string Email { get; set; } = "";
    public int OrderCount { get; set; }
    public decimal TotalSpent { get; set; }
}

// Project directly to the DTO
var customerSummaries = context.Customers
    .Select(c => new CustomerSummaryDto
    {
        Id = c.Id,
        FullName = c.FirstName + " " + c.LastName,
        Email = c.Email,
        OrderCount = c.Orders.Count(),
        TotalSpent = c.Orders.Sum(o => o.Total)
    })
    .ToList();

// Use the strongly-typed result
foreach (var customer in customerSummaries)
{
    Console.WriteLine($"{customer.FullName} has spent {customer.TotalSpent:C}");
}`}
  steps={[
    {
      lineNumbers: [2, 3, 4, 5, 6, 7, 8, 9],
      highlight: "DTO Class",
      explanation: "A simple class with only the properties you need to transfer"
    },
    {
      lineNumbers: [12, 13, 14, 15, 16, 17, 18, 19, 20, 21],
      highlight: "Direct Projection",
      explanation: "Create DTO in Select() - all computed in SQL, not in memory!"
    },
    {
      lineNumbers: [24, 25, 26, 27],
      highlight: "Strongly Typed",
      explanation: "IntelliSense and compile-time type checking work perfectly"
    }
  ]}
/>

<Comparison
  title="Anonymous Types vs DTOs"
  items={[
    {
      label: "Anonymous Types",
      description: "Quick and convenient, but limited to local scope. Can't be returned from methods or passed between classes.",
      isCorrect: false
    },
    {
      label: "DTOs",
      description: "Reusable, strongly-typed, can be returned from methods. Better for APIs, services, and maintainability.",
      isCorrect: true
    }
  ]}
/>

### Constructor Projections

<DotnetCodePreview
  title="Using Constructors in Projections"
  code={`// DTO with constructor
public class ProductCardDto
{
    public ProductCardDto(int id, string name, decimal price, string category)
    {
        Id = id;
        Name = name;
        Price = price;
        Category = category;
    }
    
    public int Id { get; }
    public string Name { get; }
    public decimal Price { get; }
    public string Category { get; }
    public string FormattedPrice => Price.ToString("C");
}

// Project using constructor
var productCards = context.Products
    .Select(p => new ProductCardDto(
        p.Id,
        p.Name,
        p.Price,
        p.Category.Name
    ))
    .ToList();`}
  steps={[
    {
      lineNumbers: [4, 5, 6, 7, 8, 9, 10],
      highlight: "Constructor",
      explanation: "DTOs can use constructors for immutability"
    },
    {
      lineNumbers: [16],
      highlight: "Computed Property",
      explanation: "FormattedPrice is computed in C# after loading - not part of the SQL query"
    },
    {
      lineNumbers: [20, 21, 22, 23, 24, 25, 26],
      highlight: "Constructor Call",
      explanation: "Pass values directly to constructor - works in EF Core 6+"
    }
  ]}
/>

<ProgressCheckpoint section="dto-projections" xpReward={25} />

---

## Section 4: SelectMany - Flattening Collections

### When You Need to Flatten

`Select()` gives you one output per input. `SelectMany()` gives you **many outputs per input** by flattening nested collections.

<DotnetCodePreview
  title="SelectMany Explained"
  code={`// Scenario: Get all order line items across all orders

// With Select() - gives List<List<LineItem>>  
var nestedItems = context.Orders
    .Select(o => o.LineItems)
    .ToList();
// Result: [[Item1, Item2], [Item3], [Item4, Item5, Item6]]

// With SelectMany() - gives List<LineItem>  
var flatItems = context.Orders
    .SelectMany(o => o.LineItems)
    .ToList();
// Result: [Item1, Item2, Item3, Item4, Item5, Item6]

// SelectMany with projection
var allProducts = context.Categories
    .SelectMany(
        c => c.Products,
        (category, product) => new 
        {
            CategoryName = category.Name,
            ProductName = product.Name,
            product.Price
        })
    .ToList();`}
  steps={[
    {
      lineNumbers: [4, 5, 6, 7],
      highlight: "Select() = Nested",
      explanation: "Returns a list of lists - each order's items are grouped"
    },
    {
      lineNumbers: [10, 11, 12, 13],
      highlight: "SelectMany() = Flat",
      explanation: "Flattens all items into one continuous list"
    },
    {
      lineNumbers: [16, 17, 18, 19, 20, 21, 22, 23, 24],
      highlight: "With Result Selector",
      explanation: "Second lambda creates output combining parent and child data"
    }
  ]}
/>

<QueryExecutionVisualizer
  title="SelectMany SQL Translation"
  steps={[
    {
      linq: `var allLineItems = context.Orders
    .SelectMany(o => o.LineItems)
    .ToList();`,
      sql: `SELECT [l].[Id], [l].[OrderId], [l].[ProductId], [l].[Quantity]
FROM [Orders] AS [o]
INNER JOIN [OrderLineItems] AS [l] ON [o].[Id] = [l].[OrderId]`,
      explanation: "SelectMany becomes an INNER JOIN, producing one row per line item."
    },
    {
      linq: `var productsByCategory = context.Categories
    .SelectMany(c => c.Products, (cat, prod) => new 
    {
        Category = cat.Name,
        Product = prod.Name
    })
    .ToList();`,
      sql: `SELECT [c].[Name] AS [Category], [p].[Name] AS [Product]
FROM [Categories] AS [c]
INNER JOIN [Products] AS [p] ON [c].[Id] = [p].[CategoryId]`,
      explanation: "The result selector lets you include data from both the parent (category) and child (product)."
    }
  ]}
/>

### Quick Knowledge Check

<Quiz id="projection-perf-quiz">
  <Question>Why should you use Select() to project only needed columns?</Question>
  <Answer>It's required by EF Core</Answer>
  <Answer correct>It reduces data transfer, memory usage, and improves performance</Answer>
  <Answer>It makes the code more readable</Answer>
  <Answer>Anonymous types require it</Answer>
</Quiz>

<Quiz id="dto-vs-anon-quiz">
  <Question>When should you use a DTO instead of an anonymous type?</Question>
  <Answer>Always - anonymous types are bad practice</Answer>
  <Answer>Only for database operations</Answer>
  <Answer correct>When you need to return the projection from a method or reuse it</Answer>
  <Answer>Never - DTOs are outdated</Answer>
</Quiz>

<Quiz id="selectmany-quiz">
  <Question>What does SelectMany() do differently from Select()?</Question>
  <Answer>It's faster than Select()</Answer>
  <Answer>It returns anonymous types</Answer>
  <Answer correct>It flattens nested collections into a single sequence</Answer>
  <Answer>It can select multiple columns</Answer>
</Quiz>

### Summary

| Concept | Key Takeaway |
|:--------|:-------------|
| **Select()** | Project to specific columns or shapes - reduces data transfer |
| **Anonymous Types** | Quick custom shapes for local use with `new { ... }` |
| **DTOs** | Reusable projection classes for APIs and services |
| **Navigation in Select()** | Access related data without Include() - generates efficient JOINs |
| **SelectMany()** | Flatten nested collections into a single list |

<KeyConcept title="What's Next?">
You can now shape your data perfectly! Next up: **Joins and Grouping** - combine data from multiple tables and create aggregated summaries.
</KeyConcept>

<ProgressCheckpoint section="selectmany-flattening" xpReward={20} />
