# Browsers and How They Work

At the advanced level, we'll explore the internals of JavaScript engines, GPU-accelerated rendering, the event loop in depth, and browser security models. This knowledge is essential for building high-performance web applications.

<RenderingPipelineSimulator showMetrics={true} speed={0.5} />

## JavaScript Engine Deep Dive

Modern JavaScript engines are marvels of engineering, using sophisticated techniques to execute code at near-native speeds.

### V8 Architecture (Chrome, Node.js)

V8 compiles JavaScript directly to machine code using a multi-tier compilation strategy:

```
Source Code
    ↓
  Parser → AST (Abstract Syntax Tree)
    ↓
  Ignition (Interpreter) → Bytecode
    ↓
  TurboFan (Optimizing Compiler) → Machine Code
```

<InfoBox type="info" title="JIT Compilation">
Just-In-Time (JIT) compilation means code is compiled during execution, not ahead of time. This allows the engine to optimize based on actual runtime behavior.
</InfoBox>

### Optimization Techniques

**1. Inline Caching**
When you access `obj.property`, the engine remembers the object's "shape" (hidden class) and caches the property offset for faster subsequent access.

```javascript
// Monomorphic (fast) - always same shape
function getX(point) { return point.x; }
getX({ x: 1, y: 2 });
getX({ x: 3, y: 4 });

// Polymorphic (slower) - different shapes
getX({ x: 1, y: 2 });
getX({ x: 1, z: 2 }); // Different shape!
```

**2. Hidden Classes**
V8 creates hidden classes for objects with the same structure. Adding properties in different orders creates different hidden classes.

```javascript
// Same hidden class (good)
function Point(x, y) {
  this.x = x;
  this.y = y;
}

// Different hidden classes (bad)
const a = {}; a.x = 1; a.y = 2;
const b = {}; b.y = 2; b.x = 1; // Different order!
```

**3. Deoptimization**
If assumptions made during optimization become invalid, the engine "deoptimizes" back to interpreted code.

<KeyConcept title="Write Predictable Code">
Consistent object shapes, avoiding `delete`, and using typed arrays help the engine optimize your code.
</KeyConcept>

<ProgressCheckpoint section="introduction" xpReward={30} />

## The Event Loop In-Depth

Understanding the event loop is crucial for writing performant, non-blocking code.

### Execution Model

```
┌───────────────────────────┐
│        Call Stack         │
│  (Currently executing)    │
└───────────────────────────┘
            ↑
┌───────────────────────────┐
│     Microtask Queue       │
│  (Promises, queueMicrotask)│
└───────────────────────────┘
            ↑
┌───────────────────────────┐
│       Task Queue          │
│  (setTimeout, I/O, events)│
└───────────────────────────┘
            ↑
┌───────────────────────────┐
│    Render Steps           │
│  (rAF, Style, Layout, Paint)│
└───────────────────────────┘
```

### Event Loop Algorithm

```javascript
while (true) {
  // 1. Execute oldest task from task queue
  task = taskQueue.shift();
  execute(task);
  
  // 2. Execute ALL microtasks
  while (microtaskQueue.length > 0) {
    microtask = microtaskQueue.shift();
    execute(microtask);
  }
  
  // 3. If it's time to render:
  if (shouldRender()) {
    // Run requestAnimationFrame callbacks
    executeAnimationFrameCallbacks();
    
    // Render pipeline
    recalculateStyles();
    layout();
    paint();
    composite();
  }
}
```

<InfoBox type="warning" title="Long Tasks Block Rendering">
Tasks longer than 50ms are considered "long tasks" and can cause jank. Break up heavy computation with `setTimeout` or `requestIdleCallback`.
</InfoBox>

### requestIdleCallback

For non-urgent work, use `requestIdleCallback` to run during browser idle time:

```javascript
requestIdleCallback((deadline) => {
  while (deadline.timeRemaining() > 0 && tasks.length > 0) {
    doTask(tasks.shift());
  }
  
  if (tasks.length > 0) {
    requestIdleCallback(processRemainingTasks);
  }
});
```

<ProgressCheckpoint section="browser-architecture" xpReward={30} />

## GPU Acceleration and Compositing

Modern browsers leverage the GPU for smooth animations and efficient rendering.

### Layer Composition

The browser creates **compositor layers** for certain elements:

- Elements with `transform` or `opacity` animations
- Elements with `will-change` property
- `<video>`, `<canvas>`, WebGL content
- Elements with CSS filters
- Overlapping elements that need their own layer

```css
/* Promote to compositor layer */
.animated-element {
  will-change: transform;
  /* or */
  transform: translateZ(0);
}
```

### The Compositor Thread

The compositor runs on a separate thread from the main thread:

```
Main Thread                    Compositor Thread
─────────────                  ─────────────────
JavaScript                     Layer composition
Style calculation              GPU texture upload
Layout                         Scrolling (sometimes)
Paint (to layers)              Transform animations
                               Opacity animations
```

<KeyConcept title="Compositor-Only Animations">
Animations using only `transform` and `opacity` can run entirely on the compositor thread, achieving 60fps even when the main thread is busy.
</KeyConcept>

### Layer Explosion

Too many layers consume memory. Use DevTools (Layers panel) to audit:

```javascript
// Check layer count in DevTools Console
// Chrome: Rendering tab → Layer borders
```

<ProgressCheckpoint section="rendering-pipeline" xpReward={30} />

## Browser Security Model

Browsers implement multiple security layers to protect users.

### Same-Origin Policy

Resources from different origins are isolated:

```
Origin = Protocol + Host + Port
https://example.com:443 ≠ http://example.com:80
https://example.com ≠ https://api.example.com
```

**Cross-Origin Resource Sharing (CORS)** allows controlled access:

```http
Access-Control-Allow-Origin: https://trusted-site.com
Access-Control-Allow-Methods: GET, POST
Access-Control-Allow-Headers: Content-Type
```

### Content Security Policy (CSP)

CSP prevents XSS attacks by controlling resource loading:

```http
Content-Security-Policy: 
  default-src 'self';
  script-src 'self' https://trusted-cdn.com;
  style-src 'self' 'unsafe-inline';
  img-src *;
```

### Process Isolation (Site Isolation)

Modern browsers run different sites in separate processes:

```
┌─────────────────┐  ┌─────────────────┐
│ Process A       │  │ Process B       │
│ example.com     │  │ other-site.com  │
│ ┌─────────────┐ │  │ ┌─────────────┐ │
│ │ Renderer    │ │  │ │ Renderer    │ │
│ │ V8 Isolate  │ │  │ │ V8 Isolate  │ │
│ └─────────────┘ │  │ └─────────────┘ │
└─────────────────┘  └─────────────────┘
```

This prevents Spectre-style attacks from leaking data between sites.

<InfoBox type="info" title="Spectre Mitigations">
After Spectre, browsers added `Cross-Origin-Opener-Policy` and `Cross-Origin-Embedder-Policy` headers for additional isolation.
</InfoBox>

<ProgressCheckpoint section="javascript-engine" xpReward={25} />

## Advanced Performance Patterns

### Web Workers

Offload heavy computation to background threads:

```javascript
// main.js
const worker = new Worker('worker.js');
worker.postMessage({ data: largeArray });
worker.onmessage = (e) => console.log(e.data.result);

// worker.js
self.onmessage = (e) => {
  const result = heavyComputation(e.data);
  self.postMessage({ result });
};
```

### SharedArrayBuffer

For high-performance scenarios, share memory between threads:

```javascript
const sab = new SharedArrayBuffer(1024);
const view = new Int32Array(sab);
Atomics.add(view, 0, 1); // Thread-safe increment
```

### OffscreenCanvas

Render canvas in a worker:

```javascript
const offscreen = canvas.transferControlToOffscreen();
worker.postMessage({ canvas: offscreen }, [offscreen]);
```

### Virtual Scrolling

For long lists, only render visible items:

```javascript
function VirtualList({ items, itemHeight, containerHeight }) {
  const [scrollTop, setScrollTop] = useState(0);
  
  const startIndex = Math.floor(scrollTop / itemHeight);
  const endIndex = Math.min(
    startIndex + Math.ceil(containerHeight / itemHeight) + 1,
    items.length
  );
  
  const visibleItems = items.slice(startIndex, endIndex);
  // Render only visibleItems with offset
}
```

<ProgressCheckpoint section="performance" xpReward={25} />

## Debugging and Profiling

### Performance Panel

Chrome DevTools Performance panel shows:
- Main thread activity (yellow = JS, purple = rendering)
- Frame rate and dropped frames
- Long tasks (red corners)
- Memory usage

### Memory Panel

Identify memory leaks:
- Heap snapshots
- Allocation timeline
- Detached DOM nodes

### Lighthouse

Automated auditing for:
- Performance (LCP, FID, CLS)
- Accessibility
- Best practices
- SEO

<KeyConcept title="Measure, Don't Guess">
Always profile before optimizing. DevTools shows exactly where time is spent — focus your efforts there.
</KeyConcept>

<ProgressCheckpoint section="summary" xpReward={20} />

## Quick Quiz

<Quiz>
  <Question text="What is 'inline caching' in JavaScript engines?">
    <Answer>Storing JavaScript files in browser cache</Answer>
    <Answer correct>Caching property access patterns based on object shapes</Answer>
    <Answer>Inlining CSS in HTML</Answer>
    <Answer>Caching function return values</Answer>
  </Question>
  
  <Question text="Which animations can run on the compositor thread without involving the main thread?">
    <Answer>width and height</Answer>
    <Answer>margin and padding</Answer>
    <Answer correct>transform and opacity</Answer>
    <Answer>background-color and border</Answer>
  </Question>
  
  <Question text="What does Site Isolation protect against?">
    <Answer>SQL injection</Answer>
    <Answer>CSRF attacks</Answer>
    <Answer correct>Spectre-style side-channel attacks</Answer>
    <Answer>DDoS attacks</Answer>
  </Question>
  
  <Question text="When should you use requestIdleCallback?">
    <Answer>For critical rendering updates</Answer>
    <Answer>For user input handling</Answer>
    <Answer correct>For non-urgent background tasks</Answer>
    <Answer>For network requests</Answer>
  </Question>
  
  <Question text="What causes 'deoptimization' in V8?">
    <Answer>Using too many variables</Answer>
    <Answer correct>When runtime behavior invalidates optimization assumptions</Answer>
    <Answer>Having too many functions</Answer>
    <Answer>Using async/await</Answer>
  </Question>
</Quiz>

---

**Outstanding work!**  You now have deep knowledge of browser internals — from JavaScript engine optimization to GPU compositing and security models. This understanding will help you build faster, more secure web applications.
