# Interface Segregation Principle (ISP) ‚Äî Advanced

At the advanced level, we explore ISP in the context of **microservices API design**, **CQRS patterns**, **interface composition**, and the relationship between ISP and other architectural patterns.

---

## Section 1: ISP and Microservices Contracts

In microservices, ISP applies to **service contracts** (APIs). Fat APIs lead to tight coupling:

<DotnetCodePreview
  title="API-Level ISP: Service Contracts"
  code={`//  Fat API Contract - all clients get everything
public interface IOrderService
{
    // Customer operations
    Task<Order> CreateOrder(CreateOrderRequest req);
    Task<Order> GetOrder(Guid orderId);
    
    // Admin operations
    Task<IEnumerable<Order>> GetAllOrders(DateRange range);
    Task RefundOrder(Guid orderId);
    
    // Fulfillment operations
    Task<ShippingLabel> GenerateShippingLabel(Guid orderId);
}

//  Segregated Contracts (Backend-for-Frontend pattern)
public interface ICustomerOrderApi
{
    Task<Order> CreateOrder(CreateOrderRequest req);
    Task<Order> GetOrder(Guid orderId);
}

public interface IAdminOrderApi
{
    Task<IEnumerable<Order>> GetAllOrders(DateRange range);
    Task RefundOrder(Guid orderId);
}

public interface IFulfillmentOrderApi
{
    Task<ShippingLabel> GenerateShippingLabel(Guid orderId);
}`}
  steps={[
    {
      lineNumbers: [2, 3, 4, 5, 6, 7],
      highlight: "Fat API",
      explanation: "Single interface for ALL clients - causes tight coupling"
    },
    {
      lineNumbers: [16, 17, 18, 19, 20],
      highlight: "Customer API",
      explanation: "Mobile app only gets what it needs - decoupled!"
    }
  ]}
/>

<InfoBox type="important">
**BFF Pattern:** Backend-for-Frontend is ISP at the architecture level. Each client type gets a tailored API instead of a one-size-fits-all contract.
</InfoBox>

<ProgressCheckpoint section="isp-introduction" xpReward={20} />

---

## Section 2: CQRS - ISP for Read/Write

Command Query Responsibility Segregation is ISP applied to data access:

```csharp
// Traditional "fat" repository interface
public interface IRepository<T>
{
    T GetById(int id);
    IEnumerable<T> GetAll();
    void Add(T entity);
    void Update(T entity);
    void Delete(int id);
}

// CQRS: Segregated Read and Write
public interface IReader<T>
{
    T GetById(int id);
    IEnumerable<T> GetAll();
}

public interface IWriter<T>
{
    void Add(T entity);
    void Update(T entity);
    void Delete(int id);
}

// Query handlers only need read access
public class OrderQueryHandler
{
    private readonly IReader<Order> _reader;
    
    public Order Handle(GetOrderQuery query) 
        => _reader.GetById(query.OrderId);
}

// Command handlers only need write access
public class CreateOrderHandler
{
    private readonly IWriter<Order> _writer;
    
    public void Handle(CreateOrderCommand cmd)
    {
        var order = new Order(cmd.CustomerId, cmd.Items);
        _writer.Add(order);
    }
}
```

<SolidPrincipleDemo principle="I" mode="advanced" />

<ProgressCheckpoint section="isp-understanding" xpReward={20} />

---

## Section 3: Interface Composition and Trade-offs

### Mixin-Style Interfaces with Default Implementation (C# 8+)

```csharp
public interface ITimestamped
{
    DateTime CreatedAt { get; set; }
    DateTime UpdatedAt { get; set; }
    
    // Default implementation (C# 8+)
    void Touch() => UpdatedAt = DateTime.UtcNow;
}

public interface ISoftDeletable
{
    DateTime? DeletedAt { get; set; }
    bool IsDeleted => DeletedAt.HasValue;
    
    void SoftDelete() => DeletedAt = DateTime.UtcNow;
}

// Compose behaviors without inheritance hierarchy
public class Product : ITimestamped, ISoftDeletable
{
    public int Id { get; set; }
    public DateTime CreatedAt { get; set; }
    public DateTime UpdatedAt { get; set; }
    public DateTime? DeletedAt { get; set; }
    // Gets Touch(), SoftDelete() for free!
}
```

### Finding Balance

```csharp
// Too granular - overkill
interface IHasId { int Id { get; } }
interface IHasName { string Name { get; } }

// Better - cohesive grouping
interface IProduct
{
    int Id { get; }
    string Name { get; }
    decimal Price { get; }
}
```

### Key Takeaways

<InfoBox type="tip" title="Remember">
-  **API-level ISP** applies to microservice contracts
-  **CQRS** is ISP for data access (read/write separation)
- üß© **Composition** via multiple small interfaces
-  **DI benefits** from precise, focused dependencies
- Ô∏è **Balance** granularity vs. cognitive load
</InfoBox>

<ProgressCheckpoint section="isp-application" xpReward={20} />
