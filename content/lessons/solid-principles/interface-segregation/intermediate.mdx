# Interface Segregation Principle (ISP)

The Interface Segregation Principle states: **"No client should be forced to depend on methods it does not use."** Let's explore how to design cohesive, focused interfaces.

---

## Section 1: Fat Interface Anti-Pattern

A "fat interface" is an interface that has too many methods, forcing implementers to provide unnecessary functionality:

<DotnetCodePreview
  title="Fat Interface: IDocument"
  code={`// A "fat" interface - tries to do everything
public interface IDocument
{
    // Basic operations
    string GetContent();
    void SetContent(string content);
    void Save(string path);
    
    // Printing operations
    void Print();
    void PrintPreview();
    
    // Version control operations
    void Commit(string message);
    void Revert();
}

// Simple document forced to implement ALL methods!
public class SimpleTextDocument : IDocument
{
    public string GetContent() => _content;
    public void SetContent(string content) => _content = content;
    public void Save(string path) => File.WriteAllText(path, _content);
    
    //  Forced to implement printing!
    public void Print() => throw new NotSupportedException();
    public void PrintPreview() => throw new NotSupportedException();
    
    //  Forced to implement versioning!
    public void Commit(string msg) => throw new NotSupportedException();
    public void Revert() => throw new NotSupportedException();
}`}
  steps={[
    {
      lineNumbers: [4, 5, 6, 7],
      highlight: "Core Operations",
      explanation: "Basic document operations - all documents need these"
    },
    {
      lineNumbers: [9, 10, 11],
      highlight: "Printing Operations",
      explanation: "Not all documents need printing capabilities"
    },
    {
      lineNumbers: [23, 24, 25, 26],
      highlight: "Forced Implementation",
      explanation: "Simple text documents MUST implement methods they'll never use!"
    }
  ]}
/>

<InfoBox type="warning">
**Problem:** Every change to `IDocument` forces ALL implementations to update, even if the change is irrelevant to them.
</InfoBox>

<ProgressCheckpoint section="isp-introduction" xpReward={13} />

---

## Section 2: Applying ISP - Role Interfaces

Split the fat interface into focused "role interfaces":

<DotnetCodePreview
  title="Segregated Interfaces by Role"
  code={`// Core interface - minimal, essential operations
public interface IDocument
{
    string GetContent();
    void SetContent(string content);
}

// Persistence role
public interface IPersistable
{
    void Save(string path);
    void Load(string path);
}

// Printing role
public interface IPrintable
{
    void Print();
    void PrintPreview();
}

// Simple document: uses only what it needs
public class SimpleTextDocument : IDocument, IPersistable
{
    public string GetContent() => _content;
    public void SetContent(string content) => _content = content;
    public void Save(string path) => File.WriteAllText(path, _content);
    public void Load(string path) => _content = File.ReadAllText(path);
    // No printing, no versioning - not needed!
}

// Rich document: composes multiple roles
public class WordProcessor : IDocument, IPersistable, IPrintable
{
    // Implements ALL roles because it actually uses them
}`}
  steps={[
    {
      lineNumbers: [2, 3, 4, 5, 6],
      highlight: "Core Interface",
      explanation: "Absolute minimum every document needs"
    },
    {
      lineNumbers: [15, 16, 17, 18, 19],
      highlight: "Printing Role",
      explanation: "Separate concern - notebooks don't print"
    },
    {
      lineNumbers: [22, 23, 24, 25, 26, 27, 28, 29],
      highlight: "Composition",
      explanation: "Class picks exactly the roles it supports"
    }
  ]}
/>

<SolidPrincipleDemo principle="I" mode="intermediate" />

<ProgressCheckpoint section="isp-understanding" xpReward={14} />

---

## Section 3: Client-Specific Interfaces

Design interfaces from the client's perspective:

| Client | Needs |
|:-------|:------|
| **OrderProcessor** | `IOrderWriter.Save()` |
| **OrderReportService** | `IOrderReader.GetAll()` |
| **AdminPanel** | Both `IOrderReader` and `IOrderWriter` |

```csharp
public interface IOrderReader
{
    Order GetById(int id);
    IEnumerable<Order> GetAll();
}

public interface IOrderWriter
{
    void Save(Order order);
    void Delete(int id);
}

// Repository implements both, but clients only see what they need
public class OrderRepository : IOrderReader, IOrderWriter { }

// Inject only what's needed
public class OrderReportService
{
    private readonly IOrderReader _reader;  // Can only read!
    
    public OrderReportService(IOrderReader reader) => _reader = reader;
}
```

### Signs of ISP Violations

| Smell | Indicates |
|:------|:----------|
| `NotImplementedException` in methods | Class forced to implement unused method |
| `NotSupportedException` thrown | Operation doesn't make sense for this class |
| Empty method bodies | Placeholder for unused functionality |

### Key Takeaways

<InfoBox type="tip" title="Remember">
-  **Role interfaces** - Group methods by capability
-  **Client-focused** - Design from consumer's perspective
-  **Adapter pattern** - Facade over fat legacy interfaces
-  **No empty methods** - Sign of forced implementation
-  **Composition** - Classes compose multiple small interfaces
</InfoBox>

<ProgressCheckpoint section="isp-application" xpReward={13} />
