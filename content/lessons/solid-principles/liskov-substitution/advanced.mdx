# Liskov Substitution Principle (LSP) ‚Äî Advanced

At the advanced level, we explore LSP through the lens of **Design by Contract**, **covariance/contravariance**, **behavioral invariants**, and practical detection strategies in large .NET codebases.

---

## Section 1: Design by Contract (DbC)

Bertrand Meyer's Design by Contract provides the formal foundation for LSP:

| Contract Element | Definition | LSP Requirement |
|:-----------------|:-----------|:----------------|
| **Preconditions** | What must be true before a method runs | Subclass can only weaken |
| **Postconditions** | What must be true after a method runs | Subclass can only strengthen |
| **Invariants** | What must always be true | Subclass must preserve |

<InfoBox type="important">
**Formal Definition:** For type S to be a behavioral subtype of type T, program correctness using T must be preserved when using S instead.
</InfoBox>

### Covariance and Contravariance

C#'s type variance rules enforce LSP at the type system level:

```csharp
// Covariance (out) - Can return more specific types
public interface IProducer<out T>
{
    T Produce();  // Returns T
}

// IProducer<Animal> <- IProducer<Dog> ‚úÖ (Dog is more specific)
IProducer<Animal> animalProducer = new DogProducer();

// Contravariance (in) - Can accept more general types
public interface IConsumer<in T>
{
    void Consume(T item);  // Accepts T
}

// IConsumer<Dog> <- IConsumer<Animal> ‚úÖ (Animal is more general)
IConsumer<Dog> dogConsumer = new AnimalConsumer();
```

<ProgressCheckpoint section="lsp-introduction" xpReward={20} />

---

## Section 2: Architecture-Level LSP

LSP applies to API contracts between services:

```csharp
// V1 API Contract
public class OrderResponseV1
{
    public string OrderId { get; set; }
    public decimal Total { get; set; }  // Always positive
    public string Status { get; set; }  // "Pending", "Completed", "Cancelled"
}

// V2 API - Must remain substitutable for V1 clients!
public class OrderResponseV2 : OrderResponseV1
{
    // ‚úÖ Adding new properties is safe
    public DateTime? ShippedDate { get; set; }
    public string TrackingNumber { get; set; }
    
    // ‚ùå Changing Status to enum breaks string consumers
    // ‚ùå Making Total nullable breaks positive-assumption
    // ‚ùå Removing OrderId breaks deserialization
}
```

### API Evolution Guidelines

| Change Type | Safe? | Reason |
|:------------|:------|:-------|
| Add optional field |  | Old clients ignore it |
| Add new enum value | Ô∏è | Old clients may break on unknown value |
| Change field type |  | Breaks deserialization |
| Remove field |  | Breaks dependent clients |

<SolidPrincipleDemo principle="L" mode="advanced" />

<ProgressCheckpoint section="lsp-understanding" xpReward={20} />

---

## Section 3: Detection and Refactoring

### Contract Testing

Use shared test suites across implementations:

```csharp
public abstract class PaymentProcessorContractTests<T> 
    where T : IPaymentProcessor, new()
{
    protected abstract T CreateProcessor();
    
    [Fact]
    public void ProcessPayment_ValidAmount_ReturnsSuccess()
    {
        var processor = CreateProcessor();
        var result = processor.Process(100m, "valid-card");
        
        Assert.True(result.Success);
        Assert.Equal(100m, result.ChargedAmount);
    }
}

// All implementations run the same tests
public class StripeProcessorTests : PaymentProcessorContractTests<StripeProcessor>
{
    protected override StripeProcessor CreateProcessor() => new();
}
```

### Refactoring Away from LSP Violations

**Before: Inheritance-based violation**
```csharp
public abstract class Employee
{
    public abstract decimal CalculateBonus();
}

public class Contractor : Employee
{
    public override decimal CalculateBonus() 
        => throw new NotSupportedException();  // ‚ùå LSP violation
}
```

**After: Role-based interfaces**
```csharp
public interface IEmployee { string Name { get; } }
public interface IBonusEligible { decimal CalculateBonus(); }

public class FullTimeEmployee : IEmployee, IBonusEligible { /* ... */ }
public class Contractor : IEmployee { /* No bonus interface */ }
```

### Key Takeaways

<InfoBox type="tip" title="Remember">
-  **Design by Contract** formalizes LSP expectations
- ‚ÜïÔ∏è **Variance** enforces LSP at the type system level in C#
-  **API versioning** is architecture-level LSP
- üß™ **Contract tests** catch violations across implementations
-  **Role interfaces** are the solution to false inheritance
</InfoBox>

<ProgressCheckpoint section="lsp-application" xpReward={20} />
