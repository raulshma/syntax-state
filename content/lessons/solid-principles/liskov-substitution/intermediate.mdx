# Liskov Substitution Principle (LSP)

Barbara Liskov's principle states: **"Objects of a superclass should be replaceable with objects of a subclass without affecting the correctness of the program."**

---

## Section 1: Behavioral Subtyping

LSP is about **behavioral contracts**, not just interface matching. A subclass must:

1. **Accept** at least everything the parent accepts
2. **Return** at most what the parent returns
3. **Preserve** all invariants of the parent
4. **Not strengthen** preconditions
5. **Not weaken** postconditions

<InfoBox type="important">
**Key Insight:** A class can implement an interface or extend a class and still violate LSP if it doesn't honor the *behavioral* expectations.
</InfoBox>

### The Rectangle-Square Problem

<DotnetCodePreview
  title="LSP Violation: Square Extends Rectangle"
  code={`public class Rectangle
{
    public virtual int Width { get; set; }
    public virtual int Height { get; set; }
    
    public int CalculateArea() => Width * Height;
}

public class Square : Rectangle
{
    private int _side;
    
    public override int Width
    {
        get => _side;
        set => _side = value;  // Also changes height!
    }
    
    public override int Height
    {
        get => _side;
        set => _side = value;  // Also changes width!
    }
}`}
  steps={[
    {
      lineNumbers: [1, 2, 3, 4, 5, 6, 7],
      highlight: "Rectangle Contract",
      explanation: "Width and Height can be set independently - that's the contract"
    },
    {
      lineNumbers: [9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22],
      highlight: "Square Violates Contract",
      explanation: "Setting width also sets height! This changes expected behavior."
    }
  ]}
/>

<ProgressCheckpoint section="lsp-introduction" xpReward={13} />

---

## Section 2: Common LSP Violations

### Empty Method Implementations

```csharp
public class Bird
{
    public virtual void Fly() => /* flying logic */;
}

public class Penguin : Bird
{
    public override void Fly() 
    { 
        // Do nothing ‚ùå - Violates expected behavior
    }
}
```

### Type Checking in Client Code

When clients need to check types, you've violated LSP:

```csharp
public void MakeBirdFly(Bird bird)
{
    if (bird is Penguin)  // ‚ùå LSP smell!
        bird.Swim();
    else
        bird.Fly();
}
```

### NotImplementedException

```csharp
public class FileLogger : ILogger
{
    public void Log(string message) => File.AppendAllText(logPath, message);
    
    public void LogError(Exception ex)
    {
        throw new NotImplementedException();  // ‚ùå Breaks contract!
    }
}
```

<SolidPrincipleDemo principle="L" mode="intermediate" />

<ProgressCheckpoint section="lsp-understanding" xpReward={14} />

---

## Section 3: Solutions and Testing

### The Solution: Composition or Separate Hierarchy

```csharp
// Solution: Separate classes, shared interface
public interface IShape
{
    int CalculateArea();
}

public class Rectangle : IShape
{
    public int Width { get; set; }
    public int Height { get; set; }
    public int CalculateArea() => Width * Height;
}

public class Square : IShape
{
    public int Side { get; set; }
    public int CalculateArea() => Side * Side;
}

// No inheritance = no broken promises!
```

### Testing for LSP Compliance

Write tests that use the base type and run against all subtypes:

```csharp
[Theory]
[MemberData(nameof(GetAllShapes))]
public void Area_AlwaysPositive(IShape shape)
{
    // This test should pass for ALL shape implementations
    Assert.True(shape.CalculateArea() >= 0);
}

public static IEnumerable<object[]> GetAllShapes()
{
    yield return new object[] { new Rectangle { Width = 5, Height = 3 } };
    yield return new object[] { new Square { Side = 4 } };
    yield return new object[] { new Circle { Radius = 2 } };
}
```

### Key Takeaways

<InfoBox type="tip" title="Remember">
-  **Contracts matter** - Behavior, not just interface signatures
-  **No surprises** - Subclass shouldn't throw unexpected exceptions
-  **Preconditions** - Can weaken (accept more), never strengthen
-  **Postconditions** - Can strengthen (promise more), never weaken
- üß™ **Test polymorphically** - All subtypes should pass parent's tests
</InfoBox>

<ProgressCheckpoint section="lsp-application" xpReward={13} />
