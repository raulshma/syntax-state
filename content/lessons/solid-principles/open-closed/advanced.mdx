# Open/Closed Principle (OCP) — Advanced

At the advanced level, we explore OCP in enterprise contexts: **plugin architectures**, **reflection-based extensions**, **middleware pipelines**, and the trade-offs of premature abstraction.

---

## Section 1: OCP in ASP.NET Core Architecture

ASP.NET Core itself is a masterclass in OCP. The framework is **closed** to modification but **open** to extension through:

| Extension Point | What You Can Add |
|:----------------|:-----------------|
| **Middleware** | Request/response processing |
| **Services** | Custom implementations via DI |
| **Filters** | Action/result/exception handling |
| **Model Binders** | Custom parameter binding |
| **Tag Helpers** | Custom Razor HTML helpers |

<InfoBox type="important">
**Framework Insight:** When designing APIs or frameworks, study ASP.NET Core's extension patterns. They demonstrate OCP at scale.
</InfoBox>

### Building a Plugin System

Let's build a file processing system that supports unlimited file formats without modification:

<DotnetCodePreview
  title="Plugin Architecture: File Processors"
  code={`// 1. Define the extension point (abstraction)
public interface IFileProcessor
{
    string[] SupportedExtensions { get; }
    Task<ProcessingResult> ProcessAsync(
        Stream fileStream, 
        ProcessingOptions options);
}

// 2. Create a registry (closed to modification)
public class FileProcessorRegistry
{
    private readonly IEnumerable<IFileProcessor> _processors;
    
    public FileProcessorRegistry(IEnumerable<IFileProcessor> processors)
    {
        _processors = processors;
    }
    
    public IFileProcessor? GetProcessor(string extension)
    {
        return _processors.FirstOrDefault(p => 
            p.SupportedExtensions.Contains(extension, 
                StringComparer.OrdinalIgnoreCase));
    }
}`}
  steps={[
    {
      lineNumbers: [2, 3, 4, 5, 6, 7, 8],
      highlight: "Extension Point",
      explanation: "Interface is the contract - never changes once published"
    },
    {
      lineNumbers: [11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25],
      highlight: "Registry (Closed)",
      explanation: "Core logic never changes - just discovers registered processors"
    }
  ]}
/>

<ProgressCheckpoint section="ocp-introduction" xpReward={20} />

---

## Section 2: OCP in Middleware Pipelines

ASP.NET Core's middleware is a perfect OCP example:

```csharp
// Middleware: Open for extension
public class LoggingMiddleware
{
    private readonly RequestDelegate _next;
    
    public LoggingMiddleware(RequestDelegate next) => _next = next;
    
    public async Task InvokeAsync(HttpContext context)
    {
        Log($"Request: {context.Request.Path}");
        await _next(context);
        Log($"Response: {context.Response.StatusCode}");
    }
}

// Application: Closed to modification, open to new middleware
app.UseMiddleware<LoggingMiddleware>();
app.UseMiddleware<AuthenticationMiddleware>();
app.UseMiddleware<RateLimitingMiddleware>();  // Just add more!
```

### Building Custom Pipelines

Apply the same pattern to your domain:

```csharp
// Pipeline for order validation
public interface IOrderValidator
{
    int Order { get; }  // Execution order
    Task<ValidationResult> ValidateAsync(Order order);
}

public class OrderValidationPipeline
{
    private readonly IEnumerable<IOrderValidator> _validators;
    
    public async Task<ValidationResult> ValidateAsync(Order order)
    {
        foreach (var validator in _validators.OrderBy(v => v.Order))
        {
            var result = await validator.ValidateAsync(order);
            if (!result.IsValid) return result;
        }
        return ValidationResult.Success;
    }
}

// Add validators without touching the pipeline
public class InventoryValidator : IOrderValidator { /* ... */ }
public class PaymentValidator : IOrderValidator { /* ... */ }
public class FraudValidator : IOrderValidator { /* new! */ }
```

<SolidPrincipleDemo principle="O" mode="advanced" />

<ProgressCheckpoint section="ocp-understanding" xpReward={20} />

---

## Section 3: Trade-offs and Best Practices

### The Premature Abstraction Anti-Pattern

OCP requires **predicting** where extensions will occur. Predict wrong and you get:

```csharp
// Over-engineered: Created interfaces nobody ever implemented
public interface IStringFormatter { }
public interface IStringParserFactory { }
public interface IStringParserFactoryFactory { }  // Really?

// YAGNI: You Aren't Gonna Need It
public class SimpleFormatter
{
    public string Format(string input) => input.Trim().ToLower();
    // Just this. No interface. No factory. Done.
}
```

<InfoBox type="warning">
**YAGNI Warning:** Don't create abstractions "just in case." Wait for the *second* use case before abstracting. First time = concrete, second time = refactor to abstract.
</InfoBox>

### When to Apply OCP

| Apply OCP | Don't Apply OCP |
|:----------|:----------------|
| Known variation points | Truly one-off code |
| Framework/library code | Internal utilities |
| Payment processors, file formats | Simple CRUD operations |
| Algorithm variations | Stable domain logic |

### Measuring OCP Compliance

| Metric | Indicates OCP Violation |
|:-------|:-----------------------|
| **Shotgun Surgery** | One change → Many files modified |
| **Switch Statement Smell** | Switch/if-else on type |
| **Modification Frequency** | Same files changed repeatedly |
| **Test Fragility** | Unrelated tests break |

### Key Takeaways

<InfoBox type="tip" title="Remember">
-  **Plugin architecture** is the ultimate OCP expression
-  **Reflection** enables runtime extension discovery
-  **Middleware patterns** compose behaviors elegantly
- ️ **YAGNI balance** is crucial — don't over-abstract early
-  **Measure** with modification frequency and test fragility
</InfoBox>

<ProgressCheckpoint section="ocp-application" xpReward={20} />
