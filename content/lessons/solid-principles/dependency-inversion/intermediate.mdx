# Dependency Inversion Principle (DIP)

The Dependency Inversion Principle has two parts:

1. **High-level modules should not depend on low-level modules.** Both should depend on abstractions.
2. **Abstractions should not depend on details.** Details should depend on abstractions.

---

## Section 1: Understanding High-Level vs Low-Level

| Level | Description | Examples |
|:------|:------------|:---------|
| **High-Level** | Business logic, orchestration | `OrderService`, `InvoiceProcessor` |
| **Low-Level** | Technical details, infrastructure | `SqlDatabase`, `SmtpEmailSender` |

<InfoBox type="important">
**Key Insight:** "High-level" doesn't mean more important. It means closer to the business domain. "Low-level" means closer to implementation details.
</InfoBox>

### The Problem: Inverted Dependencies

<DotnetCodePreview
  title="Violating DIP: Direct Dependencies"
  code={`// High-level module (business logic)
public class OrderService
{
    //  DIRECT dependency on concrete implementation
    private readonly SqlServerDatabase _database;
    
    public OrderService()
    {
        //  Creates its own dependency - tightly coupled!
        _database = new SqlServerDatabase("Server=...");
    }
    
    public void PlaceOrder(OrderRequest request)
    {
        var order = new Order(request);
        _database.SaveOrder(order);  // Bound to SQL Server forever!
    }
}`}
  steps={[
    {
      lineNumbers: [4, 5],
      highlight: "Direct Dependency",
      explanation: "High-level module depends on concrete low-level class"
    },
    {
      lineNumbers: [8, 9, 10],
      highlight: "Self-Created Dependency",
      explanation: "OrderService creates its own database - cannot be swapped!"
    }
  ]}
/>

**Problems:**
-  Can't test `OrderService` without SQL Server
-  Can't switch to PostgreSQL without modifying `OrderService`

<ProgressCheckpoint section="dip-introduction" xpReward={13} />

---

## Section 2: The Solution - Invert the Dependency

<DotnetCodePreview
  title="Applying DIP: Abstraction Layer"
  code={`// Abstraction: The "contract" owned by the high-level module
public interface IOrderRepository
{
    void Save(Order order);
    Order GetById(int id);
}

// High-level module depends on abstraction
public class OrderService
{
    private readonly IOrderRepository _repository;
    
    //  Dependency INJECTED through constructor
    public OrderService(IOrderRepository repository)
    {
        _repository = repository;
    }
    
    public void PlaceOrder(OrderRequest request)
    {
        var order = new Order(request);
        _repository.Save(order);  // Doesn't know or care about SQL!
    }
}

// Low-level module implements the abstraction
public class SqlServerOrderRepository : IOrderRepository
{
    public void Save(Order order) { /* SQL implementation */ }
    public Order GetById(int id) { /* ... */ }
}

// Alternative implementation - same interface!
public class MongoOrderRepository : IOrderRepository
{
    public void Save(Order order) { /* MongoDB implementation */ }
    public Order GetById(int id) { /* ... */ }
}`}
  steps={[
    {
      lineNumbers: [2, 3, 4, 5, 6],
      highlight: "Abstraction",
      explanation: "Interface defines what's needed, not how it's done"
    },
    {
      lineNumbers: [12, 13, 14, 15],
      highlight: "Constructor Injection",
      explanation: "Receives implementation via constructor - can be swapped!"
    },
    {
      lineNumbers: [32, 33, 34, 35],
      highlight: "Alternative Implementation",
      explanation: "Same interface, different database - OrderService unchanged!"
    }
  ]}
/>

<SolidPrincipleDemo principle="D" mode="intermediate" />

<ProgressCheckpoint section="dip-understanding" xpReward={14} />

---

## Section 3: Dependency Injection in ASP.NET Core

ASP.NET Core has built-in dependency injection that makes DIP easy:

```csharp
// Program.cs - Configuration
var builder = WebApplication.CreateBuilder(args);

// Register abstraction with implementation
builder.Services.AddScoped<IOrderRepository, SqlServerOrderRepository>();

// Controller receives dependency automatically
public class OrdersController : ControllerBase
{
    private readonly IOrderRepository _repository;
    
    // ASP.NET Core injects the configured implementation
    public OrdersController(IOrderRepository repository)
    {
        _repository = repository;
    }
}
```

### Service Lifetimes

| Lifetime | Description | Use Case |
|:---------|:------------|:---------|
| **Transient** | New instance every time | Lightweight, stateless services |
| **Scoped** | One instance per request | Database contexts, unit of work |
| **Singleton** | One instance for application | Caches, configuration |

### Testing Benefits

```csharp
// With DIP: Use test doubles
[Test]
public void PlaceOrder_SavesOrder_ToRepository()
{
    var mockRepository = new Mock<IOrderRepository>();
    var service = new OrderService(mockRepository.Object);
    
    service.PlaceOrder(new OrderRequest { /* ... */ });
    
    mockRepository.Verify(r => r.Save(It.IsAny<Order>()), Times.Once);
}
```

### Key Takeaways

<InfoBox type="tip" title="Remember">
-  **Depend on interfaces** not concrete classes
-  **Inject dependencies** through constructors
-  **Configure at startup** not in business logic
- ðŸ§ª **Testing is easy** with mock implementations
-  **Swapping is easy** change config, not code
</InfoBox>

<ProgressCheckpoint section="dip-application" xpReward={13} />
