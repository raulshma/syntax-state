# Closures: Functions That Remember

Closures are one of JavaScript's most powerful features. A closure is a function that "remembers" the variables from its outer scope, even after that outer function has finished executing. It's like a function with a backpack full of memories!

---

## Section 1: Understanding Closures

### The Backpack Analogy üéí

Imagine a function as a person going on a trip. When they leave home (the outer function), they pack a backpack with things they might need (variables from the outer scope). Even when they're far from home, they still have access to everything in their backpack!

```javascript
function createGreeter(greeting) {
  // 'greeting' goes into the backpack
  
  return function(name) {
    // This inner function carries the backpack
    return greeting + ", " + name + "!";
  };
}

const sayHello = createGreeter("Hello");
const sayHi = createGreeter("Hi");

// Even though createGreeter finished, the inner functions
// still have access to their 'greeting' values!
console.log(sayHello("Alice")); // "Hello, Alice!"
console.log(sayHi("Bob"));      // "Hi, Bob!"
```

<CodePlayground
  initialCode={`// Closures in action - functions that remember

function createMultiplier(factor) {
  // 'factor' is captured in the closure
  return function(number) {
    return number * factor;
  };
}

// Create specialized functions
const double = createMultiplier(2);
const triple = createMultiplier(3);
const tenX = createMultiplier(10);

// Each function remembers its own 'factor'
console.log(double(5));  // 10
console.log(triple(5));  // 15
console.log(tenX(5));    // 50

// The original createMultiplier has finished,
// but the returned functions still have access to 'factor'!

console.log("---");

// Another example: counter factory
function createCounter(start = 0) {
  let count = start; // Captured in closure
  
  return {
    increment: () => ++count,
    decrement: () => --count,
    getCount: () => count
  };
}

const counter = createCounter(10);
console.log(counter.increment()); // 11
console.log(counter.increment()); // 12
console.log(counter.decrement()); // 11`}
  height={400}
/>

<KeyConcept title="What Makes a Closure?">
A closure is created when:
1. A function is defined inside another function
2. The inner function references variables from the outer function
3. The inner function is returned or passed elsewhere
</KeyConcept>

<ProgressCheckpoint section="closure-concept" xpReward={25} />

---

## Section 2: Lexical Scope

### How JavaScript Finds Variables

JavaScript uses **lexical scoping** - it determines variable access based on where functions are *written*, not where they're *called*.

<ScopeChainVisualizer />

```javascript
const globalVar = "I'm global";

function outer() {
  const outerVar = "I'm from outer";
  
  function inner() {
    const innerVar = "I'm from inner";
    
    // inner can access all three!
    console.log(innerVar);  // Own scope
    console.log(outerVar);  // Parent scope (closure!)
    console.log(globalVar); // Global scope
  }
  
  return inner;
}

const myFunc = outer();
myFunc(); // Still has access to outerVar!
```


<CodePlayground
  initialCode={`// Lexical scope - where you write determines access

const name = "Global";

function outer() {
  const name = "Outer";
  
  function middle() {
    const name = "Middle";
    
    function inner() {
      // Which 'name' does this access?
      console.log("Inner sees:", name);
    }
    
    inner();
    console.log("Middle sees:", name);
  }
  
  middle();
  console.log("Outer sees:", name);
}

outer();
console.log("Global sees:", name);

console.log("---");

// Scope chain visualization
function level1() {
  const a = 1;
  
  function level2() {
    const b = 2;
    
    function level3() {
      const c = 3;
      // Can access a, b, and c
      console.log("Level 3 can see: a=" + a + ", b=" + b + ", c=" + c);
    }
    
    level3();
    // Can access a and b, but NOT c
    console.log("Level 2 can see: a=" + a + ", b=" + b);
  }
  
  level2();
  // Can only access a
  console.log("Level 1 can see: a=" + a);
}

level1();`}
  height={450}
/>

<InfoBox type="info">
**Lexical** means "relating to words/text". Lexical scope is determined by where code is written in the source text, not by how it's called at runtime.
</InfoBox>

<ProgressCheckpoint section="lexical-scope" xpReward={20} />

---

## Section 3: Practical Closures

### Real-World Use Cases

Closures are everywhere in JavaScript! Here are common patterns:

#### 1. Data Privacy / Encapsulation

```javascript
function createBankAccount(initialBalance) {
  let balance = initialBalance; // Private!
  
  return {
    deposit(amount) {
      balance += amount;
      return balance;
    },
    withdraw(amount) {
      if (amount <= balance) {
        balance -= amount;
        return balance;
      }
      return "Insufficient funds";
    },
    getBalance() {
      return balance;
    }
  };
}

const account = createBankAccount(100);
account.deposit(50);  // 150
account.withdraw(30); // 120
// account.balance is undefined - it's private!
```

#### 2. Function Factories

```javascript
function createValidator(regex, errorMessage) {
  return function(value) {
    if (regex.test(value)) {
      return { valid: true };
    }
    return { valid: false, error: errorMessage };
  };
}

const validateEmail = createValidator(
  /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
  "Invalid email format"
);

const validatePhone = createValidator(
  /^\d{10}$/,
  "Phone must be 10 digits"
);
```

<CodePlayground
  initialCode={`// Practical closure patterns

// 1. Memoization - caching expensive calculations
function createMemoizedFunction(fn) {
  const cache = {}; // Closure captures this cache
  
  return function(...args) {
    const key = JSON.stringify(args);
    
    if (cache[key] !== undefined) {
      console.log("Cache hit for:", key);
      return cache[key];
    }
    
    console.log("Computing for:", key);
    const result = fn(...args);
    cache[key] = result;
    return result;
  };
}

const expensiveAdd = createMemoizedFunction((a, b) => {
  // Simulate expensive operation
  return a + b;
});

console.log(expensiveAdd(1, 2)); // Computing
console.log(expensiveAdd(1, 2)); // Cache hit!
console.log(expensiveAdd(3, 4)); // Computing

console.log("---");

// 2. Event handler with state
function createClickCounter(buttonName) {
  let clicks = 0;
  
  return function() {
    clicks++;
    console.log(buttonName + " clicked " + clicks + " times");
  };
}

const handleButtonA = createClickCounter("Button A");
const handleButtonB = createClickCounter("Button B");

handleButtonA(); // Button A clicked 1 times
handleButtonA(); // Button A clicked 2 times
handleButtonB(); // Button B clicked 1 times (separate counter!)

console.log("---");

// 3. Partial application
function multiply(a, b) {
  return a * b;
}

function partial(fn, ...presetArgs) {
  return function(...laterArgs) {
    return fn(...presetArgs, ...laterArgs);
  };
}

const double = partial(multiply, 2);
const triple = partial(multiply, 3);

console.log(double(5)); // 10
console.log(triple(5)); // 15`}
  height={500}
/>

<ProgressCheckpoint section="practical-closures" xpReward={25} />

---

## Section 4: Common Pitfalls

### The Classic Loop Problem

One of the most common closure mistakes involves loops:

```javascript
// ‚ùå The problem - all callbacks share the same 'i'
for (var i = 0; i < 3; i++) {
  setTimeout(function() {
    console.log(i); // Prints 3, 3, 3 (not 0, 1, 2!)
  }, 100);
}

// ‚úÖ Solution 1: Use let (creates new binding each iteration)
for (let i = 0; i < 3; i++) {
  setTimeout(function() {
    console.log(i); // Prints 0, 1, 2
  }, 100);
}

// ‚úÖ Solution 2: IIFE to capture value
for (var i = 0; i < 3; i++) {
  (function(j) {
    setTimeout(function() {
      console.log(j); // Prints 0, 1, 2
    }, 100);
  })(i);
}
```

<CodePlayground
  initialCode={`// The classic closure loop problem

console.log("Problem with var:");
// Using var - all functions share the same 'i'
var funcs = [];
for (var i = 0; i < 3; i++) {
  funcs.push(function() {
    return i;
  });
}
// By the time we call these, i is 3
console.log(funcs[0]()); // 3
console.log(funcs[1]()); // 3
console.log(funcs[2]()); // 3

console.log("---");

console.log("Solution with let:");
// Using let - each iteration gets its own 'i'
let funcs2 = [];
for (let i = 0; i < 3; i++) {
  funcs2.push(function() {
    return i;
  });
}
console.log(funcs2[0]()); // 0
console.log(funcs2[1]()); // 1
console.log(funcs2[2]()); // 2

console.log("---");

console.log("Solution with closure:");
// Using IIFE to capture value
var funcs3 = [];
for (var i = 0; i < 3; i++) {
  funcs3.push((function(captured) {
    return function() {
      return captured;
    };
  })(i));
}
console.log(funcs3[0]()); // 0
console.log(funcs3[1]()); // 1
console.log(funcs3[2]()); // 2`}
  height={450}
/>

<InfoBox type="warning">
**Memory Consideration**: Closures keep their outer scope variables alive in memory. If you create many closures referencing large objects, it can lead to memory issues. Be mindful of what your closures capture!
</InfoBox>

<Quiz id="closure-quiz">
  <Question>What does a closure "close over"?</Question>
  <Answer>The global scope only</Answer>
  <Answer>The function's own local variables</Answer>
  <Answer correct>Variables from its outer (enclosing) scope</Answer>
  <Answer>All variables in the program</Answer>
</Quiz>

### Summary

| Concept | Description |
|:--------|:------------|
| **Closure** | Function + its lexical environment |
| **Lexical Scope** | Variable access based on code location |
| **Data Privacy** | Hide variables, expose methods |
| **Function Factory** | Create specialized functions |
| **Loop Pitfall** | Use `let` or IIFE to capture values |

<ProgressCheckpoint section="common-pitfalls" xpReward={30} />
