# GitHub Actions for .NET - Intermediate

Now that you understand the basics, let's dive deeper into creating professional-grade CI pipelines for .NET applications. We'll cover multi-job workflows, caching, secrets, and artifacts.

## Beyond the Basics: Real-World Workflows 

Production workflows need more than just build and test. They need to handle:

- Multiple jobs running in parallel or sequence
- Caching dependencies for faster builds
- Secure handling of secrets
- Artifact storage for deployment

<GitHubActionsVisualizer mode="intermediate" showYaml={true} interactive={true} />

## Workflow Triggers Deep Dive 

GitHub Actions supports many trigger types:

```yaml
on:
  # Push to specific branches
  push:
    branches: [ main, develop ]
    paths:
      - 'src/**'        # Only trigger on changes in src/
      - '!src/**/*.md'  # Ignore markdown files
  
  # Pull request events
  pull_request:
    branches: [ main ]
    types: [ opened, synchronize, reopened ]
  
  # Scheduled (cron syntax)
  schedule:
    - cron: '0 2 * * *'  # Daily at 2 AM UTC
  
  # Manual trigger
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'staging'
```

<InfoBox type="info">
  The **paths** filter is powerful for monorepos - only trigger builds when relevant code changes!
</InfoBox>

## Multi-Job Workflows with Dependencies 

Jobs can run in parallel or depend on other jobs:

```yaml
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '8.0.x'
      - run: dotnet build -c Release
      - run: dotnet publish -c Release -o ./publish
      - uses: actions/upload-artifact@v4
        with:
          name: app-package
          path: ./publish

  test:
    runs-on: ubuntu-latest
    needs: build  # Wait for build to complete
    steps:
      - uses: actions/checkout@v4
      - run: dotnet test --collect:"XPlat Code Coverage"
      - uses: codecov/codecov-action@v4
        with:
          token: ${{ secrets.CODECOV_TOKEN }}

  deploy:
    runs-on: ubuntu-latest
    needs: [build, test]  # Wait for both
    if: github.ref == 'refs/heads/main'
    steps:
      - uses: actions/download-artifact@v4
        with:
          name: app-package
```

## Caching Dependencies for Speed 

NuGet package restoration can be slow. Cache them:

```yaml
- name: Cache NuGet packages
  uses: actions/cache@v4
  with:
    path: ~/.nuget/packages
    key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj') }}
    restore-keys: |
      ${{ runner.os }}-nuget-

- name: Restore dependencies
  run: dotnet restore
```

<KeyConcept title="Cache Keys Matter">
  Use `hashFiles('**/*.csproj')` to invalidate cache when dependencies change. The cache is automatically restored on subsequent runs!
</KeyConcept>

## Matrix Builds - Test Multiple Configurations üß™

Test your code across multiple .NET versions and operating systems:

```yaml
jobs:
  test:
    strategy:
      matrix:
        dotnet: ['6.0.x', '7.0.x', '8.0.x']
        os: [ubuntu-latest, windows-latest, macos-latest]
      fail-fast: false  # Continue others if one fails
    
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ matrix.dotnet }}
      - run: dotnet test
```

This creates **9 parallel jobs** (3 .NET versions √ó 3 operating systems)!

## Secrets Management 

Never hardcode sensitive values. Use GitHub Secrets:

```yaml
steps:
  - name: Deploy to Azure
    env:
      AZURE_CREDENTIALS: ${{ secrets.AZURE_CREDENTIALS }}
      CONNECTION_STRING: ${{ secrets.DB_CONNECTION }}
    run: |
      dotnet publish -c Release
      # Use environment variables safely
```

<InfoBox type="warning">
  **Secrets are masked** in logs automatically. Never echo them or write them to files that get uploaded as artifacts!
</InfoBox>

## Working with Artifacts 

Artifacts persist data between jobs and workflow runs:

```yaml
# Upload
- uses: actions/upload-artifact@v4
  with:
    name: test-results
    path: |
      **/TestResults/*.trx
      **/coverage.cobertura.xml
    retention-days: 30

# Download in another job
- uses: actions/download-artifact@v4
  with:
    name: test-results
    path: ./results
```

## Environment Protection Rules Ô∏è

For production deployments, configure environment protection:

```yaml
jobs:
  deploy-production:
    runs-on: ubuntu-latest
    environment: 
      name: production
      url: https://myapp.azurewebsites.net
    steps:
      - name: Deploy
        run: echo "Deploying to production..."
```

Configure required reviewers and wait timers in GitHub repository settings!

## Key Takeaways

-  **Triggers** control when workflows run (push, PR, schedule, manual)
-  **Job dependencies** with `needs:` create sequential pipelines
-  **Caching** speeds up builds significantly
- üß™ **Matrix builds** test multiple configurations in parallel
-  **Secrets** keep credentials secure
-  **Artifacts** pass data between jobs

<ProgressCheckpoint section="ga-workflow-basics" xpReward={50} />
