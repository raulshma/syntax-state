# Variable Declarations: Deep Dive

This lesson explores the internals of JavaScript variable declarations, including memory allocation, specification details, and common interview gotchas.

## The ECMAScript Specification View

In the ECMAScript specification, variables are stored in **Environment Records**. Different declaration keywords create different types of bindings:

| Keyword | Binding Type    | Initialization | Mutable |
| :------ | :-------------- | :------------- | :------ |
| var     | Var binding     | undefined      | Yes     |
| let     | Lexical binding | Uninitialized  | Yes     |
| const   | Lexical binding | Uninitialized  | No      |

<ProgressCheckpoint section="intro-declarations" xpReward={15} />

## Hoisting and the Temporal Dead Zone

All declarations are hoisted, but their behavior during the TDZ differs significantly.

### var Hoisting - Full Behavior

When the JavaScript engine processes a scope, `var` declarations are:

1. **Created** at the top of the function scope
2. **Initialized** to `undefined`
3. **Available** for access (returns undefined before assignment)

```javascript
// What you write:
console.log(x);
var x = 5;

// How the engine sees it:
var x = undefined; // Hoisted and initialized
console.log(x); // undefined
x = 5; // Assignment stays in place
```

### let/const Hoisting - The TDZ

`let` and `const` are hoisted differently:

1. **Created** at the top of the block scope
2. **NOT initialized** (enters TDZ)
3. **Inaccessible** until the declaration is evaluated

```javascript
// This creates a TDZ from the start of the block to the let declaration
{
  // TDZ starts here for 'x'
  console.log(x); // ReferenceError: Cannot access 'x' before initialization
  let x = 5; // TDZ ends here
  console.log(x); // 5
}
```

<HoistingSimulator />

<ProgressCheckpoint section="var-keyword" xpReward={15} />

## Memory Allocation and Optimization

JavaScript engines optimize variable storage based on usage patterns.

### Stack vs Heap Allocation

```javascript
// Primitives - typically stack allocated
let count = 42; // Small, fixed size
let name = "Alice"; // String interning may apply
let active = true; // Boolean, very small

// Objects - heap allocated
const user = {
  // Reference on stack, object on heap
  name: "Bob",
  age: 30,
};

// Closures affect memory
function createCounter() {
  let count = 0; // Must persist in closure, may not be optimized
  return () => ++count;
}
```

### V8 Engine Optimizations

Modern engines like V8 perform several optimizations:

1. **Hidden Classes**: Variables declared consistently create efficient object shapes
2. **Inline Caching**: Repeated access patterns are optimized
3. **Escape Analysis**: Variables that don't escape may be stack-allocated

<CodePlayground 
  code={`// Consistent property ordering helps V8 optimization
function createUser(name, age) {
  return {
    name: name,  // Always same order
    age: age,    // Creates same "hidden class"
    active: true
  };
}

// This is less optimizable:
function createUserBad(name, age) {
const user = {};
if (age > 18) {
user.age = age; // Conditional property
}
user.name = name; // Different order
return user;
}

console.log(createUser("Alice", 25));`}
title="V8 Optimization Patterns"
/>

<ProgressCheckpoint section="let-keyword" xpReward={15} />

## Interview Deep Dive: Edge Cases

### 1. Loop Variable Capture

A classic interview question about `var` in loops:

```javascript
// The var problem
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100);
}
// Output: 3, 3, 3 (all reference same variable)

// The let solution
for (let j = 0; j < 3; j++) {
  setTimeout(() => console.log(j), 100);
}
// Output: 0, 1, 2 (each iteration gets new binding)
```

### 2. Global Object Pollution

```javascript
// var creates a property on globalThis (window in browsers)
var globalVar = "I'm global";
console.log(globalThis.globalVar); // "I'm global"

// let/const do NOT
let globalLet = "Also global scope";
console.log(globalThis.globalLet); // undefined
```

### 3. Redeclaration Behavior

```javascript
// var allows redeclaration
var x = 1;
var x = 2; // OK

// let does not in same scope
let y = 1;
// let y = 2; // SyntaxError: Identifier 'y' has already been declared

// But shadowing in nested scope is fine
let z = 1;
{
  let z = 2; // OK - different scope, this shadows outer z
  console.log(z); // 2
}
console.log(z); // 1
```

### 4. The typeof TDZ Exception

```javascript
// typeof with undeclared variable returns 'undefined'
console.log(typeof notDeclared); // 'undefined' (no error!)

// But typeof in TDZ still throws
{
  // console.log(typeof x); // ReferenceError!
  let x = 5;
}
```

<CodePlayground 
  code={`// Famous interview question: What's the output?
function test() {
  console.log(a); // ?
  console.log(b); // ?
  
  var a = 1;
  let b = 2;
}

// Uncomment to see:
// test();

// Answer:
// a logs 'undefined' (var is hoisted and initialized)
// b throws ReferenceError (let is in TDZ)`}
title="Interview Question: Hoisting"
/>

<ProgressCheckpoint section="const-keyword" xpReward={15} />

## const and Immutability Patterns

`const` only prevents reassignment, not mutation. For true immutability:

```javascript
// Object.freeze for shallow immutability
const config = Object.freeze({
  api: "https://api.example.com",
  timeout: 5000,
});
config.api = "new"; // Silently fails (throws in strict mode)

// Deep freeze for nested objects
function deepFreeze(obj) {
  Object.keys(obj).forEach((key) => {
    if (typeof obj[key] === "object" && obj[key] !== null) {
      deepFreeze(obj[key]);
    }
  });
  return Object.freeze(obj);
}

// Immutable patterns with spread
const original = { a: 1, b: 2 };
const updated = { ...original, b: 3 }; // New object, original unchanged
```

### Performance Considerations

```javascript
// const enables some optimizations
const PI = 3.14159; // Engine knows this never changes

// But for objects, const provides no optimization benefit
const user = { name: "Alice" }; // Object can still change
```

<Quiz id="var-let-const-advanced">
  <Question
    id="q1"
    text="What does typeof return for a variable in the Temporal Dead Zone?"
  >
    <Answer id="a" text="'undefined'" />
    <Answer id="b" text="Throws ReferenceError" isCorrect />
    <Answer id="c" text="'uninitialized'" />
    <Answer id="d" text="null" />
  </Question>
  <Question id="q2" text="Which statement about var in global scope is TRUE?">
    <Answer id="a" text="It creates a property on globalThis" isCorrect />
    <Answer id="b" text="It creates a separate global binding" />
    <Answer id="c" text="It behaves the same as let" />
    <Answer id="d" text="It throws an error" />
  </Question>
  <Question
    id="q3"
    text="In a for loop, why does let capture the correct value in each iteration?"
  >
    <Answer id="a" text="let uses special closure magic" />
    <Answer id="b" text="Each iteration creates a new binding" isCorrect />
    <Answer id="c" text="let is not hoisted" />
    <Answer id="d" text="let is copied by value" />
  </Question>
  <Question
    id="q4"
    text="How can you achieve true immutability with const objects?"
  >
    <Answer id="a" text="Use const with 'strict' keyword" />
    <Answer id="b" text="Use Object.freeze() or deep freeze" isCorrect />
    <Answer id="c" text="const objects are automatically immutable" />
    <Answer id="d" text="Use Object.seal()" />
  </Question>
</Quiz>

<ProgressCheckpoint section="comparison" xpReward={20} />
