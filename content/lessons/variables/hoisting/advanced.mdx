# Hoisting: Deep Internals and Interview Mastery

This lesson covers the ECMAScript specification details of hoisting, compilation phases, and common interview questions that test deep understanding.

## The ECMAScript View: Lexical Environments

In the specification, hoisting is implemented through **Lexical Environments** and **Environment Records**.

### Creation Phase Details

When a function is called, JavaScript creates an execution context with:

1. **VariableEnvironment**: Contains `var` and `function` declarations
2. **LexicalEnvironment**: Contains `let` and `const` declarations

```javascript
// Conceptual representation of execution context
ExecutionContext = {
  VariableEnvironment: {
    EnvironmentRecord: {
      myVar: undefined,      // var - initialized
      myFunc: <function>     // function - fully hoisted
    }
  },
  LexicalEnvironment: {
    EnvironmentRecord: {
      myLet: <uninitialized>,  // let - TDZ
      myConst: <uninitialized> // const - TDZ
    }
  }
}
```

<ProgressCheckpoint section="what-is-hoisting" xpReward={15} />

## The Compilation Phase in Detail

JavaScript engines process code in two passes:

### Pass 1: Parsing and Compilation

1. **Tokenization**: Break code into tokens
2. **Parsing**: Build Abstract Syntax Tree (AST)
3. **Variable collection**: Identify all declarations
4. **Scope analysis**: Determine where each variable belongs

### Pass 2: Execution

1. **Environment creation**: Set up variable bindings
2. **Code execution**: Run line by line
3. **Garbage collection**: Clean up when done

<HoistingSimulator showPhases={true} />

<CodePlayground 
  code={`// Demonstrating compilation vs execution
// During compilation, JavaScript sees:
// var a (hoisted to function scope)
// function b (fully hoisted)
// let c (noted, but TDZ)
// const d (noted, but TDZ)

function demo() {
console.log("1. typeof a:", typeof a); // "undefined"
console.log("2. typeof b:", typeof b); // "function"

// These would throw ReferenceError (TDZ):
// console.log(c);
// console.log(d);

var a = 1;
function b() { return "hoisted function"; }
let c = 3;
const d = 4;

console.log("3. Values after declaration:");
console.log("a:", a, "b():", b(), "c:", c, "d:", d);
}

demo();`}
title="Compilation Phase Demo"
/>

<ProgressCheckpoint section="var-hoisting" xpReward={15} />

## TDZ Deep Dive

The Temporal Dead Zone is NOT about physical location in code - it's about **time** during execution.

### TDZ Edge Cases

```javascript
// TDZ applies even to typeof
{
  // console.log(typeof x); // ReferenceError
  let x = 1;
}

// But typeof for undeclared variables is safe
console.log(typeof undeclaredVar); // "undefined"

// TDZ in default parameters
function buggy(a = b, b = 2) {
  return a + b;
}
// buggy(); // ReferenceError: b is in TDZ when evaluating 'a = b'

// Fixed order:
function fixed(a = 2, b = a) {
  return a + b;
}
console.log(fixed()); // 4
```

### TDZ and Classes

```javascript
// Classes also have TDZ
// const instance = new MyClass(); // ReferenceError

class MyClass {
  constructor() {
    this.value = 42;
  }
}

const instance = new MyClass(); // Works after declaration
```

<ProgressCheckpoint section="let-const-hoisting" xpReward={15} />

## Function Hoisting Nuances

### Function Declaration vs Expression Priority

When both exist with the same name:

```javascript
// What gets hoisted?
console.log(typeof foo); // "function"

var foo = 1;
function foo() {}

console.log(typeof foo); // "number" (var assignment wins in execution)

// The engine sees:
// function foo() {} (hoisted first)
// var foo; (ignored - foo already exists)
// execution: console.log, foo = 1, console.log
```

### Block-Scoped Function Declarations

In strict mode and ES6+, function declarations in blocks are tricky:

```javascript
"use strict";

// Block-scoped function in strict mode
{
  function blockFunc() {
    return "I'm in a block";
  }
  console.log(blockFunc()); // Works
}

// console.log(blockFunc()); // ReferenceError in strict mode
```

<CodePlayground 
  code={`// Interview classic: What's logged?
var x = 1;

function test() {
console.log(x); // undefined (local var shadows)
var x = 2;
console.log(x); // 2
}

test();
console.log(x); // 1 (global unchanged)

// Another classic:
function hoistOrder() {
console.log(f); // [Function: f]

var f = 1;
function f() {}

console.log(f); // 1
}

hoistOrder();`}
title="Interview: Hoisting Order"
/>

<ProgressCheckpoint section="function-hoisting" xpReward={15} />

## Interview Deep Dive: Tricky Scenarios

### Scenario 1: Conditional Declarations

```javascript
// Old browsers (pre-ES6):
if (true) {
  function test() {
    return "if block";
  }
} else {
  function test() {
    return "else block";
  }
}
console.log(test()); // Unpredictable in old JS!

// ES6 strict mode: Block-scoped
// Modern behavior is more predictable
```

### Scenario 2: Closures and Hoisting

```javascript
function createFunctions() {
  var result = [];

  for (var i = 0; i < 3; i++) {
    result.push(function () {
      return i; // All reference the same hoisted 'i'
    });
  }

  return result;
}

var funcs = createFunctions();
console.log(funcs[0]()); // 3
console.log(funcs[1]()); // 3
console.log(funcs[2]()); // 3

// Fix with IIFE or let
function createFunctionsFixed() {
  var result = [];

  for (let i = 0; i < 3; i++) {
    // let creates new binding each iteration
    result.push(function () {
      return i;
    });
  }

  return result;
}
```

### Scenario 3: Self-Referencing Functions

```javascript
// Named function expression
var factorial = function fact(n) {
  console.log(typeof fact); // "function" - available inside
  return n <= 1 ? 1 : n * fact(n - 1);
};

console.log(factorial(5)); // 120
// console.log(typeof fact); // ReferenceError - not available outside
```

### Scenario 4: The Arguments Shadow

```javascript
function test(x) {
  console.log(x); // 1 (parameter)
  var x = 2; // var re-declaration
  function x() {} // function declaration
  console.log(x); // 2
}

test(1);

// Hoisting order: function > parameter > var
// But var assignment happens during execution
```

<CodePlayground 
  code={`// Ultimate interview question
var a = 1;

function outer() {
console.log(a); // What logs here?

if (false) {
var a = 2; // Never executes, but var still hoists!
}

console.log(a); // And here?
}

outer();

// Answer: undefined, undefined
// The var a inside outer shadows the global a
// even though the if block never runs!`}
title="Ultimate Hoisting Question"
/>

<Quiz id="hoisting-advanced">
  <Question
    id="q1"
    text="Why does typeof throw for TDZ variables but not undeclared ones?"
  >
    <Answer id="a" text="TDZ variables are 'dead' in memory" />
    <Answer
      id="b"
      text="The engine detects the binding exists but is uninitialized"
      isCorrect
    />
    <Answer id="c" text="typeof is buggy in JavaScript" />
    <Answer id="d" text="TDZ variables have a special type" />
  </Question>
  <Question
    id="q2"
    text="What happens when var and function have the same name?"
  >
    <Answer id="a" text="SyntaxError" />
    <Answer
      id="b"
      text="Function hoists first, var initialization wins during execution"
      isCorrect
    />
    <Answer id="c" text="var always wins" />
    <Answer id="d" text="The second declaration is ignored" />
  </Question>
  <Question
    id="q3"
    text="In the loop 'for (var i...)' with closures problem, why does let fix it?"
  >
    <Answer id="a" text="let prevents hoisting entirely" />
    <Answer id="b" text="let is copied by value into closures" />
    <Answer
      id="c"
      text="let creates a new binding for each loop iteration"
      isCorrect
    />
    <Answer id="d" text="let automatically creates an IIFE" />
  </Question>
  <Question
    id="q4"
    text="What logs: var x = 1; (function() { console.log(x); var x = 2; })();"
  >
    <Answer id="a" text="1" />
    <Answer id="b" text="undefined" isCorrect />
    <Answer id="c" text="2" />
    <Answer id="d" text="ReferenceError" />
  </Question>
</Quiz>

<ProgressCheckpoint section="practical-implications" xpReward={20} />
