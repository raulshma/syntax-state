# Response Caching: Speed Up Your API

Imagine you're a cashier at a popular coffee shop. Every customer orders the same "Menu of the Day." Instead of walking to the kitchen each time, you keep a printed copy at your counter and just hand it to customers. Much faster!

That's exactly what **Response Caching** does for your web APIs!

## What is Response Caching?

Response Caching stores the entire HTTP response (the data your API sends back) so that repeated requests get the same answer **instantly**, without re-executing your code.

> **Real-World Analogy**: Think of a photocopy machine. Instead of rewriting the same document by hand 100 times, you write it once and make photocopies!

### How It Helps

| Without Response Cache | With Response Cache |
|:----------------------|:-------------------|
|  Process every request |  Return cached response |
|  CPU works hard |  CPU relaxes |
| Ô∏è Database hit every time |  Database saved |
|  200ms response time |  5ms response time |

<InfoBox type="info">
**Response Caching** is perfect for API endpoints that return the same data for all users, like product catalogs, blog posts, or public data.
</InfoBox>

## How Does It Work?

When a request comes in:

1.  **Check cache**: "Do I have this response saved?"
2.  **If YES**: Return it immediately!
3.  **If NO**: Process the request, save the response, then return it

<DotnetCodePreview 
  language="csharp"
  code={`[ApiController]
[Route("api/[controller]")]
public class ProductsController : ControllerBase
{
    // Cache this response for 60 seconds
    [HttpGet]
    [ResponseCache(Duration = 60)]
    public async Task<IActionResult> GetProducts()
    {
        var products = await _db.Products.ToListAsync();
        return Ok(products);
    }
}`}
/>

In this example:
- First request: Takes 200ms (database query)
- Next requests (within 60 seconds): Take 5ms (from cache!)
- After 60 seconds: Cache expires, next request rebuilds cache

## Setting Up Response Caching

### Step 1: Add the Middleware

In `Program.cs`:

```csharp
var builder = WebApplication.CreateBuilder(args);

// Add response caching service
builder.Services.AddResponseCaching();

var app = builder.Build();

// Use response caching middleware
app.UseResponseCaching();

app.MapControllers();
app.Run();
```

### Step 2: Add the Attribute

On your controller action:

```csharp
[ResponseCache(Duration = 300)] // Cache for 5 minutes
public IActionResult GetCategories()
{
    var categories = _db.Categories.ToList();
    return Ok(categories);
}
```

<InfoBox type="warning">
**Important**: Response caching only works for **GET** and **HEAD** HTTP requests. POST, PUT, DELETE requests are never cached!
</InfoBox>

## Cache Duration

The `Duration` parameter specifies how long (in seconds) to cache the response:

```csharp
[ResponseCache(Duration = 60)]       // 1 minute
[ResponseCache(Duration = 300)]      // 5 minutes
[ResponseCache(Duration = 3600)]     // 1 hour
[ResponseCache(Duration = 86400)]    // 24 hours
```

**Rule of Thumb**:
-  News/blog posts: 5-30 minutes
-  Product catalogs: 15-60 minutes
- Ô∏è Configuration data: 1-24 hours
-  Real-time data: Don't cache!

## When to Use Response Caching

 **Perfect For:**
-  Public data (same for all users)
-  Blog posts and articles
-  Product catalogs
-  Public statistics/reports
- Ô∏è Reference data (countries, categories)

 **Don't Use For:**
-  User-specific data
-  Authenticated content
-  Shopping carts
-  Form submissions
-  Real-time data

## Cache vs. No Cache Example

### Without Caching
```csharp
[HttpGet("slow")]
public async Task<IActionResult> GetSlowData()
{
    // This runs EVERY time
    await Task.Delay(2000); // Simulate slow operation
    var data = "Slow response";
    return Ok(data);
}
// Every request takes 2 seconds üò∞
```

### With Caching
```csharp
[HttpGet("fast")]
[ResponseCache(Duration = 300)]
public async Task<IActionResult> GetFastData()
{
    // This runs ONCE, then cached for 5 minutes
    await Task.Delay(2000); // Simulate slow operation
    var data = "Fast response";
    return Ok(data);
}
// First request: 2 seconds
// Next requests: 5 milliseconds! ‚ö°
```

## Disabling Cache

Sometimes you want to explicitly say "Never cache this!":

```csharp
[ResponseCache(NoStore = true, Location = ResponseCacheLocation.None)]
public IActionResult GetSensitiveData()
{
    // This will NEVER be cached
    return Ok(sensitiveData);
}
```

## How Browsers Use the Cache

When you add `[ResponseCache]`, ASP.NET Core adds special headers to the response:

```
Cache-Control: public, max-age=60
```

This tells the browser:
-  **public**: Anyone can cache this
- ‚è∞ **max-age=60**: Cache for 60 seconds

<InfoBox type="tip">
**Pro Tip**: Both the **browser** and the **server** cache the response! This means even faster responses for repeat visitors.
</InfoBox>

## Common Pitfalls

###  Wrong: Caching User-Specific Data
```csharp
[ResponseCache(Duration = 300)]
public IActionResult GetMyOrders()
{
    // DON'T DO THIS! User A will see User B's orders!
    var orders = _db.Orders.Where(o => o.UserId == currentUserId);
    return Ok(orders);
}
```

###  Right: Cache Public Data Only
```csharp
[ResponseCache(Duration = 300)]
public IActionResult GetAllProducts()
{
    // GOOD! Same products for everyone
    var products = _db.Products.Where(p => p.IsActive);
    return Ok(products);
}
```

## Quick Wins

Here are easy endpoints to cache right now:

```csharp
// Cache product categories
[ResponseCache(Duration = 3600)]
[HttpGet("categories")]
public IActionResult GetCategories() => Ok(_db.Categories.ToList());

// Cache blog posts list
[ResponseCache(Duration = 900)]
[HttpGet("posts")]
public IActionResult GetPosts() => Ok(_db.BlogPosts.ToList());

// Cache site configuration
[ResponseCache(Duration = 86400)]
[HttpGet("config")]
public IActionResult GetConfig() => Ok(_configuration);
```

<ProgressCheckpoint section="response-caching-basics" xpReward={25} />
