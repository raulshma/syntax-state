# Multi-Mapping - Intermediate

Master practical multi-mapping patterns for real-world applications including one-to-many relationships, deduplication strategies, and efficient data loading.

<InfoBox type="tip" title="Level Up">
This lesson covers one-to-many mapping, dictionary-based deduplication, QueryMultiple for complex scenarios, and production-ready patterns.
</InfoBox>

<ProgressCheckpoint section="introduction-multi-mapping" xpReward={10} />

## Section 1: Introduction to Advanced Multi-Mapping

### Beyond Simple Joins

In real applications, relationships are rarely simple one-to-one. You'll encounter:
- One customer with many orders
- One order with many items
- Products with multiple categories and tags

The challenge is that SQL JOINs create **duplicate rows** for the parent entity.

```sql
-- This query returns 3 rows for Alice (one per order)
SELECT c.*, o.*
FROM Customers c
LEFT JOIN Orders o ON o.CustomerId = c.CustomerId
WHERE c.CustomerId = 1
```

| CustomerId | Name | OrderId | Total |
|------------|------|---------|-------|
| 1 | Alice | 101 | 50.00 |
| 1 | Alice | 102 | 75.00 |
| 1 | Alice | 103 | 30.00 |

We need to **deduplicate** Alice and collect her orders into a list.

<ProgressCheckpoint section="two-type-mapping" xpReward={10} />

---

## Section 2: Two-Type Mapping with Collections

### The Dictionary Pattern

Use a dictionary to track seen entities and build collections:

```csharp
public class Customer
{
    public int CustomerId { get; set; }
    public string Name { get; set; }
    public string Email { get; set; }
    public List<Order> Orders { get; set; } = new();
}

public class Order
{
    public int OrderId { get; set; }
    public int CustomerId { get; set; }
    public decimal Total { get; set; }
}

public async Task<Customer?> GetCustomerWithOrdersAsync(int customerId)
{
    var sql = @"
        SELECT c.*, o.*
        FROM Customers c
        LEFT JOIN Orders o ON o.CustomerId = c.CustomerId
        WHERE c.CustomerId = @customerId";

    var customerDict = new Dictionary<int, Customer>();

    await using var connection = new SqlConnection(_connectionString);
    await connection.QueryAsync<Customer, Order, Customer>(
        sql,
        (customer, order) =>
        {
            // Check if we've seen this customer
            if (!customerDict.TryGetValue(customer.CustomerId, out var existing))
            {
                existing = customer;
                customerDict.Add(customer.CustomerId, existing);
            }

            // Add order to collection (handle LEFT JOIN nulls)
            if (order != null)
            {
                existing.Orders.Add(order);
            }

            return existing;
        },
        new { customerId },
        splitOn: "OrderId"
    );

    return customerDict.Values.FirstOrDefault();
}
```

### Multiple Customers with Orders

```csharp
public async Task<List<Customer>> GetAllCustomersWithOrdersAsync()
{
    var sql = @"
        SELECT c.*, o.*
        FROM Customers c
        LEFT JOIN Orders o ON o.CustomerId = c.CustomerId
        ORDER BY c.CustomerId, o.OrderId";

    var customerDict = new Dictionary<int, Customer>();

    await using var connection = new SqlConnection(_connectionString);
    await connection.QueryAsync<Customer, Order, Customer>(
        sql,
        (customer, order) =>
        {
            if (!customerDict.TryGetValue(customer.CustomerId, out var existing))
            {
                existing = customer;
                customerDict.Add(customer.CustomerId, existing);
            }

            if (order != null)
            {
                existing.Orders.Add(order);
            }

            return existing;
        },
        splitOn: "OrderId"
    );

    return customerDict.Values.ToList();
}
```

<ProgressCheckpoint section="spliton-parameter" xpReward={10} />

---

## Section 3: SplitOn Deep Dive

### Multiple Split Points

When mapping three or more types, specify multiple split columns:

```csharp
public class Order
{
    public int OrderId { get; set; }
    public Customer Customer { get; set; }
    public Address ShippingAddress { get; set; }
}

var sql = @"
    SELECT o.*, c.*, a.*
    FROM Orders o
    INNER JOIN Customers c ON c.CustomerId = o.CustomerId
    INNER JOIN Addresses a ON a.AddressId = o.ShippingAddressId
    WHERE o.OrderId = @orderId";

var order = connection.Query<Order, Customer, Address, Order>(
    sql,
    (order, customer, address) =>
    {
        order.Customer = customer;
        order.ShippingAddress = address;
        return order;
    },
    new { orderId = 1 },
    splitOn: "CustomerId,AddressId"  // Two split points!
).FirstOrDefault();
```

### Column Aliasing for Clarity

When tables have same-named columns, use aliases:

```csharp
var sql = @"
    SELECT 
        o.OrderId, o.Total, o.OrderDate,
        c.CustomerId AS CustomerId, c.Name AS CustomerName, c.Email,
        a.AddressId AS AddressId, a.Street, a.City
    FROM Orders o
    INNER JOIN Customers c ON c.CustomerId = o.CustomerId
    INNER JOIN Addresses a ON a.AddressId = o.ShippingAddressId";

// splitOn matches the aliased column names
var orders = connection.Query<Order, Customer, Address, Order>(
    sql,
    (order, customer, address) => { /* ... */ },
    splitOn: "CustomerId,AddressId"
);
```

<ProgressCheckpoint section="three-plus-types" xpReward={10} />

---

## Section 4: Three or More Types

### Complex Order with Customer and Items

```csharp
public class Order
{
    public int OrderId { get; set; }
    public DateTime OrderDate { get; set; }
    public Customer Customer { get; set; }
    public List<OrderItem> Items { get; set; } = new();
}

public class OrderItem
{
    public int OrderItemId { get; set; }
    public string ProductName { get; set; }
    public int Quantity { get; set; }
    public decimal Price { get; set; }
}

public async Task<Order?> GetOrderWithDetailsAsync(int orderId)
{
    var sql = @"
        SELECT o.*, c.*, oi.*
        FROM Orders o
        INNER JOIN Customers c ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderItems oi ON oi.OrderId = o.OrderId
        WHERE o.OrderId = @orderId";

    Order? result = null;

    await using var connection = new SqlConnection(_connectionString);
    await connection.QueryAsync<Order, Customer, OrderItem, Order>(
        sql,
        (order, customer, item) =>
        {
            if (result == null)
            {
                result = order;
                result.Customer = customer;
            }

            if (item != null)
            {
                result.Items.Add(item);
            }

            return result;
        },
        new { orderId },
        splitOn: "CustomerId,OrderItemId"
    );

    return result;
}
```

<ProgressCheckpoint section="real-world-examples" xpReward={10} />

---

## Section 5: Real-World Examples

### Blog Posts with Authors and Tags

```csharp
public class Post
{
    public int PostId { get; set; }
    public string Title { get; set; }
    public string Content { get; set; }
    public Author Author { get; set; }
    public List<Tag> Tags { get; set; } = new();
}

public async Task<List<Post>> GetPostsWithDetailsAsync()
{
    var sql = @"
        SELECT p.*, a.*, t.*
        FROM Posts p
        INNER JOIN Authors a ON a.AuthorId = p.AuthorId
        LEFT JOIN PostTags pt ON pt.PostId = p.PostId
        LEFT JOIN Tags t ON t.TagId = pt.TagId
        ORDER BY p.PostId";

    var postDict = new Dictionary<int, Post>();

    await using var connection = new SqlConnection(_connectionString);
    await connection.QueryAsync<Post, Author, Tag, Post>(
        sql,
        (post, author, tag) =>
        {
            if (!postDict.TryGetValue(post.PostId, out var existing))
            {
                existing = post;
                existing.Author = author;
                postDict.Add(post.PostId, existing);
            }

            if (tag != null && !existing.Tags.Any(t => t.TagId == tag.TagId))
            {
                existing.Tags.Add(tag);
            }

            return existing;
        },
        splitOn: "AuthorId,TagId"
    );

    return postDict.Values.ToList();
}
```

### Using QueryMultiple as Alternative

Sometimes separate queries are cleaner:

```csharp
public async Task<Customer?> GetCustomerWithOrdersMultipleAsync(int customerId)
{
    var sql = @"
        SELECT * FROM Customers WHERE CustomerId = @customerId;
        SELECT * FROM Orders WHERE CustomerId = @customerId ORDER BY OrderDate DESC;";

    await using var connection = new SqlConnection(_connectionString);
    await using var multi = await connection.QueryMultipleAsync(sql, new { customerId });

    var customer = await multi.ReadSingleOrDefaultAsync<Customer>();
    
    if (customer != null)
    {
        customer.Orders = (await multi.ReadAsync<Order>()).ToList();
    }

    return customer;
}
```

<ProgressCheckpoint section="performance-tips" xpReward={10} />

---

## Section 6: Performance Tips

### Tip 1: Select Only Needed Columns

```csharp
// ❌ Slow: SELECT *
var sql = "SELECT c.*, o.* FROM Customers c JOIN Orders o ...";

// ✅ Faster: Specific columns
var sql = @"
    SELECT c.CustomerId, c.Name, c.Email,
           o.OrderId, o.Total, o.OrderDate
    FROM Customers c
    JOIN Orders o ON o.CustomerId = c.CustomerId";
```

### Tip 2: Add Indexes on Join Columns

```sql
-- Ensure these indexes exist
CREATE INDEX IX_Orders_CustomerId ON Orders(CustomerId);
CREATE INDEX IX_OrderItems_OrderId ON OrderItems(OrderId);
```

### Tip 3: Paginate Large Results

```csharp
public async Task<List<Customer>> GetCustomersPagedAsync(int page, int pageSize)
{
    var offset = (page - 1) * pageSize;
    
    var sql = @"
        SELECT c.*, o.*
        FROM (
            SELECT * FROM Customers
            ORDER BY CustomerId
            OFFSET @offset ROWS FETCH NEXT @pageSize ROWS ONLY
        ) c
        LEFT JOIN Orders o ON o.CustomerId = c.CustomerId
        ORDER BY c.CustomerId";

    var customerDict = new Dictionary<int, Customer>();

    await using var connection = new SqlConnection(_connectionString);
    await connection.QueryAsync<Customer, Order, Customer>(
        sql,
        (customer, order) =>
        {
            if (!customerDict.TryGetValue(customer.CustomerId, out var existing))
            {
                existing = customer;
                customerDict.Add(customer.CustomerId, existing);
            }

            if (order != null) existing.Orders.Add(order);
            return existing;
        },
        new { offset, pageSize },
        splitOn: "OrderId"
    );

    return customerDict.Values.ToList();
}
```

### Tip 4: Consider QueryMultiple for Complex Hierarchies

| Approach | Best For |
|----------|----------|
| Multi-mapping JOIN | Simple 1:1 or small 1:N |
| QueryMultiple | Complex hierarchies, large datasets |
| Separate queries | When you need conditional loading |

<InfoBox type="success" title="Intermediate Complete! ">
You've mastered:
- One-to-many mapping with dictionary deduplication
- Multiple split points for complex joins
- Three-type mapping patterns
- QueryMultiple as an alternative
- Performance optimization strategies

Ready for advanced patterns like multi-level hierarchies and repository integration!
</InfoBox>
