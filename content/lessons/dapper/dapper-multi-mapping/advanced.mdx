# Multi-Mapping - Advanced

Master enterprise-grade multi-mapping patterns including multi-level hierarchies, generic helpers, performance optimization, and architectural best practices.

<InfoBox type="tip" title="Expert Level">
This lesson covers complex hierarchies, reusable extension methods, caching strategies, and production-ready repository patterns.
</InfoBox>

<ProgressCheckpoint section="introduction-multi-mapping" xpReward={14} />

## Section 1: Advanced Multi-Mapping Architecture

### Understanding the Data Flow

```
SQL Result (Flat Rows)
    ↓
Dapper Multi-Map Function
    ↓
Dictionary Deduplication
    ↓
Object Graph (Hierarchical)
```

### Memory-Efficient Streaming

For very large datasets, consider streaming:

```csharp
public async IAsyncEnumerable<Customer> StreamCustomersWithOrdersAsync(
    [EnumeratorCancellation] CancellationToken ct = default)
{
    var sql = @"
        SELECT c.*, o.*
        FROM Customers c
        LEFT JOIN Orders o ON o.CustomerId = c.CustomerId
        ORDER BY c.CustomerId, o.OrderId";

    await using var connection = new SqlConnection(_connectionString);
    await connection.OpenAsync(ct);

    Customer? currentCustomer = null;

    await foreach (var row in connection.Query<Customer, Order, (Customer, Order)>(
        sql,
        (c, o) => (c, o),
        splitOn: "OrderId",
        buffered: false
    ).ToAsyncEnumerable().WithCancellation(ct))
    {
        if (currentCustomer == null || currentCustomer.CustomerId != row.Item1.CustomerId)
        {
            if (currentCustomer != null)
            {
                yield return currentCustomer;
            }
            currentCustomer = row.Item1;
        }

        if (row.Item2 != null)
        {
            currentCustomer.Orders.Add(row.Item2);
        }
    }

    if (currentCustomer != null)
    {
        yield return currentCustomer;
    }
}
```

<ProgressCheckpoint section="two-type-mapping" xpReward={14} />

---

## Section 2: Generic Multi-Mapping Extensions

### Reusable One-to-Many Helper

```csharp
public static class DapperMultiMapExtensions
{
    public static async Task<IEnumerable<TParent>> QueryParentChildAsync<TParent, TChild, TKey>(
        this IDbConnection connection,
        string sql,
        Func<TParent, TKey> parentKeySelector,
        Action<TParent, TChild> addChild,
        object? param = null,
        string splitOn = "Id",
        IDbTransaction? transaction = null)
        where TKey : notnull
    {
        var lookup = new Dictionary<TKey, TParent>();

        await connection.QueryAsync<TParent, TChild, TParent>(
            sql,
            (parent, child) =>
            {
                var key = parentKeySelector(parent);

                if (!lookup.TryGetValue(key, out var existingParent))
                {
                    existingParent = parent;
                    lookup.Add(key, existingParent);
                }

                if (child != null)
                {
                    addChild(existingParent, child);
                }

                return existingParent;
            },
            param,
            transaction,
            splitOn: splitOn
        );

        return lookup.Values;
    }
}

// Usage - much cleaner!
var customers = await connection.QueryParentChildAsync<Customer, Order, int>(
    sql,
    c => c.CustomerId,
    (c, o) => c.Orders.Add(o),
    new { minOrderTotal = 100 },
    splitOn: "OrderId"
);
```

### Three-Level Hierarchy Helper

```csharp
public static async Task<IEnumerable<TGrandparent>> QueryThreeLevelAsync<TGrandparent, TParent, TChild, TGrandparentKey, TParentKey>(
    this IDbConnection connection,
    string sql,
    Func<TGrandparent, TGrandparentKey> grandparentKeySelector,
    Func<TParent, TParentKey> parentKeySelector,
    Func<TParent, TGrandparentKey> parentToGrandparentKey,
    Action<TGrandparent, TParent> addParent,
    Action<TParent, TChild> addChild,
    object? param = null,
    string splitOn = "Id,Id")
    where TGrandparentKey : notnull
    where TParentKey : notnull
{
    var grandparentLookup = new Dictionary<TGrandparentKey, TGrandparent>();
    var parentLookup = new Dictionary<TParentKey, TParent>();

    await connection.QueryAsync<TGrandparent, TParent, TChild, TGrandparent>(
        sql,
        (grandparent, parent, child) =>
        {
            var gpKey = grandparentKeySelector(grandparent);

            if (!grandparentLookup.TryGetValue(gpKey, out var existingGp))
            {
                existingGp = grandparent;
                grandparentLookup.Add(gpKey, existingGp);
            }

            if (parent != null)
            {
                var pKey = parentKeySelector(parent);

                if (!parentLookup.TryGetValue(pKey, out var existingParent))
                {
                    existingParent = parent;
                    parentLookup.Add(pKey, existingParent);
                    addParent(existingGp, existingParent);
                }

                if (child != null)
                {
                    addChild(existingParent, child);
                }
            }

            return existingGp;
        },
        param,
        splitOn: splitOn
    );

    return grandparentLookup.Values;
}
```

<ProgressCheckpoint section="spliton-parameter" xpReward={14} />

---

## Section 3: Advanced SplitOn Strategies

### Dynamic SplitOn Resolution

```csharp
public class MultiMapConfig<T>
{
    public string SplitColumn { get; set; } = "Id";
    public Func<T, bool> IsValid { get; set; } = _ => true;
}

public async Task<List<Order>> GetOrdersWithDynamicMappingAsync(
    MultiMapConfig<Customer> customerConfig,
    MultiMapConfig<Address> addressConfig)
{
    var sql = @"
        SELECT o.*, c.*, a.*
        FROM Orders o
        INNER JOIN Customers c ON c.CustomerId = o.CustomerId
        LEFT JOIN Addresses a ON a.AddressId = o.ShippingAddressId";

    var splitOn = $"{customerConfig.SplitColumn},{addressConfig.SplitColumn}";

    await using var connection = new SqlConnection(_connectionString);
    return (await connection.QueryAsync<Order, Customer, Address, Order>(
        sql,
        (order, customer, address) =>
        {
            if (customerConfig.IsValid(customer))
                order.Customer = customer;
            if (address != null && addressConfig.IsValid(address))
                order.ShippingAddress = address;
            return order;
        },
        splitOn: splitOn
    )).ToList();
}
```

### Handling Ambiguous Column Names

```csharp
// When both tables have 'Id', 'Name', etc.
var sql = @"
    SELECT 
        o.Id AS OrderId,
        o.Total,
        o.OrderDate,
        -- Customer columns with prefix
        c.Id AS Customer_Id,
        c.Name AS Customer_Name,
        c.Email AS Customer_Email,
        -- Address columns with prefix
        a.Id AS Address_Id,
        a.Street AS Address_Street,
        a.City AS Address_City
    FROM Orders o
    INNER JOIN Customers c ON c.Id = o.CustomerId
    LEFT JOIN Addresses a ON a.Id = o.AddressId";

// Custom type with column mapping
public class CustomerDto
{
    [Column("Customer_Id")]
    public int Id { get; set; }
    [Column("Customer_Name")]
    public string Name { get; set; }
    [Column("Customer_Email")]
    public string Email { get; set; }
}

// Use splitOn with the aliased names
var orders = connection.Query<Order, CustomerDto, AddressDto, Order>(
    sql,
    (order, customer, address) => { /* ... */ },
    splitOn: "Customer_Id,Address_Id"
);
```

<ProgressCheckpoint section="three-plus-types" xpReward={14} />

---

## Section 4: Complex Multi-Level Hierarchies

### Four-Level Deep: Company → Department → Employee → Project

```csharp
public class Company
{
    public int CompanyId { get; set; }
    public string Name { get; set; }
    public List<Department> Departments { get; set; } = new();
}

public class Department
{
    public int DepartmentId { get; set; }
    public string Name { get; set; }
    public List<Employee> Employees { get; set; } = new();
}

public class Employee
{
    public int EmployeeId { get; set; }
    public string Name { get; set; }
    public List<Project> Projects { get; set; } = new();
}

public class Project
{
    public int ProjectId { get; set; }
    public string Name { get; set; }
}

public async Task<Company?> GetCompanyHierarchyAsync(int companyId)
{
    var sql = @"
        SELECT c.*, d.*, e.*, p.*
        FROM Companies c
        LEFT JOIN Departments d ON d.CompanyId = c.CompanyId
        LEFT JOIN Employees e ON e.DepartmentId = d.DepartmentId
        LEFT JOIN EmployeeProjects ep ON ep.EmployeeId = e.EmployeeId
        LEFT JOIN Projects p ON p.ProjectId = ep.ProjectId
        WHERE c.CompanyId = @companyId
        ORDER BY d.DepartmentId, e.EmployeeId";

    var companyLookup = new Dictionary<int, Company>();
    var deptLookup = new Dictionary<int, Department>();
    var empLookup = new Dictionary<int, Employee>();
    var projectsAdded = new HashSet<(int, int)>(); // (EmployeeId, ProjectId)

    await using var connection = new SqlConnection(_connectionString);
    await connection.QueryAsync<Company, Department, Employee, Project, Company>(
        sql,
        (company, dept, emp, project) =>
        {
            if (!companyLookup.TryGetValue(company.CompanyId, out var existingCompany))
            {
                existingCompany = company;
                companyLookup.Add(company.CompanyId, existingCompany);
            }

            if (dept != null)
            {
                if (!deptLookup.TryGetValue(dept.DepartmentId, out var existingDept))
                {
                    existingDept = dept;
                    deptLookup.Add(dept.DepartmentId, existingDept);
                    existingCompany.Departments.Add(existingDept);
                }

                if (emp != null)
                {
                    if (!empLookup.TryGetValue(emp.EmployeeId, out var existingEmp))
                    {
                        existingEmp = emp;
                        empLookup.Add(emp.EmployeeId, existingEmp);
                        existingDept.Employees.Add(existingEmp);
                    }

                    if (project != null)
                    {
                        var key = (emp.EmployeeId, project.ProjectId);
                        if (!projectsAdded.Contains(key))
                        {
                            existingEmp.Projects.Add(project);
                            projectsAdded.Add(key);
                        }
                    }
                }
            }

            return existingCompany;
        },
        new { companyId },
        splitOn: "DepartmentId,EmployeeId,ProjectId"
    );

    return companyLookup.Values.FirstOrDefault();
}
```

<ProgressCheckpoint section="real-world-examples" xpReward={14} />

---

## Section 5: Production Patterns

### Repository with Caching

```csharp
public class CachedCustomerRepository : ICustomerRepository
{
    private readonly IDbConnectionFactory _connectionFactory;
    private readonly IMemoryCache _cache;
    private readonly TimeSpan _cacheDuration = TimeSpan.FromMinutes(5);

    public async Task<Customer?> GetWithOrdersAsync(int customerId)
    {
        var cacheKey = $"customer:{customerId}:with-orders";

        if (_cache.TryGetValue(cacheKey, out Customer? cached))
        {
            return cached;
        }

        await using var connection = _connectionFactory.CreateConnection();
        
        var sql = @"
            SELECT c.*, o.*
            FROM Customers c
            LEFT JOIN Orders o ON o.CustomerId = c.CustomerId
            WHERE c.CustomerId = @customerId";

        var customerDict = new Dictionary<int, Customer>();

        await connection.QueryAsync<Customer, Order, Customer>(
            sql,
            (customer, order) =>
            {
                if (!customerDict.TryGetValue(customer.CustomerId, out var existing))
                {
                    existing = customer;
                    customerDict.Add(customer.CustomerId, existing);
                }
                if (order != null) existing.Orders.Add(order);
                return existing;
            },
            new { customerId },
            splitOn: "OrderId"
        );

        var result = customerDict.Values.FirstOrDefault();
        
        if (result != null)
        {
            _cache.Set(cacheKey, result, _cacheDuration);
        }

        return result;
    }
}
```

### Specification Pattern for Dynamic Queries

```csharp
public interface ISpecification<T>
{
    string ToSql();
    object GetParameters();
}

public class CustomerWithOrdersSpecification : ISpecification<Customer>
{
    public int? MinOrderCount { get; set; }
    public decimal? MinTotalSpent { get; set; }
    public DateTime? OrdersSince { get; set; }

    public string ToSql()
    {
        var sql = new StringBuilder(@"
            SELECT c.*, o.*
            FROM Customers c
            LEFT JOIN Orders o ON o.CustomerId = c.CustomerId
            WHERE 1=1");

        if (MinOrderCount.HasValue)
            sql.Append(" AND c.CustomerId IN (SELECT CustomerId FROM Orders GROUP BY CustomerId HAVING COUNT(*) >= @MinOrderCount)");
        
        if (MinTotalSpent.HasValue)
            sql.Append(" AND c.CustomerId IN (SELECT CustomerId FROM Orders GROUP BY CustomerId HAVING SUM(Total) >= @MinTotalSpent)");
        
        if (OrdersSince.HasValue)
            sql.Append(" AND o.OrderDate >= @OrdersSince");

        sql.Append(" ORDER BY c.CustomerId, o.OrderDate DESC");
        
        return sql.ToString();
    }

    public object GetParameters() => new
    {
        MinOrderCount,
        MinTotalSpent,
        OrdersSince
    };
}
```

<ProgressCheckpoint section="performance-tips" xpReward={15} />

---

## Section 6: Performance Optimization

### Benchmark Comparison

| Approach | 10K Customers + 50K Orders | Memory | Time |
|----------|---------------------------|--------|------|
| N+1 Queries | 10,001 DB calls | 200 MB | ~8000 ms |
| Multi-Map JOIN | 1 DB call | 150 MB | ~400 ms |
| QueryMultiple | 2 DB calls | 100 MB | ~350 ms |
| Paginated (100/page) | 1 DB call | 15 MB | ~50 ms |

### Optimized Pagination

```csharp
public async Task<PagedResult<Customer>> GetCustomersPagedAsync(
    int page, 
    int pageSize,
    CancellationToken ct = default)
{
    var offset = (page - 1) * pageSize;

    var sql = @"
        -- Get total count
        SELECT COUNT(DISTINCT CustomerId) FROM Customers;
        
        -- Get paginated customers with orders
        WITH PagedCustomers AS (
            SELECT CustomerId, Name, Email,
                   ROW_NUMBER() OVER (ORDER BY CustomerId) AS RowNum
            FROM Customers
        )
        SELECT pc.CustomerId, pc.Name, pc.Email, o.*
        FROM PagedCustomers pc
        LEFT JOIN Orders o ON o.CustomerId = pc.CustomerId
        WHERE pc.RowNum BETWEEN @offset + 1 AND @offset + @pageSize
        ORDER BY pc.CustomerId, o.OrderDate DESC";

    await using var connection = new SqlConnection(_connectionString);
    await using var multi = await connection.QueryMultipleAsync(
        sql, 
        new { offset, pageSize }
    );

    var totalCount = await multi.ReadSingleAsync<int>();
    
    var customerDict = new Dictionary<int, Customer>();
    await multi.ReadAsync<Customer, Order, Customer>(
        (customer, order) =>
        {
            if (!customerDict.TryGetValue(customer.CustomerId, out var existing))
            {
                existing = customer;
                customerDict.Add(customer.CustomerId, existing);
            }
            if (order != null) existing.Orders.Add(order);
            return existing;
        },
        splitOn: "OrderId"
    );

    return new PagedResult<Customer>
    {
        Items = customerDict.Values.ToList(),
        TotalCount = totalCount,
        Page = page,
        PageSize = pageSize,
        TotalPages = (int)Math.Ceiling(totalCount / (double)pageSize)
    };
}
```

### Connection and Query Optimization

```csharp
public class OptimizedRepository
{
    private readonly string _connectionString;

    // Use CommandDefinition for fine-grained control
    public async Task<List<Customer>> GetCustomersOptimizedAsync(
        CancellationToken ct = default)
    {
        var sql = @"
            SELECT c.CustomerId, c.Name, c.Email,
                   o.OrderId, o.Total, o.OrderDate
            FROM Customers c
            LEFT JOIN Orders o ON o.CustomerId = c.CustomerId
            ORDER BY c.CustomerId";

        var command = new CommandDefinition(
            sql,
            cancellationToken: ct,
            commandTimeout: 30,
            flags: CommandFlags.Buffered
        );

        await using var connection = new SqlConnection(_connectionString);
        
        var customerDict = new Dictionary<int, Customer>();

        await connection.QueryAsync<Customer, Order, Customer>(
            command.CommandText,
            (customer, order) =>
            {
                if (!customerDict.TryGetValue(customer.CustomerId, out var existing))
                {
                    existing = customer;
                    customerDict.Add(customer.CustomerId, existing);
                }
                if (order != null) existing.Orders.Add(order);
                return existing;
            },
            splitOn: "OrderId"
        );

        return customerDict.Values.ToList();
    }
}
```

<InfoBox type="success" title="Advanced Mastery Complete! ">
You've conquered:
- Generic multi-mapping extension methods
- Four-level deep hierarchies
- Caching and specification patterns
- Performance optimization strategies
- Production-ready repository patterns

You're now equipped to handle any multi-mapping scenario in enterprise applications!
</InfoBox>
