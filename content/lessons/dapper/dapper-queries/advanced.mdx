# Queries & Commands - Advanced

Master complex query scenarios, performance optimization, and enterprise patterns with Dapper.

<InfoBox type="tip" title="Expert Level">
This lesson covers multiple result sets, table-valued parameters, query optimization, and advanced async patterns.
</InfoBox>

<ProgressCheckpoint section="query-methods" xpReward={13} />

## Section 1: Advanced Query Methods

### Multiple Result Sets (GridReader)

Execute multiple queries in a single round trip:

```csharp
public async Task<DashboardData> GetDashboardAsync(int userId)
{
    var sql = @"
        SELECT * FROM Users WHERE Id = @userId;
        SELECT * FROM Orders WHERE UserId = @userId ORDER BY OrderDate DESC;
        SELECT COUNT(*) FROM Orders WHERE UserId = @userId;
        SELECT SUM(Total) FROM Orders WHERE UserId = @userId;";

    await using var connection = new SqlConnection(_connectionString);
    await using var multi = await connection.QueryMultipleAsync(sql, new { userId });

    return new DashboardData
    {
        User = await multi.ReadSingleAsync<User>(),
        RecentOrders = (await multi.ReadAsync<Order>()).ToList(),
        TotalOrders = await multi.ReadSingleAsync<int>(),
        TotalSpent = await multi.ReadSingleOrDefaultAsync<decimal?>() ?? 0
    };
}
```

### Streaming Large Results

```csharp
// Process millions of rows without loading all into memory
public async IAsyncEnumerable<Product> StreamProductsAsync(
    [EnumeratorCancellation] CancellationToken ct = default)
{
    await using var connection = new SqlConnection(_connectionString);
    await connection.OpenAsync(ct);

    // Use unbuffered query
    var products = connection.Query<Product>(
        "SELECT * FROM Products",
        buffered: false
    );

    foreach (var product in products)
    {
        ct.ThrowIfCancellationRequested();
        yield return product;
    }
}

// Usage
await foreach (var product in StreamProductsAsync())
{
    await ProcessProductAsync(product);
}
```

### Dynamic Column Selection

```csharp
public async Task<IEnumerable<dynamic>> QueryDynamicAsync(
    string tableName,
    IEnumerable<string> columns,
    IDictionary<string, object> filters)
{
    // Validate table name against whitelist
    if (!_allowedTables.Contains(tableName))
        throw new ArgumentException("Invalid table name");

    // Validate column names
    var validColumns = columns.Where(c => _columnWhitelist[tableName].Contains(c));
    var columnList = string.Join(", ", validColumns.Select(c => $"[{c}]"));

    var parameters = new DynamicParameters();
    var whereClauses = new List<string>();

    foreach (var (key, value) in filters)
    {
        if (_columnWhitelist[tableName].Contains(key))
        {
            whereClauses.Add($"[{key}] = @{key}");
            parameters.Add($"@{key}", value);
        }
    }

    var whereClause = whereClauses.Any() 
        ? $"WHERE {string.Join(" AND ", whereClauses)}" 
        : "";

    var sql = $"SELECT {columnList} FROM [{tableName}] {whereClause}";

    await using var connection = new SqlConnection(_connectionString);
    return await connection.QueryAsync(sql, parameters);
}
```

<ProgressCheckpoint section="query-single" xpReward={13} />

---

## Section 2: Advanced Single Queries

### Composite Key Lookups

```csharp
public async Task<OrderItem?> GetOrderItemAsync(int orderId, int productId)
{
    await using var connection = new SqlConnection(_connectionString);
    return await connection.QuerySingleOrDefaultAsync<OrderItem>(
        @"SELECT * FROM OrderItems 
          WHERE OrderId = @orderId AND ProductId = @productId",
        new { orderId, productId }
    );
}
```

### Conditional Includes

```csharp
public async Task<Product> GetProductWithDetailsAsync(
    int id, 
    bool includeCategory = false,
    bool includeReviews = false)
{
    var sql = new StringBuilder("SELECT * FROM Products WHERE Id = @id;");
    
    if (includeCategory)
        sql.Append("SELECT * FROM Categories WHERE Id = (SELECT CategoryId FROM Products WHERE Id = @id);");
    
    if (includeReviews)
        sql.Append("SELECT * FROM Reviews WHERE ProductId = @id;");

    await using var connection = new SqlConnection(_connectionString);
    await using var multi = await connection.QueryMultipleAsync(sql.ToString(), new { id });

    var product = await multi.ReadSingleAsync<Product>();
    
    if (includeCategory)
        product.Category = await multi.ReadSingleOrDefaultAsync<Category>();
    
    if (includeReviews)
        product.Reviews = (await multi.ReadAsync<Review>()).ToList();

    return product;
}
```

<ProgressCheckpoint section="execute-commands" xpReward={13} />

---

## Section 3: Advanced Execute Commands

### Upsert Pattern (MERGE)

```csharp
public async Task<int> UpsertProductAsync(Product product)
{
    var sql = @"
        MERGE INTO Products AS target
        USING (SELECT @Id AS Id) AS source
        ON target.Id = source.Id
        WHEN MATCHED THEN
            UPDATE SET 
                Name = @Name, 
                Price = @Price,
                ModifiedDate = GETUTCDATE()
        WHEN NOT MATCHED THEN
            INSERT (Name, Price, CreatedDate)
            VALUES (@Name, @Price, GETUTCDATE())
        OUTPUT INSERTED.Id;";

    await using var connection = new SqlConnection(_connectionString);
    return await connection.ExecuteScalarAsync<int>(sql, product);
}
```

### Soft Delete with Audit

```csharp
public async Task<bool> SoftDeleteAsync(int id, string deletedBy)
{
    var sql = @"
        UPDATE Products 
        SET IsDeleted = 1, 
            DeletedDate = GETUTCDATE(),
            DeletedBy = @deletedBy
        WHERE Id = @id AND IsDeleted = 0;
        
        INSERT INTO AuditLog (EntityType, EntityId, Action, PerformedBy, PerformedAt)
        VALUES ('Product', @id, 'Delete', @deletedBy, GETUTCDATE());";

    await using var connection = new SqlConnection(_connectionString);
    var rowsAffected = await connection.ExecuteAsync(sql, new { id, deletedBy });
    return rowsAffected > 0;
}
```

### Batch with Individual Results

```csharp
public async Task<BatchResult> ProcessBatchAsync(IEnumerable<Product> products)
{
    var result = new BatchResult();
    
    await using var connection = new SqlConnection(_connectionString);
    await connection.OpenAsync();
    await using var transaction = await connection.BeginTransactionAsync();

    try
    {
        foreach (var product in products)
        {
            try
            {
                await connection.ExecuteAsync(
                    "INSERT INTO Products (Name, Price) VALUES (@Name, @Price)",
                    product,
                    transaction
                );
                result.Succeeded.Add(product);
            }
            catch (Exception ex)
            {
                result.Failed.Add((product, ex.Message));
            }
        }

        await transaction.CommitAsync();
    }
    catch
    {
        await transaction.RollbackAsync();
        throw;
    }

    return result;
}
```

<ProgressCheckpoint section="bulk-operations" xpReward={13} />

---

## Section 4: Advanced Bulk Operations

### Table-Valued Parameters (SQL Server)

```csharp
// First, create the table type in SQL Server:
// CREATE TYPE dbo.ProductTableType AS TABLE (Name NVARCHAR(100), Price DECIMAL(18,2))

public async Task BulkInsertWithTVPAsync(IEnumerable<Product> products)
{
    var table = new DataTable();
    table.Columns.Add("Name", typeof(string));
    table.Columns.Add("Price", typeof(decimal));

    foreach (var product in products)
    {
        table.Rows.Add(product.Name, product.Price);
    }

    var parameters = new DynamicParameters();
    parameters.Add("@Products", table.AsTableValuedParameter("dbo.ProductTableType"));

    await using var connection = new SqlConnection(_connectionString);
    await connection.ExecuteAsync(
        @"INSERT INTO Products (Name, Price)
          SELECT Name, Price FROM @Products",
        parameters
    );
}
```

### Bulk Copy for Large Datasets

```csharp
public async Task BulkCopyAsync(IEnumerable<Product> products)
{
    var table = new DataTable();
    table.Columns.Add("Name", typeof(string));
    table.Columns.Add("Price", typeof(decimal));
    table.Columns.Add("CreatedDate", typeof(DateTime));

    foreach (var product in products)
    {
        table.Rows.Add(product.Name, product.Price, DateTime.UtcNow);
    }

    await using var connection = new SqlConnection(_connectionString);
    await connection.OpenAsync();

    using var bulkCopy = new SqlBulkCopy(connection)
    {
        DestinationTableName = "Products",
        BatchSize = 10000
    };

    bulkCopy.ColumnMappings.Add("Name", "Name");
    bulkCopy.ColumnMappings.Add("Price", "Price");
    bulkCopy.ColumnMappings.Add("CreatedDate", "CreatedDate");

    await bulkCopy.WriteToServerAsync(table);
}
```

<ProgressCheckpoint section="stored-procedures" xpReward={13} />

---

## Section 5: Advanced Stored Procedures

### Complex Output Handling

```csharp
public async Task<OrderResult> CreateOrderAsync(Order order)
{
    var parameters = new DynamicParameters();
    parameters.Add("@CustomerId", order.CustomerId);
    parameters.Add("@Items", CreateOrderItemsTable(order.Items)
        .AsTableValuedParameter("dbo.OrderItemType"));
    parameters.Add("@OrderId", dbType: DbType.Int32, direction: ParameterDirection.Output);
    parameters.Add("@OrderTotal", dbType: DbType.Decimal, direction: ParameterDirection.Output);
    parameters.Add("@ReturnValue", dbType: DbType.Int32, direction: ParameterDirection.ReturnValue);

    await using var connection = new SqlConnection(_connectionString);
    await connection.ExecuteAsync(
        "CreateOrder",
        parameters,
        commandType: CommandType.StoredProcedure
    );

    var returnValue = parameters.Get<int>("@ReturnValue");
    
    return new OrderResult
    {
        Success = returnValue == 0,
        OrderId = parameters.Get<int>("@OrderId"),
        Total = parameters.Get<decimal>("@OrderTotal"),
        ErrorCode = returnValue
    };
}
```

### Multiple Result Sets from Stored Procedure

```csharp
public async Task<ReportData> GetReportAsync(DateTime startDate, DateTime endDate)
{
    await using var connection = new SqlConnection(_connectionString);
    await using var multi = await connection.QueryMultipleAsync(
        "GenerateReport",
        new { startDate, endDate },
        commandType: CommandType.StoredProcedure
    );

    return new ReportData
    {
        Summary = await multi.ReadSingleAsync<ReportSummary>(),
        DailyBreakdown = (await multi.ReadAsync<DailyStats>()).ToList(),
        TopProducts = (await multi.ReadAsync<ProductStats>()).ToList(),
        TopCustomers = (await multi.ReadAsync<CustomerStats>()).ToList()
    };
}
```

<ProgressCheckpoint section="async-methods" xpReward={15} />

---

## Section 6: Advanced Async Patterns

### Parallel Queries with Semaphore

```csharp
public async Task<IEnumerable<Product>> GetProductsParallelAsync(IEnumerable<int> categoryIds)
{
    var semaphore = new SemaphoreSlim(10); // Max 10 concurrent connections
    var tasks = categoryIds.Select(async categoryId =>
    {
        await semaphore.WaitAsync();
        try
        {
            await using var connection = new SqlConnection(_connectionString);
            return await connection.QueryAsync<Product>(
                "SELECT * FROM Products WHERE CategoryId = @categoryId",
                new { categoryId }
            );
        }
        finally
        {
            semaphore.Release();
        }
    });

    var results = await Task.WhenAll(tasks);
    return results.SelectMany(r => r);
}
```

### Cancellation-Aware Operations

```csharp
public async Task<IEnumerable<Product>> SearchWithTimeoutAsync(
    string term,
    TimeSpan timeout)
{
    using var cts = new CancellationTokenSource(timeout);
    
    try
    {
        var command = new CommandDefinition(
            "SELECT * FROM Products WHERE Name LIKE @term",
            new { term = $"%{term}%" },
            cancellationToken: cts.Token,
            commandTimeout: (int)timeout.TotalSeconds
        );

        await using var connection = new SqlConnection(_connectionString);
        return await connection.QueryAsync<Product>(command);
    }
    catch (OperationCanceledException)
    {
        throw new TimeoutException($"Search timed out after {timeout.TotalSeconds}s");
    }
}
```

### Retry Pattern with Polly

```csharp
public class ResilientProductRepository
{
    private readonly AsyncRetryPolicy _retryPolicy;
    private readonly string _connectionString;

    public ResilientProductRepository(string connectionString)
    {
        _connectionString = connectionString;
        _retryPolicy = Policy
            .Handle<SqlException>(ex => IsTransient(ex))
            .WaitAndRetryAsync(
                3,
                retryAttempt => TimeSpan.FromMilliseconds(100 * Math.Pow(2, retryAttempt))
            );
    }

    public async Task<Product?> GetByIdAsync(int id)
    {
        return await _retryPolicy.ExecuteAsync(async () =>
        {
            await using var connection = new SqlConnection(_connectionString);
            return await connection.QuerySingleOrDefaultAsync<Product>(
                "SELECT * FROM Products WHERE Id = @id",
                new { id }
            );
        });
    }

    private static bool IsTransient(SqlException ex)
    {
        int[] transientErrors = { -2, 20, 64, 233, 10053, 10054, 10060 };
        return transientErrors.Contains(ex.Number);
    }
}
```

<InfoBox type="success" title="Advanced Mastery Complete! ">
You've mastered:
- Multiple result sets and streaming
- Table-valued parameters and bulk copy
- Complex stored procedure patterns
- Advanced async with cancellation and retry

You're now equipped to build enterprise-grade data access layers with Dapper!
</InfoBox>
