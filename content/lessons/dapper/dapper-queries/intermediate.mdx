# Queries & Commands - Intermediate

Master advanced querying techniques, efficient command execution, and production-ready patterns with Dapper.

<InfoBox type="tip" title="Level Up">
This lesson covers advanced parameter handling, efficient bulk operations, stored procedure patterns, and async best practices.
</InfoBox>

<ProgressCheckpoint section="query-methods" xpReward={9} />

## Section 1: Query Methods Deep Dive

### Choosing the Right Method

Understanding when to use each query method is crucial for writing robust code:

```csharp
// Query<T> - Returns IEnumerable<T>, never null
var products = connection.Query<Product>(
    "SELECT * FROM Products WHERE CategoryId = @categoryId",
    new { categoryId = 1 }
);
// Safe to iterate even if empty

// QueryFirst<T> - Throws if no results
try
{
    var first = connection.QueryFirst<Product>(
        "SELECT * FROM Products WHERE Id = @id",
        new { id = 999 }
    );
}
catch (InvalidOperationException)
{
    // No matching product found
}

// QueryFirstOrDefault<T> - Returns null/default if no results
var product = connection.QueryFirstOrDefault<Product>(
    "SELECT * FROM Products WHERE Id = @id",
    new { id = 999 }
);
// product is null if not found
```

### Projection Queries

Don't always map to full entitiesâ€”project to DTOs:

```csharp
// Project to anonymous type
var summaries = connection.Query(
    @"SELECT p.Name, p.Price, c.Name as CategoryName
      FROM Products p
      JOIN Categories c ON p.CategoryId = c.Id"
);

// Project to specific DTO
public record ProductSummaryDto(string Name, decimal Price, string CategoryName);

var summaries = connection.Query<ProductSummaryDto>(
    @"SELECT p.Name, p.Price, c.Name as CategoryName
      FROM Products p
      JOIN Categories c ON p.CategoryId = c.Id"
);
```

<ProgressCheckpoint section="query-single" xpReward={9} />

---

## Section 2: Query Single Patterns

### Safe Single Queries

```csharp
// Pattern: Get by ID with null check
public async Task<Product?> GetByIdAsync(int id)
{
    using var connection = new SqlConnection(_connectionString);
    return await connection.QuerySingleOrDefaultAsync<Product>(
        "SELECT * FROM Products WHERE Id = @id",
        new { id }
    );
}

// Pattern: Get required entity (throws if not found)
public async Task<Product> GetRequiredByIdAsync(int id)
{
    using var connection = new SqlConnection(_connectionString);
    var product = await connection.QuerySingleOrDefaultAsync<Product>(
        "SELECT * FROM Products WHERE Id = @id",
        new { id }
    );
    
    return product ?? throw new NotFoundException($"Product {id} not found");
}
```

### Scalar Queries with Type Safety

```csharp
// Count with proper typing
var count = connection.ExecuteScalar<int>(
    "SELECT COUNT(*) FROM Products WHERE CategoryId = @categoryId",
    new { categoryId = 1 }
);

// Nullable scalar (when result might be null)
var maxPrice = connection.ExecuteScalar<decimal?>(
    "SELECT MAX(Price) FROM Products WHERE CategoryId = @categoryId",
    new { categoryId = 999 }  // Category might not exist
);

if (maxPrice.HasValue)
{
    Console.WriteLine($"Max price: {maxPrice.Value}");
}

// Get inserted ID
var newId = connection.ExecuteScalar<int>(
    @"INSERT INTO Products (Name, Price) VALUES (@name, @price);
      SELECT SCOPE_IDENTITY();",
    new { name = "New Product", price = 99.99m }
);
```

<ProgressCheckpoint section="execute-commands" xpReward={9} />

---

## Section 3: Execute Commands

### INSERT with Identity Return

```csharp
// SQL Server - Get inserted ID
var sql = @"
    INSERT INTO Products (Name, Price, CategoryId) 
    VALUES (@Name, @Price, @CategoryId);
    SELECT CAST(SCOPE_IDENTITY() as int);";

var newId = connection.ExecuteScalar<int>(sql, new
{
    Name = "Gaming Keyboard",
    Price = 149.99m,
    CategoryId = 1
});

// PostgreSQL - Use RETURNING
var sql = @"
    INSERT INTO products (name, price, category_id) 
    VALUES (@Name, @Price, @CategoryId)
    RETURNING id;";
```

### UPDATE with Optimistic Concurrency

```csharp
public async Task<bool> UpdateProductAsync(Product product)
{
    using var connection = new SqlConnection(_connectionString);
    
    var rowsAffected = await connection.ExecuteAsync(
        @"UPDATE Products 
          SET Name = @Name, Price = @Price, Version = @Version + 1
          WHERE Id = @Id AND Version = @Version",
        product
    );
    
    if (rowsAffected == 0)
    {
        throw new ConcurrencyException("Product was modified by another user");
    }
    
    return true;
}
```

### Conditional Updates

```csharp
// Update only non-null fields
public async Task<int> PatchProductAsync(int id, ProductPatch patch)
{
    var updates = new List<string>();
    var parameters = new DynamicParameters();
    parameters.Add("@Id", id);
    
    if (patch.Name != null)
    {
        updates.Add("Name = @Name");
        parameters.Add("@Name", patch.Name);
    }
    
    if (patch.Price.HasValue)
    {
        updates.Add("Price = @Price");
        parameters.Add("@Price", patch.Price.Value);
    }
    
    if (updates.Count == 0) return 0;
    
    var sql = $"UPDATE Products SET {string.Join(", ", updates)} WHERE Id = @Id";
    
    using var connection = new SqlConnection(_connectionString);
    return await connection.ExecuteAsync(sql, parameters);
}
```

<ProgressCheckpoint section="bulk-operations" xpReward={9} />

---

## Section 4: Bulk Operations

### Efficient Batch Inserts

```csharp
// Dapper automatically batches when you pass a collection
var products = new List<Product>
{
    new() { Name = "Product 1", Price = 10.00m },
    new() { Name = "Product 2", Price = 20.00m },
    new() { Name = "Product 3", Price = 30.00m }
};

var sql = "INSERT INTO Products (Name, Price) VALUES (@Name, @Price)";
var rowsAffected = connection.Execute(sql, products);
// Executes 3 INSERT statements in one round trip
```

### Batch Updates

```csharp
// Update multiple products
var updates = new[]
{
    new { Id = 1, Price = 99.99m },
    new { Id = 2, Price = 149.99m },
    new { Id = 3, Price = 199.99m }
};

var rowsAffected = connection.Execute(
    "UPDATE Products SET Price = @Price WHERE Id = @Id",
    updates
);
```

### Transaction-Wrapped Bulk Operations

```csharp
public async Task ImportProductsAsync(IEnumerable<Product> products)
{
    using var connection = new SqlConnection(_connectionString);
    await connection.OpenAsync();
    
    using var transaction = connection.BeginTransaction();
    
    try
    {
        // Clear existing
        await connection.ExecuteAsync(
            "DELETE FROM Products WHERE IsImported = 1",
            transaction: transaction
        );
        
        // Insert new
        await connection.ExecuteAsync(
            @"INSERT INTO Products (Name, Price, IsImported) 
              VALUES (@Name, @Price, 1)",
            products,
            transaction
        );
        
        transaction.Commit();
    }
    catch
    {
        transaction.Rollback();
        throw;
    }
}
```

<ProgressCheckpoint section="stored-procedures" xpReward={9} />

---

## Section 5: Stored Procedures

### Basic Stored Procedure Calls

```csharp
// Query with stored procedure
var products = connection.Query<Product>(
    "GetProductsByCategory",
    new { CategoryId = 1 },
    commandType: CommandType.StoredProcedure
);

// Execute stored procedure
connection.Execute(
    "UpdateProductStock",
    new { ProductId = 1, Quantity = 10 },
    commandType: CommandType.StoredProcedure
);
```

### Output Parameters

```csharp
var parameters = new DynamicParameters();
parameters.Add("@CategoryId", 1);
parameters.Add("@TotalCount", dbType: DbType.Int32, direction: ParameterDirection.Output);
parameters.Add("@TotalValue", dbType: DbType.Decimal, direction: ParameterDirection.Output);

var products = connection.Query<Product>(
    "GetProductsWithStats",
    parameters,
    commandType: CommandType.StoredProcedure
).ToList();

var totalCount = parameters.Get<int>("@TotalCount");
var totalValue = parameters.Get<decimal>("@TotalValue");
```

### Return Values

```csharp
var parameters = new DynamicParameters();
parameters.Add("@ProductId", 1);
parameters.Add("@ReturnValue", dbType: DbType.Int32, direction: ParameterDirection.ReturnValue);

connection.Execute(
    "DeleteProduct",
    parameters,
    commandType: CommandType.StoredProcedure
);

var returnValue = parameters.Get<int>("@ReturnValue");
// 0 = success, -1 = not found, etc.
```

<ProgressCheckpoint section="async-methods" xpReward={10} />

---

## Section 6: Async Methods

### Async Best Practices

```csharp
public class ProductRepository
{
    private readonly string _connectionString;

    // Always create new connections for async operations
    public async Task<IEnumerable<Product>> GetAllAsync()
    {
        await using var connection = new SqlConnection(_connectionString);
        return await connection.QueryAsync<Product>("SELECT * FROM Products");
    }

    // Use ConfigureAwait(false) in library code
    public async Task<Product?> GetByIdAsync(int id)
    {
        await using var connection = new SqlConnection(_connectionString);
        return await connection.QuerySingleOrDefaultAsync<Product>(
            "SELECT * FROM Products WHERE Id = @id",
            new { id }
        ).ConfigureAwait(false);
    }

    // Async with cancellation support
    public async Task<IEnumerable<Product>> SearchAsync(
        string term, 
        CancellationToken ct = default)
    {
        await using var connection = new SqlConnection(_connectionString);
        
        var command = new CommandDefinition(
            "SELECT * FROM Products WHERE Name LIKE @term",
            new { term = $"%{term}%" },
            cancellationToken: ct
        );
        
        return await connection.QueryAsync<Product>(command);
    }
}
```

### Async Transactions

```csharp
public async Task TransferAsync(int fromId, int toId, decimal amount)
{
    await using var connection = new SqlConnection(_connectionString);
    await connection.OpenAsync();
    
    await using var transaction = await connection.BeginTransactionAsync();
    
    try
    {
        await connection.ExecuteAsync(
            "UPDATE Accounts SET Balance = Balance - @amount WHERE Id = @id",
            new { id = fromId, amount },
            transaction
        );
        
        await connection.ExecuteAsync(
            "UPDATE Accounts SET Balance = Balance + @amount WHERE Id = @id",
            new { id = toId, amount },
            transaction
        );
        
        await transaction.CommitAsync();
    }
    catch
    {
        await transaction.RollbackAsync();
        throw;
    }
}
```

<InfoBox type="success" title="Intermediate Complete! ">
You've mastered:
- Advanced query method selection
- Efficient command execution patterns
- Bulk operations with transactions
- Stored procedure integration
- Async best practices

Ready for advanced topics like multi-mapping and complex result sets!
</InfoBox>
