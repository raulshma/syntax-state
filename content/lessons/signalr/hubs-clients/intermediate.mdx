# Hubs & Clients: Advanced Communication Patterns

SignalR Hubs provide a high-level abstraction for bidirectional client-server communication. Understanding the Hub architecture and client proxy system is essential for building scalable real-time applications.

## Hub Architecture

A Hub is a class that inherits from `Microsoft.AspNetCore.SignalR.Hub` and serves as the communication endpoint for SignalR connections.

```csharp
using Microsoft.AspNetCore.SignalR;

public class ChatHub : Hub
{
    // Hub methods are publicly accessible to connected clients
    public async Task SendMessage(string user, string message)
    {
        await Clients.All.SendAsync("ReceiveMessage", user, message);
    }
    
    // Access connection context
    public string GetConnectionId()
    {
        return Context.ConnectionId;
    }
    
    // Access user information
    public string GetUserId()
    {
        return Context.UserIdentifier ?? "Anonymous";
    }
}
```

### Hub Context

Every hub method has access to `HubCallerContext` through the `Context` property:

| Property | Description | Use Case |
|:---------|:------------|:---------|
| `ConnectionId` | Unique connection identifier | Tracking specific connections |
| `UserIdentifier` | User ID from authentication | User-based messaging |
| `User` | ClaimsPrincipal for authenticated user | Authorization checks |
| `Items` | Key-value collection for connection state | Storing connection-specific data |
| `Features` | HTTP features collection | Accessing transport information |

<ProgressCheckpoint section="understanding-hubs" xpReward={15} />

## Client Communication Patterns

The `Clients` property provides various methods for targeting different sets of connections.

### 1. Broadcasting Methods

```csharp
public class NotificationHub : Hub
{
    // Send to all connected clients
    public async Task BroadcastToAll(string message)
    {
        await Clients.All.SendAsync("Notify", message);
    }
    
    // Send to all except specific connections
    public async Task BroadcastExcept(List<string> excludedConnections, string message)
    {
        await Clients.AllExcept(excludedConnections).SendAsync("Notify", message);
    }
    
    // Send to everyone except the caller
    public async Task BroadcastToOthers(string message)
    {
        await Clients.Others.SendAsync("Notify", message);
    }
}
```

### 2. Targeted Communication

```csharp
public class DirectMessageHub : Hub
{
    // Send to specific client
    public async Task SendToClient(string connectionId, string message)
    {
        await Clients.Client(connectionId).SendAsync("ReceiveMessage", message);
    }
    
    // Send to multiple specific clients
    public async Task SendToClients(List<string> connectionIds, string message)
    {
        await Clients.Clients(connectionIds).SendAsync("ReceiveMessage", message);
    }
    
    // Send to all connections for a specific user
    public async Task SendToUser(string userId, string message)
    {
        await Clients.User(userId).SendAsync("ReceiveMessage", message);
    }
    
    // Send to multiple users
    public async Task SendToUsers(List<string> userIds, string message)
    {
        await Clients.Users(userIds).SendAsync("ReceiveMessage", message);
    }
}
```

### 3. Caller-Specific Communication

```csharp
public class EchoHub : Hub
{
    // Send only to the calling client
    public async Task Echo(string message)
    {
        await Clients.Caller.SendAsync("Echo", $"You said: {message}");
    }
    
    // Acknowledge receipt
    public async Task ProcessCommand(string command)
    {
        // Process command
        var result = await ProcessAsync(command);
        
        // Send result back to caller
        await Clients.Caller.SendAsync("CommandResult", result);
        
        // Notify others about the action
        await Clients.Others.SendAsync("UserAction", 
            $"{Context.UserIdentifier} executed: {command}");
    }
}
```

<KeyConcept title="Client Proxy Methods">
All `Clients` methods return a client proxy with these key methods:

- **`SendAsync(methodName, ...args)`**: Invoke client method (fire-and-forget)
- **`SendCoreAsync(methodName, args, cancellationToken)`**: Low-level send with cancellation
- **`InvokeAsync<T>(methodName, ...args)`**: Call client and await result (requires client return value support)

The method name is case-sensitive and must match the client-side handler exactly.
</KeyConcept>

<ProgressCheckpoint section="client-communication" xpReward={20} />

## Connection Lifecycle Management

### Connection Events

```csharp
public class PresenceHub : Hub
{
    private readonly IConnectionStore _connectionStore;
    private readonly ILogger<PresenceHub> _logger;
    
    public PresenceHub(
        IConnectionStore connectionStore,
        ILogger<PresenceHub> logger)
    {
        _connectionStore = connectionStore;
        _logger = logger;
    }
    
    public override async Task OnConnectedAsync()
    {
        var userId = Context.UserIdentifier;
        var connectionId = Context.ConnectionId;
        
        _logger.LogInformation(
            "User {UserId} connected with connection {ConnectionId}", 
            userId, connectionId);
        
        // Store connection
        await _connectionStore.AddConnectionAsync(userId, connectionId);
        
        // Notify others
        await Clients.Others.SendAsync("UserConnected", userId);
        
        // Send current online users to new connection
        var onlineUsers = await _connectionStore.GetOnlineUsersAsync();
        await Clients.Caller.SendAsync("OnlineUsers", onlineUsers);
        
        await base.OnConnectedAsync();
    }
    
    public override async Task OnDisconnectedAsync(Exception? exception)
    {
        var userId = Context.UserIdentifier;
        var connectionId = Context.ConnectionId;
        
        if (exception != null)
        {
            _logger.LogError(exception, 
                "Connection {ConnectionId} disconnected with error", 
                connectionId);
        }
        
        // Remove connection
        await _connectionStore.RemoveConnectionAsync(userId, connectionId);
        
        // Check if user is fully disconnected
        var userStillOnline = await _connectionStore
            .HasActiveConnectionsAsync(userId);
        
        if (!userStillOnline)
        {
            // Notify others user went offline
            await Clients.Others.SendAsync("UserDisconnected", userId);
        }
        
        await base.OnDisconnectedAsync(exception);
    }
}
```

### Client-Side Connection Management

```typescript
class SignalRConnection {
    private connection: signalR.HubConnection;
    private reconnectAttempts = 0;
    private maxReconnectAttempts = 5;
    
    constructor(hubUrl: string) {
        this.connection = new signalR.HubConnectionBuilder()
            .withUrl(hubUrl)
            .withAutomaticReconnect()
            .configureLogging(signalR.LogLevel.Information)
            .build();
        
        this.setupEventHandlers();
    }
    
    private setupEventHandlers(): void {
        this.connection.onclose(async (error) => {
            console.error("Connection closed:", error);
            await this.attemptReconnect();
        });
        
        this.connection.onreconnecting((error) => {
            console.warn("Reconnecting...", error);
            this.updateUI("reconnecting");
        });
        
        this.connection.onreconnected((connectionId) => {
            console.log("Reconnected with ID:", connectionId);
            this.reconnectAttempts = 0;
            this.updateUI("connected");
            this.resubscribeToGroups();
        });
    }
    
    private async attemptReconnect(): Promise<void> {
        if (this.reconnectAttempts < this.maxReconnectAttempts) {
            this.reconnectAttempts++;
            const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 30000);
            
            console.log(`Reconnect attempt ${this.reconnectAttempts} in ${delay}ms`);
            await new Promise(resolve => setTimeout(resolve, delay));
            
            try {
                await this.connection.start();
                this.reconnectAttempts = 0;
            } catch (error) {
                console.error("Reconnection failed:", error);
                await this.attemptReconnect();
            }
        } else {
            console.error("Max reconnection attempts reached");
            this.updateUI("disconnected");
        }
    }
    
    private updateUI(state: string): void {
        // Update UI based on connection state
    }
    
    private resubscribeToGroups(): void {
        // Rejoin any groups after reconnection
    }
    
    public async start(): Promise<void> {
        await this.connection.start();
    }
    
    public on(methodName: string, handler: (...args: any[]) => void): void {
        this.connection.on(methodName, handler);
    }
    
    public async invoke(methodName: string, ...args: any[]): Promise<any> {
        return await this.connection.invoke(methodName, ...args);
    }
}

// Usage
const chatConnection = new SignalRConnection("/chatHub");
await chatConnection.start();

chatConnection.on("ReceiveMessage", (user, message) => {
    console.log(`${user}: ${message}`);
});

await chatConnection.invoke("SendMessage", "Hello, everyone!");
```

## Advanced Patterns

### Return Values from Hub Methods

```csharp
public class QueryHub : Hub
{
    private readonly IUserRepository _userRepository;
    
    public async Task<UserProfile> GetUserProfile(string userId)
    {
        return await _userRepository.GetProfileAsync(userId);
    }
    
    public async Task<List<Message>> GetRecentMessages(int count)
    {
        return await _messageRepository.GetRecentAsync(count, Context.UserIdentifier);
    }
}
```

```javascript
// Client can await results
const profile = await connection.invoke("GetUserProfile", "user123");
console.log(profile.name);

const messages = await connection.invoke("GetRecentMessages", 50);
messages.forEach(msg => console.log(msg.text));
```

### Streaming from Server

```csharp
public class StreamHub : Hub
{
    public async IAsyncEnumerable<StockPrice> StreamStockPrices(
        string symbol,
        [EnumeratorCancellation] CancellationToken cancellationToken)
    {
        while (!cancellationToken.IsCancellationRequested)
        {
            yield return await _stockService.GetCurrentPriceAsync(symbol);
            await Task.Delay(1000, cancellationToken);
        }
    }
}
```

```javascript
connection.stream("StreamStockPrices", "AAPL")
    .subscribe({
        next: (price) => updateStockDisplay(price),
        error: (err) => console.error(err),
        complete: () => console.log("Stream ended")
    });
```

<ProgressCheckpoint section="connection-management" xpReward={15} />

## Performance Considerations

### Connection Pooling (.NET Clients)

```csharp
// Singleton connection for multiple operations
services.AddSingleton<IHubConnectionPool, HubConnectionPool>();

public class HubConnectionPool : IHubConnectionPool
{
    private readonly ConcurrentDictionary<string, HubConnection> _connections = new();
    
    public async Task<HubConnection> GetConnectionAsync(string hubUrl)
    {
        return _connections.GetOrAdd(hubUrl, url =>
        {
            var connection = new HubConnectionBuilder()
                .WithUrl(url)
                .WithAutomaticReconnect()
                .Build();
            
            connection.StartAsync().GetAwaiter().GetResult();
            return connection;
        });
    }
}
```

### Message Batching

```csharp
public class BatchingHub : Hub
{
    public async Task SendBatchedMessages(List<Message> messages)
    {
        // Send as single payload instead of multiple calls
        await Clients.All.SendAsync("ReceiveBatch", messages);
    }
}
```

## Best Practices

 **Keep hub methods lightweight** - offload heavy work to background services  
 **Use strongly-typed hubs** for compile-time safety  
 **Implement proper error handling** in both hub and client  
 **Monitor connection state** and handle reconnections gracefully  
 **Use return values** for request-response patterns  
 **Stream large datasets** instead of loading all at once  
 **Pool connections** in .NET client applications  
 **Batch messages** when sending multiple updates  

> **Next**: Learn how to organize clients into groups for efficient targeted messaging!
