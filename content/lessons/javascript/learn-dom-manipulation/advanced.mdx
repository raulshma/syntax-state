# DOM Manipulation: Advanced

Welcome to advanced DOM manipulation! Here we'll explore powerful APIs like MutationObserver, dive into Shadow DOM for encapsulation, and learn performance optimization techniques that separate good developers from great ones.

<InfoBox type="tip" title="Expert Territory">
These concepts are used in frameworks like React, Vue, and Angular under the hood. Understanding them will make you a more effective developer and help you debug complex issues.
</InfoBox>

<ProgressCheckpoint section="introduction" xpReward={15} />

## MutationObserver: Watching for Changes

MutationObserver lets you react to DOM changes — when elements are added, removed, or modified.

### Basic Usage

```javascript
// Create an observer
const observer = new MutationObserver((mutations) => {
  mutations.forEach(mutation => {
    console.log('DOM changed:', mutation.type);
    
    if (mutation.type === 'childList') {
      mutation.addedNodes.forEach(node => {
        console.log('Added:', node);
      });
      mutation.removedNodes.forEach(node => {
        console.log('Removed:', node);
      });
    }
  });
});

// Start observing
observer.observe(document.body, {
  childList: true,      // Watch for added/removed children
  subtree: true,        // Watch all descendants
  attributes: true,     // Watch attribute changes
  characterData: true,  // Watch text content changes
});

// Stop observing when done
observer.disconnect();
```

### Practical Use Cases

```javascript
// 1. Lazy loading images when they're added to DOM
const imageObserver = new MutationObserver((mutations) => {
  mutations.forEach(mutation => {
    mutation.addedNodes.forEach(node => {
      if (node.nodeName === 'IMG' && node.dataset.src) {
        node.src = node.dataset.src;
      }
    });
  });
});

// 2. Auto-initialize components
const componentObserver = new MutationObserver((mutations) => {
  mutations.forEach(mutation => {
    mutation.addedNodes.forEach(node => {
      if (node.nodeType === Node.ELEMENT_NODE) {
        // Initialize any new components
        node.querySelectorAll('[data-component]').forEach(initComponent);
      }
    });
  });
});

// 3. Track form changes for auto-save
const formObserver = new MutationObserver(() => {
  scheduleAutoSave();
});
```

<KeyConcept title="Performance Tip">
MutationObserver batches changes and fires asynchronously, making it more efficient than deprecated `MutationEvents`. Always disconnect when you're done observing!
</KeyConcept>

<CodePlayground
  initialCode={`// MutationObserver example
// In a real app, this would watch actual DOM changes

const changes = [];

function simulateMutationCallback(mutations) {
  mutations.forEach(mutation => {
    changes.push({
      type: mutation.type,
      target: mutation.target,
      timestamp: Date.now()
    });
  });
}

// Simulate some mutations
simulateMutationCallback([
  { type: 'childList', target: 'div#container' },
  { type: 'attributes', target: 'button.submit' },
  { type: 'characterData', target: 'text node' }
]);

console.log('Observed changes:');
changes.forEach((change, i) => {
  console.log(\`\${i + 1}. \${change.type} on \${change.target}\`);
});`}
/>

<ProgressCheckpoint section="dom-tree" xpReward={15} />

## Shadow DOM: Encapsulation

Shadow DOM creates an isolated DOM tree attached to an element. Styles and scripts inside don't leak out, and outside styles don't leak in.

### Creating Shadow DOM

```javascript
// Create a host element
const host = document.createElement('div');
document.body.appendChild(host);

// Attach shadow root
const shadow = host.attachShadow({ mode: 'open' });

// Add content to shadow DOM
shadow.innerHTML = `
  <style>
    /* These styles only apply inside the shadow DOM */
    p { color: red; font-weight: bold; }
    .container { padding: 20px; border: 2px solid blue; }
  </style>
  <div class="container">
    <p>I'm inside the Shadow DOM!</p>
    <slot></slot>
  </div>
`;
```

### Shadow DOM Modes

```javascript
// 'open' - shadow root accessible via element.shadowRoot
const openShadow = element.attachShadow({ mode: 'open' });
console.log(element.shadowRoot); // Returns shadow root

// 'closed' - shadow root not accessible
const closedShadow = element.attachShadow({ mode: 'closed' });
console.log(element.shadowRoot); // Returns null
```

### Slots: Projecting Content

```javascript
// In shadow DOM template
shadow.innerHTML = `
  <div class="card">
    <slot name="header"></slot>
    <slot></slot>  <!-- Default slot -->
    <slot name="footer"></slot>
  </div>
`;

// In light DOM (regular HTML)
// <my-card>
//   <h2 slot="header">Title</h2>
//   <p>Main content goes in default slot</p>
//   <span slot="footer">Footer text</span>
// </my-card>
```

<KeyConcept title="When to Use Shadow DOM">
- Building reusable web components
- Isolating widget styles from page styles
- Creating embeddable widgets (like social buttons)
- Preventing CSS conflicts in large applications
</KeyConcept>

<DomTreeVisualizer
  html={`<div id="host">
  #shadow-root
    <style>scoped styles</style>
    <div class="wrapper">
      <slot name="header"></slot>
      <slot></slot>
    </div>
  <h2 slot="header">Slotted Header</h2>
  <p>Slotted Content</p>
</div>`}
  showAttributes={true}
/>

<ProgressCheckpoint section="selecting-elements" xpReward={15} />

## Custom Events

Create your own events for component communication:

```javascript
// Create a custom event
const event = new CustomEvent('userLoggedIn', {
  detail: {
    userId: 123,
    username: 'john_doe',
    timestamp: Date.now()
  },
  bubbles: true,      // Event bubbles up
  cancelable: true,   // Can be cancelled
  composed: true      // Crosses shadow DOM boundaries
});

// Dispatch the event
element.dispatchEvent(event);

// Listen for the event
document.addEventListener('userLoggedIn', (e) => {
  console.log('User logged in:', e.detail.username);
});
```

### Event-Driven Architecture

```javascript
// Component A: Dispatches events
class ShoppingCart {
  addItem(item) {
    this.items.push(item);
    this.element.dispatchEvent(new CustomEvent('cart:updated', {
      detail: { items: this.items, total: this.getTotal() },
      bubbles: true
    }));
  }
}

// Component B: Listens for events
class CartSummary {
  constructor() {
    document.addEventListener('cart:updated', (e) => {
      this.updateDisplay(e.detail);
    });
  }
}
```

<ProgressCheckpoint section="modifying-elements" xpReward={15} />

## Performance Optimization

### Batch DOM Operations

```javascript
// ❌ Bad: Multiple reflows
items.forEach(item => {
  const div = document.createElement('div');
  div.textContent = item;
  container.appendChild(div); // Triggers reflow each time!
});

// ✅ Good: Use DocumentFragment
const fragment = document.createDocumentFragment();
items.forEach(item => {
  const div = document.createElement('div');
  div.textContent = item;
  fragment.appendChild(div);
});
container.appendChild(fragment); // Single reflow!
```

### Minimize Reflows

```javascript
// ❌ Bad: Reading then writing repeatedly
elements.forEach(el => {
  const height = el.offsetHeight; // Read (forces layout)
  el.style.height = height + 10 + 'px'; // Write (invalidates layout)
});

// ✅ Good: Batch reads, then batch writes
const heights = elements.map(el => el.offsetHeight); // All reads
elements.forEach((el, i) => {
  el.style.height = heights[i] + 10 + 'px'; // All writes
});
```

### Use CSS Classes Instead of Inline Styles

```javascript
// ❌ Bad: Multiple style changes
element.style.color = 'red';
element.style.fontSize = '20px';
element.style.fontWeight = 'bold';

// ✅ Good: Single class toggle
element.classList.add('highlighted');
// CSS: .highlighted { color: red; font-size: 20px; font-weight: bold; }
```

### Virtual Scrolling for Large Lists

```javascript
// Only render visible items
class VirtualList {
  constructor(container, items, itemHeight) {
    this.container = container;
    this.items = items;
    this.itemHeight = itemHeight;
    
    container.addEventListener('scroll', () => this.render());
    this.render();
  }
  
  render() {
    const scrollTop = this.container.scrollTop;
    const viewportHeight = this.container.clientHeight;
    
    const startIndex = Math.floor(scrollTop / this.itemHeight);
    const endIndex = Math.min(
      startIndex + Math.ceil(viewportHeight / this.itemHeight) + 1,
      this.items.length
    );
    
    // Only render visible items
    const visibleItems = this.items.slice(startIndex, endIndex);
    // ... render only these items
  }
}
```

<KeyConcept title="Layout Thrashing">
Reading layout properties (offsetHeight, getBoundingClientRect) forces the browser to calculate layout. Alternating reads and writes causes "layout thrashing" — multiple expensive recalculations.
</KeyConcept>

<CodePlayground
  initialCode={`// Performance comparison
function measurePerformance(name, fn) {
  const start = performance.now();
  fn();
  const end = performance.now();
  console.log(\`\${name}: \${(end - start).toFixed(2)}ms\`);
}

// Simulate DOM operations
const items = Array.from({ length: 1000 }, (_, i) => \`Item \${i}\`);

measurePerformance('Individual appends (simulated)', () => {
  // Each append would trigger reflow
  items.forEach(() => {
    // container.appendChild(div)
  });
});

measurePerformance('DocumentFragment (simulated)', () => {
  // Single reflow at the end
  const fragment = { children: [] };
  items.forEach(item => {
    fragment.children.push(item);
  });
  // container.appendChild(fragment)
});

console.log("\\nDocumentFragment is much faster for bulk operations!");`}
/>

<ProgressCheckpoint section="events" xpReward={15} />

## Advanced Event Patterns

### Debouncing and Throttling

```javascript
// Debounce: Wait until user stops typing
function debounce(fn, delay) {
  let timeoutId;
  return (...args) => {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => fn(...args), delay);
  };
}

const handleSearch = debounce((query) => {
  fetchResults(query);
}, 300);

input.addEventListener('input', (e) => handleSearch(e.target.value));

// Throttle: Execute at most once per interval
function throttle(fn, interval) {
  let lastTime = 0;
  return (...args) => {
    const now = Date.now();
    if (now - lastTime >= interval) {
      lastTime = now;
      fn(...args);
    }
  };
}

const handleScroll = throttle(() => {
  updateScrollPosition();
}, 100);

window.addEventListener('scroll', handleScroll);
```

### Passive Event Listeners

```javascript
// Passive listeners can't call preventDefault()
// This allows browser to scroll immediately without waiting
document.addEventListener('touchstart', handleTouch, { passive: true });
document.addEventListener('wheel', handleWheel, { passive: true });

// For scroll-blocking events, explicitly set passive: false
document.addEventListener('touchmove', (e) => {
  e.preventDefault(); // Only works with passive: false
}, { passive: false });
```

<EventFlowSimulator showPhases={true} interactive={true} />

<ProgressCheckpoint section="event-flow" xpReward={10} />

## Key Takeaways

<KeyConcept title="MutationObserver">
Watch for DOM changes efficiently. Use for lazy loading, auto-initialization, and tracking modifications.
</KeyConcept>

<KeyConcept title="Shadow DOM">
Encapsulate styles and markup. Essential for web components and preventing CSS conflicts.
</KeyConcept>

<KeyConcept title="Performance">
Batch DOM operations with DocumentFragment, avoid layout thrashing, use CSS classes over inline styles.
</KeyConcept>

<ProgressCheckpoint section="summary" xpReward={10} />

## Quick Quiz

<Quiz>
  <Question text="What does MutationObserver watch for?">
    <Answer>Network requests</Answer>
    <Answer correct>DOM changes</Answer>
    <Answer>JavaScript errors</Answer>
    <Answer>CSS transitions</Answer>
  </Question>
  
  <Question text="What is the purpose of Shadow DOM?">
    <Answer>Faster rendering</Answer>
    <Answer correct>Style and markup encapsulation</Answer>
    <Answer>Server-side rendering</Answer>
    <Answer>Memory optimization</Answer>
  </Question>
  
  <Question text="What causes layout thrashing?">
    <Answer>Too many event listeners</Answer>
    <Answer>Large CSS files</Answer>
    <Answer correct>Alternating DOM reads and writes</Answer>
    <Answer>Using innerHTML</Answer>
  </Question>
  
  <Question text="What's the benefit of passive event listeners?">
    <Answer>They use less memory</Answer>
    <Answer correct>Browser can scroll without waiting for handler</Answer>
    <Answer>They fire more frequently</Answer>
    <Answer>They work across shadow DOM</Answer>
  </Question>
</Quiz>

---

**Congratulations!**  You've mastered advanced DOM manipulation. These skills will serve you well whether you're building vanilla JavaScript applications or working with modern frameworks.
