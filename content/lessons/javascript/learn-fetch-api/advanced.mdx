# Learn Fetch API - Advanced

Welcome to the advanced level! Here we'll explore the deeper aspects of HTTP communication: CORS, request cancellation with AbortController, streaming responses, and comparing Fetch with XMLHttpRequest.

<InfoBox type="tip" title="Advanced Territory">
These concepts are essential for building production-ready applications that handle edge cases, optimize performance, and work across different domains.
</InfoBox>

<ProgressCheckpoint section="introduction" xpReward={25} />

## Understanding CORS

**Cross-Origin Resource Sharing (CORS)** is a security mechanism that controls how web pages can request resources from different domains.

### The Same-Origin Policy

By default, browsers block requests to different origins (domain + protocol + port):

```javascript
// Your site: https://myapp.com

// ✅ Same origin - allowed
fetch('https://myapp.com/api/data')

// ❌ Different origin - blocked by default
fetch('https://api.other-site.com/data')
```

### How CORS Works

When you make a cross-origin request, the browser:

1. **Simple requests** (GET, POST with simple headers): Sends the request directly, checks response headers
2. **Preflight requests** (PUT, DELETE, custom headers): Sends an OPTIONS request first to check permissions

```
Browser                          Server
   |                                |
   |-- OPTIONS /api/data ---------> |  (Preflight)
   |<-- Access-Control-Allow-* ---- |
   |                                |
   |-- GET /api/data -------------> |  (Actual request)
   |<-- Data --------------------- |
```

### CORS Headers

The server controls CORS with these headers:

```http
# Allow requests from specific origin
Access-Control-Allow-Origin: https://myapp.com

# Or allow any origin (not recommended for sensitive data)
Access-Control-Allow-Origin: *

# Allow specific methods
Access-Control-Allow-Methods: GET, POST, PUT, DELETE

# Allow specific headers
Access-Control-Allow-Headers: Content-Type, Authorization

# Allow credentials (cookies, auth headers)
Access-Control-Allow-Credentials: true

# Cache preflight response (seconds)
Access-Control-Max-Age: 86400
```

<KeyConcept title="CORS is Server-Side">
You cannot bypass CORS from the browser. The server must send the appropriate headers to allow cross-origin requests.
</KeyConcept>

<CodePlayground
  initialCode={`// Understanding CORS scenarios
const scenarios = [
  {
    from: 'https://myapp.com',
    to: 'https://myapp.com/api',
    result: ' Same origin - always allowed'
  },
  {
    from: 'https://myapp.com',
    to: 'https://api.myapp.com',
    result: ' Different subdomain - needs CORS'
  },
  {
    from: 'https://myapp.com',
    to: 'http://myapp.com/api',
    result: ' Different protocol - needs CORS'
  },
  {
    from: 'https://myapp.com',
    to: 'https://myapp.com:8080/api',
    result: ' Different port - needs CORS'
  },
];

console.log('CORS Scenarios:\\n');
scenarios.forEach(s => {
  console.log(\`From: \${s.from}\`);
  console.log(\`To:   \${s.to}\`);
  console.log(\`→ \${s.result}\\n\`);
});`}
/>

<ProgressCheckpoint section="request-response" xpReward={25} />

## AbortController: Canceling Requests

Sometimes you need to cancel a request — maybe the user navigated away, or you're implementing a search that cancels previous requests.

### Basic Usage

```javascript
// Create an AbortController
const controller = new AbortController();

// Pass its signal to fetch
fetch('https://api.example.com/data', {
  signal: controller.signal
})
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => {
    if (error.name === 'AbortError') {
      console.log('Request was cancelled');
    } else {
      console.error('Fetch error:', error);
    }
  });

// Cancel the request
controller.abort();
```

### Timeout Pattern

```javascript
async function fetchWithTimeout(url, options = {}, timeout = 5000) {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeout);
  
  try {
    const response = await fetch(url, {
      ...options,
      signal: controller.signal,
    });
    clearTimeout(timeoutId);
    return response;
  } catch (error) {
    clearTimeout(timeoutId);
    if (error.name === 'AbortError') {
      throw new Error(`Request timed out after ${timeout}ms`);
    }
    throw error;
  }
}

// Usage
try {
  const response = await fetchWithTimeout('/api/slow-endpoint', {}, 3000);
  const data = await response.json();
} catch (error) {
  console.error(error.message);
}
```

### Search with Debounce and Cancellation

```javascript
let currentController = null;

async function search(query) {
  // Cancel previous request
  if (currentController) {
    currentController.abort();
  }
  
  // Create new controller for this request
  currentController = new AbortController();
  
  try {
    const response = await fetch(`/api/search?q=${query}`, {
      signal: currentController.signal,
    });
    const results = await response.json();
    displayResults(results);
  } catch (error) {
    if (error.name !== 'AbortError') {
      console.error('Search failed:', error);
    }
    // Ignore AbortError - it's expected when cancelling
  }
}

// Called on each keystroke (with debounce)
searchInput.addEventListener('input', debounce(e => {
  search(e.target.value);
}, 300));
```

<InfoBox type="info" title="AbortController is Reusable... Sort Of">
Once aborted, an AbortController cannot be reused. Create a new one for each request you might want to cancel.
</InfoBox>

<ProgressCheckpoint section="fetch-basics" xpReward={25} />

## Streaming Responses

For large responses, you can process data as it arrives instead of waiting for the entire response.

### Reading a Stream

```javascript
async function fetchWithProgress(url) {
  const response = await fetch(url);
  
  // Get the total size if available
  const contentLength = response.headers.get('Content-Length');
  const total = contentLength ? parseInt(contentLength, 10) : 0;
  
  // Get the reader from the response body stream
  const reader = response.body.getReader();
  let received = 0;
  const chunks = [];
  
  while (true) {
    const { done, value } = await reader.read();
    
    if (done) break;
    
    chunks.push(value);
    received += value.length;
    
    if (total) {
      const progress = (received / total * 100).toFixed(1);
      console.log(`Progress: ${progress}%`);
    }
  }
  
  // Combine chunks into single Uint8Array
  const allChunks = new Uint8Array(received);
  let position = 0;
  for (const chunk of chunks) {
    allChunks.set(chunk, position);
    position += chunk.length;
  }
  
  // Decode to string
  const text = new TextDecoder('utf-8').decode(allChunks);
  return JSON.parse(text);
}
```

### Server-Sent Events Pattern

```javascript
async function streamEvents(url, onEvent) {
  const response = await fetch(url);
  const reader = response.body.getReader();
  const decoder = new TextDecoder();
  let buffer = '';
  
  while (true) {
    const { done, value } = await reader.read();
    if (done) break;
    
    buffer += decoder.decode(value, { stream: true });
    
    // Process complete lines
    const lines = buffer.split('\n');
    buffer = lines.pop(); // Keep incomplete line in buffer
    
    for (const line of lines) {
      if (line.startsWith('data: ')) {
        const data = JSON.parse(line.slice(6));
        onEvent(data);
      }
    }
  }
}

// Usage
streamEvents('/api/events', event => {
  console.log('Received event:', event);
});
```

<KeyConcept title="Streams are Powerful">
Streaming allows you to:
- Show progress for large downloads
- Process data incrementally
- Reduce memory usage for huge responses
- Implement real-time features
</KeyConcept>

<ProgressCheckpoint section="http-methods" xpReward={25} />

## Request and Response Objects

### Creating Request Objects

```javascript
// Create a reusable request
const request = new Request('https://api.example.com/data', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({ key: 'value' }),
  mode: 'cors',
  credentials: 'include',
  cache: 'no-cache',
});

// Use the request
const response = await fetch(request);

// Clone for retry (requests can only be used once)
const retryRequest = request.clone();
```

### Request Options Deep Dive

```javascript
fetch(url, {
  // HTTP method
  method: 'POST',
  
  // Request headers
  headers: {
    'Content-Type': 'application/json',
  },
  
  // Request body
  body: JSON.stringify(data),
  
  // CORS mode
  mode: 'cors',        // Default - CORS enabled
  // mode: 'no-cors',  // Limited, opaque response
  // mode: 'same-origin', // Only same-origin requests
  
  // Credentials (cookies, auth)
  credentials: 'same-origin', // Default - same origin only
  // credentials: 'include',  // Always send
  // credentials: 'omit',     // Never send
  
  // Cache behavior
  cache: 'default',    // Normal caching
  // cache: 'no-store', // Don't cache
  // cache: 'reload',   // Ignore cache, update it
  // cache: 'no-cache', // Validate with server
  // cache: 'force-cache', // Use cache even if stale
  
  // Redirect handling
  redirect: 'follow',  // Default - follow redirects
  // redirect: 'error', // Throw on redirect
  // redirect: 'manual', // Don't follow, return redirect response
  
  // Referrer policy
  referrerPolicy: 'no-referrer-when-downgrade',
  
  // Abort signal
  signal: controller.signal,
});
```

<ProgressCheckpoint section="error-handling" xpReward={20} />

## Fetch vs XMLHttpRequest

Understanding the differences helps when working with legacy code or choosing the right tool.

### XMLHttpRequest (Legacy)

```javascript
// The old way
const xhr = new XMLHttpRequest();
xhr.open('GET', 'https://api.example.com/data');

xhr.onload = function() {
  if (xhr.status === 200) {
    const data = JSON.parse(xhr.responseText);
    console.log(data);
  } else {
    console.error('Error:', xhr.status);
  }
};

xhr.onerror = function() {
  console.error('Network error');
};

xhr.onprogress = function(event) {
  if (event.lengthComputable) {
    const progress = (event.loaded / event.total) * 100;
    console.log(`Progress: ${progress}%`);
  }
};

xhr.send();
```

### Comparison

| Feature | Fetch | XMLHttpRequest |
|---------|-------|----------------|
| Promise-based |  Yes |  No (callbacks) |
| Streaming |  Yes |  Limited |
| Request/Response objects |  Yes |  No |
| Service Worker support |  Yes |  No |
| Upload progress |  No |  Yes |
| Timeout option |  No (use AbortController) |  Yes |
| Synchronous requests |  No |  Yes (deprecated) |

<InfoBox type="info" title="When to Use XHR">
XMLHttpRequest still has one advantage: native upload progress events. For file uploads with progress bars, XHR might be simpler.
</InfoBox>

<ProgressCheckpoint section="headers-cors" xpReward={20} />

## Advanced Patterns

### Retry with Exponential Backoff

```javascript
async function fetchWithRetry(url, options = {}, maxRetries = 3) {
  let lastError;
  
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      const response = await fetch(url, options);
      
      if (response.ok) {
        return response;
      }
      
      // Don't retry client errors (4xx)
      if (response.status >= 400 && response.status < 500) {
        throw new Error(`Client error: ${response.status}`);
      }
      
      lastError = new Error(`Server error: ${response.status}`);
    } catch (error) {
      lastError = error;
    }
    
    // Exponential backoff: 1s, 2s, 4s...
    const delay = Math.pow(2, attempt) * 1000;
    console.log(`Retry ${attempt + 1} in ${delay}ms...`);
    await new Promise(resolve => setTimeout(resolve, delay));
  }
  
  throw lastError;
}
```

### Request Interceptor Pattern

```javascript
class FetchClient {
  constructor(baseUrl, defaultHeaders = {}) {
    this.baseUrl = baseUrl;
    this.defaultHeaders = defaultHeaders;
    this.interceptors = {
      request: [],
      response: [],
    };
  }
  
  addRequestInterceptor(fn) {
    this.interceptors.request.push(fn);
  }
  
  addResponseInterceptor(fn) {
    this.interceptors.response.push(fn);
  }
  
  async fetch(path, options = {}) {
    let config = {
      ...options,
      headers: { ...this.defaultHeaders, ...options.headers },
    };
    
    // Run request interceptors
    for (const interceptor of this.interceptors.request) {
      config = await interceptor(config);
    }
    
    let response = await fetch(this.baseUrl + path, config);
    
    // Run response interceptors
    for (const interceptor of this.interceptors.response) {
      response = await interceptor(response);
    }
    
    return response;
  }
}

// Usage
const api = new FetchClient('https://api.example.com', {
  'Content-Type': 'application/json',
});

// Add auth token to all requests
api.addRequestInterceptor(config => {
  const token = localStorage.getItem('token');
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

// Log all responses
api.addResponseInterceptor(response => {
  console.log(`${response.status} ${response.url}`);
  return response;
});
```

<CodePlayground
  initialCode={`// Retry with exponential backoff simulation
async function simulateFetchWithRetry(shouldFail = true) {
  const maxRetries = 3;
  
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    console.log(\`Attempt \${attempt} of \${maxRetries}...\`);
    
    // Simulate request
    const success = !shouldFail || attempt === maxRetries;
    
    if (success) {
      console.log(' Request succeeded!');
      return { data: 'Success!' };
    }
    
    console.log(' Request failed');
    
    if (attempt < maxRetries) {
      const delay = Math.pow(2, attempt - 1) * 1000;
      console.log(\`Waiting \${delay}ms before retry...\\n\`);
      // In real code: await new Promise(r => setTimeout(r, delay));
    }
  }
  
  throw new Error('All retries failed');
}

// Test the retry logic
simulateFetchWithRetry(true);`}
/>

<ProgressCheckpoint section="summary" xpReward={15} />

## Try the API Builder

Experiment with advanced request configurations:

<ApiRequestBuilder />

## Key Takeaways

<KeyConcept title="CORS is Essential">
Understand CORS to work with APIs across different domains. The server controls access through response headers.
</KeyConcept>

<KeyConcept title="AbortController for Cancellation">
Use AbortController to cancel requests, implement timeouts, and prevent race conditions in search/autocomplete features.
</KeyConcept>

<KeyConcept title="Streams for Large Data">
Use response.body streams for progress tracking and processing large responses incrementally.
</KeyConcept>

## Quick Quiz

<Quiz>
  <Question text="What triggers a CORS preflight request?">
    <Answer>Any cross-origin request</Answer>
    <Answer correct>Requests with custom headers or non-simple methods</Answer>
    <Answer>Only POST requests</Answer>
    <Answer>Requests to HTTPS endpoints</Answer>
  </Question>
  
  <Question text="How do you cancel a fetch request?">
    <Answer>fetch.cancel()</Answer>
    <Answer>response.abort()</Answer>
    <Answer correct>controller.abort() with AbortController</Answer>
    <Answer>clearFetch()</Answer>
  </Question>
  
  <Question text="What error name indicates a cancelled request?">
    <Answer>CancelError</Answer>
    <Answer correct>AbortError</Answer>
    <Answer>TimeoutError</Answer>
    <Answer>NetworkError</Answer>
  </Question>
  
  <Question text="Which feature does XMLHttpRequest have that Fetch lacks natively?">
    <Answer>Promise support</Answer>
    <Answer>Streaming</Answer>
    <Answer correct>Upload progress events</Answer>
    <Answer>CORS support</Answer>
  </Question>
</Quiz>

---

**Congratulations!**  You've mastered the Fetch API from basics to advanced patterns. You now have the knowledge to build robust, production-ready data fetching in your applications!
