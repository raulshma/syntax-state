# Learn Fetch API - Intermediate

Now that you understand the basics of fetching data, let's dive deeper into the Fetch API. We'll explore proper error handling, working with different HTTP methods, and understanding request/response objects in detail.

<InfoBox type="tip" title="Level Up Your Fetch Skills">
This lesson covers practical patterns you'll use daily: proper error handling, working with headers, and making different types of requests.
</InfoBox>

<ProgressCheckpoint section="introduction" xpReward={20} />

## The Fetch API in Depth

The `fetch()` function returns a Promise that resolves to a `Response` object. This object contains everything about the server's response.

```javascript
fetch('https://api.example.com/data')
  .then(response => {
    console.log(response.status);      // 200
    console.log(response.statusText);  // "OK"
    console.log(response.ok);          // true (status 200-299)
    console.log(response.headers);     // Headers object
    return response.json();
  })
  .then(data => console.log(data));
```

### Response Methods

The Response object has several methods to read the body:

| Method | Returns | Use When |
|--------|---------|----------|
| `response.json()` | Parsed JSON object | API returns JSON |
| `response.text()` | Plain string | HTML, plain text |
| `response.blob()` | Binary data | Images, files |
| `response.arrayBuffer()` | Raw binary | Low-level binary |
| `response.formData()` | FormData object | Form submissions |

<KeyConcept title="Body Can Only Be Read Once">
The response body is a stream — you can only read it once! If you call `response.json()`, you can't call `response.text()` afterward.
</KeyConcept>

<ProgressCheckpoint section="request-response" xpReward={20} />

## Proper Error Handling

One of the most common mistakes with fetch is not handling errors properly. Let's build a robust error handling pattern.

```javascript
async function fetchData(url) {
  try {
    const response = await fetch(url);
    
    // Check if response is OK (status 200-299)
    if (!response.ok) {
      // Try to get error details from response body
      const errorData = await response.json().catch(() => ({}));
      throw new Error(
        errorData.message || `HTTP error! Status: ${response.status}`
      );
    }
    
    return await response.json();
  } catch (error) {
    // Handle network errors and our thrown errors
    if (error.name === 'TypeError') {
      throw new Error('Network error - check your connection');
    }
    throw error;
  }
}

// Usage
fetchData('https://api.example.com/users')
  .then(users => console.log(users))
  .catch(error => console.error('Failed:', error.message));
```

<InfoBox type="warning" title="Fetch Doesn't Reject on HTTP Errors">
`fetch()` only rejects on network failures. A 404 or 500 response still resolves successfully — you must check `response.ok` yourself!
</InfoBox>

### Error Types to Handle

```javascript
async function robustFetch(url, options = {}) {
  try {
    const response = await fetch(url, options);
    
    if (!response.ok) {
      switch (response.status) {
        case 400:
          throw new Error('Bad request - check your data');
        case 401:
          throw new Error('Unauthorized - please log in');
        case 403:
          throw new Error('Forbidden - you lack permission');
        case 404:
          throw new Error('Not found - resource does not exist');
        case 429:
          throw new Error('Too many requests - slow down');
        case 500:
          throw new Error('Server error - try again later');
        default:
          throw new Error(`HTTP error: ${response.status}`);
      }
    }
    
    return response;
  } catch (error) {
    if (error instanceof TypeError) {
      throw new Error('Network error - are you online?');
    }
    throw error;
  }
}
```

<CodePlayground
  initialCode={`// Error handling patterns
async function safeFetch(url) {
  console.log("Fetching:", url);
  
  try {
    // Simulating different scenarios
    const scenarios = {
      '/success': { ok: true, status: 200, data: { message: 'Success!' } },
      '/not-found': { ok: false, status: 404, data: null },
      '/server-error': { ok: false, status: 500, data: null },
    };
    
    const scenario = scenarios[url] || scenarios['/success'];
    
    if (!scenario.ok) {
      throw new Error(\`HTTP \${scenario.status}: Request failed\`);
    }
    
    console.log(" Success:", scenario.data);
    return scenario.data;
    
  } catch (error) {
    console.log(" Error:", error.message);
    throw error;
  }
}

// Test different scenarios
safeFetch('/success');
safeFetch('/not-found').catch(() => {});
safeFetch('/server-error').catch(() => {});`}
/>

<ProgressCheckpoint section="fetch-basics" xpReward={20} />

## Working with HTTP Methods

Let's explore each HTTP method with proper patterns.

### GET - Retrieving Data

```javascript
// Simple GET
const response = await fetch('https://api.example.com/users');
const users = await response.json();

// GET with query parameters
const params = new URLSearchParams({
  page: 1,
  limit: 10,
  sort: 'name'
});
const response = await fetch(`https://api.example.com/users?${params}`);
```

### POST - Creating Data

```javascript
const newUser = {
  name: 'Jane Doe',
  email: 'jane@example.com',
  role: 'developer'
};

const response = await fetch('https://api.example.com/users', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify(newUser),
});

const createdUser = await response.json();
console.log('Created user with ID:', createdUser.id);
```

### PUT - Updating Data (Full Replace)

```javascript
const updatedUser = {
  id: 123,
  name: 'Jane Smith',  // Changed
  email: 'jane.smith@example.com',  // Changed
  role: 'senior developer'  // Changed
};

const response = await fetch('https://api.example.com/users/123', {
  method: 'PUT',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify(updatedUser),
});
```

### PATCH - Partial Update

```javascript
// Only update specific fields
const response = await fetch('https://api.example.com/users/123', {
  method: 'PATCH',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({
    role: 'team lead'  // Only updating role
  }),
});
```

### DELETE - Removing Data

```javascript
const response = await fetch('https://api.example.com/users/123', {
  method: 'DELETE',
});

if (response.ok) {
  console.log('User deleted successfully');
}
```

<KeyConcept title="PUT vs PATCH">
- **PUT**: Replaces the entire resource (send all fields)
- **PATCH**: Updates only specified fields (send only what changed)
</KeyConcept>

<ProgressCheckpoint section="http-methods" xpReward={20} />

## Working with Headers

Headers provide metadata about your request and response.

### Common Request Headers

```javascript
const response = await fetch('https://api.example.com/data', {
  headers: {
    // Tell server what format you're sending
    'Content-Type': 'application/json',
    
    // Tell server what format you want back
    'Accept': 'application/json',
    
    // Authentication
    'Authorization': 'Bearer your-token-here',
    
    // Custom headers (often prefixed with X-)
    'X-Request-ID': 'unique-request-id',
  },
});
```

### Reading Response Headers

```javascript
const response = await fetch('https://api.example.com/data');

// Get a specific header
const contentType = response.headers.get('Content-Type');
const rateLimit = response.headers.get('X-RateLimit-Remaining');

// Iterate all headers
response.headers.forEach((value, name) => {
  console.log(`${name}: ${value}`);
});
```

<InfoBox type="info" title="CORS and Headers">
Not all headers are accessible due to CORS restrictions. The server must explicitly expose headers using `Access-Control-Expose-Headers`.
</InfoBox>

<ProgressCheckpoint section="error-handling" xpReward={15} />

## Try It Yourself!

Use the API Request Builder to experiment with different HTTP methods and headers. Watch how the generated code changes!

<ApiRequestBuilder />

## Inspecting Responses

Use the Response Inspector to understand what comes back from the server:

<ResponseInspector 
  response={{
    status: 200,
    statusText: 'OK',
    headers: {
      'content-type': 'application/json; charset=utf-8',
      'cache-control': 'max-age=43200',
      'x-ratelimit-limit': '1000',
      'x-ratelimit-remaining': '999',
    },
    body: {
      id: 1,
      title: 'Sample Post',
      body: 'This is the post content...',
      userId: 1
    },
    time: 145
  }}
/>

<ProgressCheckpoint section="headers-cors" xpReward={15} />

## Async/Await Pattern

Modern JavaScript uses async/await for cleaner fetch code:

```javascript
// Promise chain (older style)
fetch('https://api.example.com/users')
  .then(response => response.json())
  .then(users => {
    console.log(users);
  })
  .catch(error => {
    console.error(error);
  });

// Async/await (modern style)
async function getUsers() {
  try {
    const response = await fetch('https://api.example.com/users');
    const users = await response.json();
    console.log(users);
  } catch (error) {
    console.error(error);
  }
}
```

### Parallel Requests

```javascript
// Fetch multiple resources in parallel
async function fetchDashboardData() {
  const [users, posts, comments] = await Promise.all([
    fetch('/api/users').then(r => r.json()),
    fetch('/api/posts').then(r => r.json()),
    fetch('/api/comments').then(r => r.json()),
  ]);
  
  return { users, posts, comments };
}
```

<CodePlayground
  initialCode={`// Async/await with fetch
async function fetchUserData(userId) {
  console.log(\`Fetching user \${userId}...\`);
  
  // Simulated API response
  const mockUsers = {
    1: { id: 1, name: 'Alice', role: 'Admin' },
    2: { id: 2, name: 'Bob', role: 'User' },
    3: { id: 3, name: 'Charlie', role: 'User' },
  };
  
  // Simulate network delay
  await new Promise(resolve => setTimeout(resolve, 100));
  
  const user = mockUsers[userId];
  
  if (!user) {
    throw new Error(\`User \${userId} not found\`);
  }
  
  console.log('Found user:', user);
  return user;
}

// Using async/await
async function main() {
  try {
    const user = await fetchUserData(1);
    console.log('User name:', user.name);
    
    // Try fetching non-existent user
    await fetchUserData(99);
  } catch (error) {
    console.log('Error:', error.message);
  }
}

main();`}
/>

<ProgressCheckpoint section="summary" xpReward={10} />

## Key Takeaways

<KeyConcept title="Always Check response.ok">
Fetch doesn't throw on HTTP errors. Always check `response.ok` or `response.status` before processing data.
</KeyConcept>

<KeyConcept title="Use Appropriate HTTP Methods">
- GET for reading
- POST for creating
- PUT for full updates
- PATCH for partial updates
- DELETE for removing
</KeyConcept>

<KeyConcept title="Headers Matter">
Set `Content-Type` when sending data, `Accept` for what you want back, and `Authorization` for protected resources.
</KeyConcept>

## Quick Quiz

<Quiz>
  <Question text="What does response.ok return for a 404 status?">
    <Answer>true</Answer>
    <Answer correct>false</Answer>
    <Answer>undefined</Answer>
    <Answer>null</Answer>
  </Question>
  
  <Question text="Which method should you use to update only specific fields?">
    <Answer>PUT</Answer>
    <Answer>POST</Answer>
    <Answer correct>PATCH</Answer>
    <Answer>UPDATE</Answer>
  </Question>
  
  <Question text="What header tells the server what format you're sending?">
    <Answer>Accept</Answer>
    <Answer correct>Content-Type</Answer>
    <Answer>Authorization</Answer>
    <Answer>Format</Answer>
  </Question>
  
  <Question text="How do you make multiple fetch requests run in parallel?">
    <Answer>fetch.all()</Answer>
    <Answer correct>Promise.all()</Answer>
    <Answer>async.parallel()</Answer>
    <Answer>fetch.parallel()</Answer>
  </Question>
</Quiz>

---

**Excellent work!**  You now have solid intermediate knowledge of the Fetch API. In the advanced level, we'll explore CORS, AbortController, streaming responses, and more advanced patterns.
