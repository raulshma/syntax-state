# JavaScript Syntax and Basic Constructs

Welcome to the advanced level! Here we'll explore the deeper mechanics of JavaScript — the specification details, operator precedence, bitwise operations, and edge cases that separate JavaScript experts from casual users.

<InfoBox type="info" title="ECMAScript Specification">
JavaScript is formally defined by the ECMAScript specification. Understanding how the spec defines behavior helps you predict exactly what JavaScript will do in any situation.
</InfoBox>

<ProgressCheckpoint section="introduction" xpReward={30} />

## The Abstract Equality Algorithm

When you use `==`, JavaScript follows a specific algorithm defined in the ECMAScript specification. Understanding this helps predict seemingly "weird" behavior.

### The Algorithm (Simplified)

1. If types are the same, use strict equality
2. `null == undefined` → `true`
3. Number vs String → convert string to number
4. Boolean vs anything → convert boolean to number first
5. Object vs primitive → convert object with `ToPrimitive`

```javascript
// Boolean conversion happens FIRST
console.log(true == "1");   // true (true→1, "1"→1)
console.log(true == "true"); // false (true→1, "true"→NaN)

// Object conversion uses valueOf/toString
console.log([1] == 1);      // true ([1].toString()→"1"→1)
console.log([1,2] == "1,2"); // true ([1,2].toString()→"1,2")
```

<KeyConcept title="ToPrimitive Conversion">
Objects are converted to primitives by calling `valueOf()` first, then `toString()` if needed. Arrays' `toString()` joins elements with commas.
</KeyConcept>

<CodePlayground
  initialCode={`// Abstract Equality deep dive
console.log("Boolean conversions:");
console.log('true == 1:', true == 1);
console.log('true == "1":', true == "1");
console.log('true == "true":', true == "true");

console.log("\\nArray conversions:");
console.log('[1] == 1:', [1] == 1);
console.log('[1] == "1":', [1] == "1");
console.log('[] == false:', [] == false);
console.log('[] == 0:', [] == 0);

console.log("\\nObject valueOf/toString:");
let obj = {
  valueOf() { return 42; },
  toString() { return "hello"; }
};
console.log('obj == 42:', obj == 42);
console.log('String(obj):', String(obj));`}
/>

<ProgressCheckpoint section="abstract-equality" xpReward={30} />

## Operator Precedence

Operators have different precedence levels that determine evaluation order. Higher precedence operators are evaluated first.

### Precedence Table (Highest to Lowest)

| Precedence | Operator | Description |
|------------|----------|-------------|
| 18 | `()` | Grouping |
| 17 | `.` `[]` `()` | Member access, call |
| 16 | `new` | Constructor call |
| 15 | `++` `--` | Postfix increment |
| 14 | `!` `~` `+` `-` `++` `--` `typeof` | Unary operators |
| 13 | `**` | Exponentiation |
| 12 | `*` `/` `%` | Multiplication |
| 11 | `+` `-` | Addition |
| 10 | `<<` `>>` `>>>` | Bitwise shift |
| 9 | `<` `<=` `>` `>=` | Comparison |
| 8 | `==` `!=` `===` `!==` | Equality |
| 7 | `&` | Bitwise AND |
| 6 | `^` | Bitwise XOR |
| 5 | `\|` | Bitwise OR |
| 4 | `&&` | Logical AND |
| 3 | `\|\|` | Logical OR |
| 2 | `?:` | Ternary |
| 1 | `=` `+=` etc. | Assignment |

### Associativity

When operators have the same precedence, associativity determines order:

```javascript
// Left-to-right (most operators)
console.log(10 - 5 - 2);  // 3 (evaluated as (10-5)-2)

// Right-to-left (assignment, exponentiation)
let a, b, c;
a = b = c = 5;  // c=5, then b=5, then a=5
console.log(2 ** 3 ** 2);  // 512 (evaluated as 2**(3**2) = 2**9)
```

<CodePlayground
  initialCode={`// Operator precedence examples
console.log("Precedence matters:");
console.log('2 + 3 * 4 =', 2 + 3 * 4);  // 14, not 20
console.log('(2 + 3) * 4 =', (2 + 3) * 4);  // 20

console.log("\\nExponentiation is right-associative:");
console.log('2 ** 3 ** 2 =', 2 ** 3 ** 2);  // 512
console.log('(2 ** 3) ** 2 =', (2 ** 3) ** 2);  // 64

console.log("\\nLogical operators:");
console.log('true || false && false =', true || false && false);  // true
// && has higher precedence than ||

console.log("\\nComparison chain (doesn't work like math!):");
console.log('1 < 2 < 3 =', 1 < 2 < 3);  // true (but not why you think!)
console.log('3 > 2 > 1 =', 3 > 2 > 1);  // false!
// 3 > 2 → true, true > 1 → 1 > 1 → false`}
/>

<ProgressCheckpoint section="operator-precedence" xpReward={30} />

## Bitwise Operations

Bitwise operators work on the binary representation of numbers. They convert operands to 32-bit integers.

### Bitwise Operators

```javascript
// AND (&) - both bits must be 1
console.log(5 & 3);   // 1 (0101 & 0011 = 0001)

// OR (|) - either bit can be 1
console.log(5 | 3);   // 7 (0101 | 0011 = 0111)

// XOR (^) - exactly one bit must be 1
console.log(5 ^ 3);   // 6 (0101 ^ 0011 = 0110)

// NOT (~) - inverts all bits
console.log(~5);      // -6 (inverts 0101)

// Left shift (<<) - shifts bits left
console.log(5 << 1);  // 10 (0101 → 1010)

// Right shift (>>) - shifts bits right (preserves sign)
console.log(-8 >> 2); // -2

// Unsigned right shift (>>>) - shifts bits right (fills with 0)
console.log(-8 >>> 2); // 1073741822
```

### Practical Uses

```javascript
// Fast integer conversion (truncates decimals)
console.log(~~3.7);     // 3
console.log(3.7 | 0);   // 3
console.log(3.7 >> 0);  // 3

// Check if number is even/odd
console.log(4 & 1);     // 0 (even)
console.log(5 & 1);     // 1 (odd)

// Swap without temp variable
let a = 5, b = 3;
a ^= b; b ^= a; a ^= b;
console.log(a, b);      // 3, 5

// Powers of 2
console.log(1 << 4);    // 16 (2^4)
console.log(1 << 10);   // 1024 (2^10)
```

<CodePlayground
  initialCode={`// Bitwise operations
console.log("Basic bitwise:");
console.log('5 & 3 =', 5 & 3, '(AND)');
console.log('5 | 3 =', 5 | 3, '(OR)');
console.log('5 ^ 3 =', 5 ^ 3, '(XOR)');
console.log('~5 =', ~5, '(NOT)');

console.log("\\nBit shifting:");
console.log('5 << 1 =', 5 << 1, '(left shift)');
console.log('5 >> 1 =', 5 >> 1, '(right shift)');

console.log("\\nPractical tricks:");
console.log('~~3.7 =', ~~3.7, '(fast floor)');
console.log('7 & 1 =', 7 & 1, '(odd check)');
console.log('8 & 1 =', 8 & 1, '(even check)');
console.log('1 << 10 =', 1 << 10, '(2^10)');

// Binary representation helper
function toBinary(n) {
  return (n >>> 0).toString(2).padStart(8, '0');
}
console.log("\\nBinary of 5:", toBinary(5));
console.log("Binary of 3:", toBinary(3));
console.log("5 & 3 binary:", toBinary(5 & 3));`}
/>

<ProgressCheckpoint section="bitwise-operations" xpReward={30} />

## Type Conversion Edge Cases

### Number Conversion Quirks

```javascript
// Empty and whitespace strings
Number("");        // 0
Number("   ");     // 0
Number("\n\t");    // 0

// Special values
Number(null);      // 0
Number(undefined); // NaN
Number(true);      // 1
Number(false);     // 0

// Arrays
Number([]);        // 0 (""→0)
Number([1]);       // 1 ("1"→1)
Number([1,2]);     // NaN ("1,2"→NaN)

// Objects
Number({});        // NaN
Number({valueOf: () => 42}); // 42
```

### String Conversion

```javascript
// Arrays join with commas
String([1, 2, 3]);     // "1,2,3"
String([]);            // ""
String([null, undefined]); // ","

// Objects use toString
String({});            // "[object Object]"
String({toString: () => "custom"}); // "custom"
```

<CodePlayground
  initialCode={`// Type conversion edge cases
console.log("Number conversions:");
console.log('Number("") =', Number(""));
console.log('Number("   ") =', Number("   "));
console.log('Number(null) =', Number(null));
console.log('Number(undefined) =', Number(undefined));
console.log('Number([]) =', Number([]));
console.log('Number([1]) =', Number([1]));
console.log('Number([1,2]) =', Number([1,2]));

console.log("\\nString conversions:");
console.log('String([1,2,3]) =', String([1,2,3]));
console.log('String([]) =', String([]));
console.log('String({}) =', String({}));

console.log("\\nWeird but true:");
console.log('[] + [] =', [] + []);
console.log('[] + {} =', [] + {});
console.log('{} + [] =', {} + []);
console.log('+[] =', +[]);
console.log('+{} =', +{});`}
/>

<ProgressCheckpoint section="type-conversion-edge-cases" xpReward={25} />

## The typeof Operator Quirks

```javascript
// Expected results
typeof undefined;  // "undefined"
typeof true;       // "boolean"
typeof 42;         // "number"
typeof "hello";    // "string"
typeof Symbol();   // "symbol"
typeof BigInt(1);  // "bigint"
typeof {};         // "object"
typeof function(){}; // "function"

// The famous bug
typeof null;       // "object" (historical bug, never fixed)

// Arrays are objects
typeof [];         // "object"

// Better checks
Array.isArray([]);           // true
Object.prototype.toString.call([]); // "[object Array]"
Object.prototype.toString.call(null); // "[object Null]"
```

<KeyConcept title="typeof null === 'object'">
This is a bug from the first JavaScript implementation that was never fixed for backward compatibility. Use `value === null` to check for null.
</KeyConcept>

<ProgressCheckpoint section="typeof-quirks" xpReward={20} />

## Variable Declarations: var vs let vs const

### Hoisting Behavior

```javascript
// var is hoisted and initialized to undefined
console.log(x); // undefined
var x = 5;

// let/const are hoisted but NOT initialized (TDZ)
console.log(y); // ReferenceError: Cannot access 'y' before initialization
let y = 5;
```

### Scope Differences

```javascript
// var is function-scoped
function varExample() {
  if (true) {
    var x = 1;
  }
  console.log(x); // 1 (accessible!)
}

// let/const are block-scoped
function letExample() {
  if (true) {
    let y = 1;
  }
  console.log(y); // ReferenceError
}
```

<VariableVisualizer 
  steps={[
    {
      id: 'step-1',
      action: 'declare',
      description: 'var is hoisted to function scope',
      code: 'var x; // hoisted',
      variables: [
        { name: 'x', value: undefined, type: 'undefined', declarationType: 'var', isNew: true }
      ]
    },
    {
      id: 'step-2',
      action: 'assign',
      description: 'Assignment happens at original location',
      code: 'x = 5;',
      variables: [
        { name: 'x', value: 5, type: 'number', declarationType: 'var', isModified: true }
      ]
    },
    {
      id: 'step-3',
      action: 'declare',
      description: 'let creates block-scoped variable',
      code: 'let y = 10;',
      variables: [
        { name: 'x', value: 5, type: 'number', declarationType: 'var' },
        { name: 'y', value: 10, type: 'number', declarationType: 'let', isNew: true }
      ]
    },
    {
      id: 'step-4',
      action: 'declare',
      description: 'const creates immutable binding',
      code: 'const z = 15;',
      variables: [
        { name: 'x', value: 5, type: 'number', declarationType: 'var' },
        { name: 'y', value: 10, type: 'number', declarationType: 'let' },
        { name: 'z', value: 15, type: 'number', declarationType: 'const', isNew: true }
      ]
    }
  ]}
/>

<ProgressCheckpoint section="variable-declarations" xpReward={20} />

## Key Takeaways

<KeyConcept title="Understand the Spec">
JavaScript's behavior is defined by ECMAScript. Understanding algorithms like Abstract Equality helps predict "weird" behavior.
</KeyConcept>

<KeyConcept title="Precedence Matters">
Know operator precedence to avoid bugs. When in doubt, use parentheses to make intent clear.
</KeyConcept>

<KeyConcept title="Bitwise for Performance">
Bitwise operations can be faster for certain operations like integer conversion and power-of-2 calculations.
</KeyConcept>

<ProgressCheckpoint section="summary" xpReward={15} />

## Quick Quiz

<Quiz>
  <Question text="What does typeof null return?">
    <Answer>"null"</Answer>
    <Answer correct>"object"</Answer>
    <Answer>"undefined"</Answer>
    <Answer>null</Answer>
  </Question>
  
  <Question text="What is the result of 2 ** 3 ** 2?">
    <Answer>64</Answer>
    <Answer correct>512</Answer>
    <Answer>36</Answer>
    <Answer>8</Answer>
  </Question>
  
  <Question text="What does ~5 return?">
    <Answer>-5</Answer>
    <Answer correct>-6</Answer>
    <Answer>4</Answer>
    <Answer>6</Answer>
  </Question>
  
  <Question text="What is Number([]) in JavaScript?">
    <Answer>NaN</Answer>
    <Answer correct>0</Answer>
    <Answer>undefined</Answer>
    <Answer>""</Answer>
  </Question>
</Quiz>

---

**Congratulations!**  You've mastered the advanced concepts of JavaScript syntax. You now understand the specification-level details that make JavaScript tick. This knowledge will help you debug complex issues and write more predictable code.
