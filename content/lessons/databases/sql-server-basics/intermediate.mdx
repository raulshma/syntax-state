# SQL Server Basics - Intermediate

Level up your SQL Server skills with stored procedures, indexes, and transactions!

---

## Section 1: Introduction to SQL Server

### SQL Server Architecture

Understanding how SQL Server works internally:

- **Database Engine** - Core service that stores and processes data
- **SQL Server Agent** - Job scheduling and automation
- **Integration Services (SSIS)** - ETL (Extract, Transform, Load)
- **Reporting Services (SSRS)** - Report generation
- **Analysis Services (SSAS)** - OLAP cubes and data mining

### System Databases

| Database | Purpose |
|:---------|:--------|
| **master** | Server configuration and login info |
| **model** | Template for new databases |
| **msdb** | SQL Agent jobs and backup history |
| **tempdb** | Temporary objects and intermediate results |

```sql
-- View system database info
SELECT name, database_id, create_date
FROM sys.databases
WHERE database_id <= 4;
```

<ProgressCheckpoint section="intro-sql-server" xpReward={12} />

---

## Section 2: SQL Server Management Studio (SSMS)

### Advanced SSMS Features

#### Query Shortcuts

```sql
-- sp_who2: See active connections
EXEC sp_who2;

-- sp_help: Get table info
EXEC sp_help 'Users';

-- sp_helptext: View stored procedure code
EXEC sp_helptext 'GetUserOrders';
```

#### Keyboard Shortcuts

| Shortcut | Action |
|:---------|:-------|
| `F5` or `Ctrl+E` | Execute query |
| `Ctrl+R` | Toggle results pane |
| `Ctrl+L` | Display execution plan |
| `Ctrl+Shift+V` | Cycle clipboard ring |
| `Ctrl+U` | Change database |

### Database Diagrams

Create visual representations of table relationships in SSMS:
1. Right-click "Database Diagrams" → New Database Diagram
2. Add tables
3. SSMS shows foreign key relationships automatically

<ProgressCheckpoint section="ssms-basics" xpReward={13} />

---

## Section 3: T-SQL Features

###  Stored Procedures

Stored procedures are saved SQL programs that live in the database:

<DotnetCodePreview
  title="Creating a Stored Procedure"
  code={`CREATE PROCEDURE GetUserOrders
    @UserId INT,
    @MinTotal DECIMAL(18,2) = 0
AS
BEGIN
    SET NOCOUNT ON;
    
    SELECT 
        Orders.Id,
        Orders.OrderDate,
        Orders.Total
    FROM Orders
    WHERE Orders.UserId = @UserId
      AND Orders.Total >= @MinTotal
    ORDER BY Orders.OrderDate DESC;
END;`}
  steps={[
    {
      lineNumbers: [2, 3],
      highlight: "Parameters",
      explanation: "@UserId is required, @MinTotal has a default value of 0"
    },
    {
      lineNumbers: [6],
      highlight: "SET NOCOUNT ON",
      explanation: "Prevents 'X rows affected' messages - cleaner output"
    },
    {
      lineNumbers: [8, 9, 10, 11, 12, 13, 14, 15],
      highlight: "The query",
      explanation: "Parameters are used like variables in the query"
    }
  ]}
/>

### Calling Stored Procedures

```sql
-- Execute with all parameters
EXEC GetUserOrders @UserId = 5, @MinTotal = 100.00;

-- Use default for @MinTotal
EXEC GetUserOrders @UserId = 5;
```

### From C#

```csharp
using var cmd = new SqlCommand("GetUserOrders", connection);
cmd.CommandType = CommandType.StoredProcedure;
cmd.Parameters.AddWithValue("@UserId", userId);

using var reader = await cmd.ExecuteReaderAsync();
```

##  Indexes - Speed Up Your Queries

Indexes are like a book's index - they help find data faster:

<DotnetCodePreview
  title="Creating Indexes"
  code={`-- Clustered Index (how data is physically stored)
-- Usually created automatically on PRIMARY KEY
CREATE CLUSTERED INDEX IX_Users_Id ON Users(Id);

-- Non-Clustered Index (separate lookup structure)
CREATE NONCLUSTERED INDEX IX_Users_Email 
ON Users(Email);

-- Composite Index (multiple columns)
CREATE INDEX IX_Orders_User_Date 
ON Orders(UserId, OrderDate DESC);

-- Include columns (covered queries)
CREATE INDEX IX_Orders_User_Covered
ON Orders(UserId)
INCLUDE (Total, Status);`}
  steps={[
    {
      lineNumbers: [3],
      highlight: "Clustered",
      explanation: "Only one per table - determines physical row order"
    },
    {
      lineNumbers: [6, 7],
      highlight: "Non-Clustered",
      explanation: "Separate structure pointing to data - can have many"
    },
    {
      lineNumbers: [10, 11],
      highlight: "Composite",
      explanation: "Order matters! Can use for UserId alone, but not OrderDate alone"
    },
    {
      lineNumbers: [14, 15, 16],
      highlight: "INCLUDE",
      explanation: "Adds columns to index without affecting sort order - prevents lookups"
    }
  ]}
/>

### When to Add Indexes

| Add Index On | Reason |
|:-------------|:-------|
| Foreign Keys | JOINs are faster |
| WHERE clause columns | Filtering is faster |
| ORDER BY columns | Sorting is faster |
| Frequently searched columns | Lookups are faster |

> ️ **Warning:** Too many indexes slow down INSERT/UPDATE/DELETE!

##  Transactions - All or Nothing

Transactions ensure multiple operations succeed or fail together:

<DotnetCodePreview
  title="Transaction in T-SQL"
  code={`BEGIN TRANSACTION;

BEGIN TRY
    -- Deduct from sender
    UPDATE Accounts SET Balance = Balance - 100 
    WHERE UserId = 1;
    
    -- Add to receiver
    UPDATE Accounts SET Balance = Balance + 100 
    WHERE UserId = 2;
    
    -- Both succeeded - make permanent
    COMMIT TRANSACTION;
END TRY
BEGIN CATCH
    -- Something failed - undo everything
    ROLLBACK TRANSACTION;
    
    THROW; -- Re-raise the error
END CATCH;`}
  steps={[
    {
      lineNumbers: [1],
      highlight: "BEGIN TRANSACTION",
      explanation: "Starts recording changes - nothing is final yet"
    },
    {
      lineNumbers: [5, 6, 9, 10],
      highlight: "Multiple operations",
      explanation: "Both must succeed for the transfer to be valid"
    },
    {
      lineNumbers: [13],
      highlight: "COMMIT",
      explanation: "Makes all changes permanent"
    },
    {
      lineNumbers: [16],
      highlight: "ROLLBACK",
      explanation: "Undoes ALL changes since BEGIN TRANSACTION"
    }
  ]}
/>

## ️ Views - Virtual Tables

Views are saved queries that act like tables:

```sql
-- Create a view
CREATE VIEW vw_ActiveUsersWithOrders
AS
SELECT 
    u.Id,
    u.Name,
    u.Email,
    COUNT(o.Id) AS OrderCount,
    SUM(o.Total) AS TotalSpent
FROM Users u
LEFT JOIN Orders o ON u.Id = o.UserId
WHERE u.IsActive = 1
GROUP BY u.Id, u.Name, u.Email;

-- Use it like a table
SELECT * FROM vw_ActiveUsersWithOrders
WHERE TotalSpent > 1000;
```

##  Triggers - Automatic Reactions

Triggers run automatically when data changes:

<DotnetCodePreview
  title="Audit Trigger"
  code={`CREATE TRIGGER trg_Users_Audit
ON Users
AFTER UPDATE
AS
BEGIN
    SET NOCOUNT ON;
    
    INSERT INTO UserAuditLog (UserId, ChangedAt, OldEmail, NewEmail)
    SELECT 
        i.Id,
        GETDATE(),
        d.Email,
        i.Email
    FROM inserted i
    INNER JOIN deleted d ON i.Id = d.Id
    WHERE i.Email <> d.Email;
END;`}
  steps={[
    {
      lineNumbers: [3],
      highlight: "AFTER UPDATE",
      explanation: "Runs after any UPDATE on Users table"
    },
    {
      lineNumbers: [14, 15],
      highlight: "inserted/deleted",
      explanation: "Special tables: 'inserted' has new values, 'deleted' has old values"
    },
    {
      lineNumbers: [16],
      highlight: "Change detection",
      explanation: "Only log when email actually changed"
    }
  ]}
/>

<SqlServerExplorer mode="intermediate" />

## Quick Reference

| Feature | Purpose | Syntax Start |
|:--------|:--------|:-------------|
| Stored Procedure | Reusable SQL program | `CREATE PROCEDURE` |
| Index | Speed up queries | `CREATE INDEX` |
| Transaction | Group operations | `BEGIN TRANSACTION` |
| View | Virtual table | `CREATE VIEW` |
| Trigger | Auto-react to changes | `CREATE TRIGGER` |

<ProgressCheckpoint section="tsql-features" xpReward={12} />

---

## Section 4: .NET Integration

### Using ADO.NET with SQL Server

```csharp
using Microsoft.Data.SqlClient;

public class UserRepository
{
    private readonly string _connectionString;

    public UserRepository(IConfiguration config)
    {
        _connectionString = config.GetConnectionString("DefaultConnection");
    }

    public async Task<User?> GetByIdAsync(int id)
    {
        using var connection = new SqlConnection(_connectionString);
        await connection.OpenAsync();

        using var command = new SqlCommand(
            "SELECT Id, Name, Email FROM Users WHERE Id = @Id",
            connection);
        
        command.Parameters.AddWithValue("@Id", id);

        using var reader = await command.ExecuteReaderAsync();
        
        if (await reader.ReadAsync())
        {
            return new User
            {
                Id = reader.GetInt32(0),
                Name = reader.GetString(1),
                Email = reader.GetString(2)
            };
        }

        return null;
    }

    public async Task<int> CreateAsync(User user)
    {
        using var connection = new SqlConnection(_connectionString);
        await connection.OpenAsync();

        using var command = new SqlCommand(
            @"INSERT INTO Users (Name, Email) 
              OUTPUT INSERTED.Id
              VALUES (@Name, @Email)",
            connection);
        
        command.Parameters.AddWithValue("@Name", user.Name);
        command.Parameters.AddWithValue("@Email", user.Email);

        return (int)await command.ExecuteScalarAsync();
    }
}
```

### Calling Stored Procedures from C#

```csharp
public async Task<List<Order>> GetUserOrdersAsync(int userId, decimal minTotal)
{
    using var connection = new SqlConnection(_connectionString);
    await connection.OpenAsync();

    using var command = new SqlCommand("GetUserOrders", connection);
    command.CommandType = CommandType.StoredProcedure;
    
    command.Parameters.AddWithValue("@UserId", userId);
    command.Parameters.AddWithValue("@MinTotal", minTotal);

    var orders = new List<Order>();
    using var reader = await command.ExecuteReaderAsync();
    
    while (await reader.ReadAsync())
    {
        orders.Add(new Order
        {
            Id = reader.GetInt32(0),
            OrderDate = reader.GetDateTime(1),
            Total = reader.GetDecimal(2)
        });
    }

    return orders;
}
```

### Transaction Management in C#

```csharp
public async Task TransferFundsAsync(int fromUserId, int toUserId, decimal amount)
{
    using var connection = new SqlConnection(_connectionString);
    await connection.OpenAsync();

    using var transaction = connection.BeginTransaction();
    
    try
    {
        // Deduct from sender
        using (var cmd = new SqlCommand(
            "UPDATE Accounts SET Balance = Balance - @Amount WHERE UserId = @UserId",
            connection, transaction))
        {
            cmd.Parameters.AddWithValue("@Amount", amount);
            cmd.Parameters.AddWithValue("@UserId", fromUserId);
            await cmd.ExecuteNonQueryAsync();
        }

        // Add to receiver
        using (var cmd = new SqlCommand(
            "UPDATE Accounts SET Balance = Balance + @Amount WHERE UserId = @UserId",
            connection, transaction))
        {
            cmd.Parameters.AddWithValue("@Amount", amount);
            cmd.Parameters.AddWithValue("@UserId", toUserId);
            await cmd.ExecuteNonQueryAsync();
        }

        await transaction.CommitAsync();
    }
    catch
    {
        await transaction.RollbackAsync();
        throw;
    }
}
```

<ProgressCheckpoint section="dotnet-integration" xpReward={13} />
