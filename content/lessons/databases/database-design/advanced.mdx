# Database Design - Advanced

Master advanced database design patterns, denormalization strategies, and enterprise-scale considerations.

---

## Section 1: Introduction to Design

### Enterprise Design Principles

#### SOLID Principles for Databases

- **Single Responsibility** - Each table has one clear purpose
- **Open/Closed** - Design for extension (add columns/tables, don't modify existing)
- **Liskov Substitution** - Subtypes should work like parent types (table inheritance)
- **Interface Segregation** - Don't force tables to have unused columns
- **Dependency Inversion** - Depend on abstractions (views) not concrete tables

#### Design for Scale

```sql
-- Partition key selection
-- BAD: Random UUID (no locality)
CREATE TABLE Events (
    Id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    Data JSONB
);

-- GOOD: Time-based partitioning
CREATE TABLE Events (
    Id BIGSERIAL,
    CreatedAt TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    Data JSONB,
    PRIMARY KEY (CreatedAt, Id)
) PARTITION BY RANGE (CreatedAt);
```

<ProgressCheckpoint section="intro-design" xpReward={18} />

---

## Section 2: Relationships

### Advanced Relationship Patterns

#### Polymorphic Associations

```sql
-- Comments can belong to Posts OR Photos
CREATE TABLE Comments (
    Id INT PRIMARY KEY,
    CommentableType VARCHAR(50) NOT NULL,  -- 'Post' or 'Photo'
    CommentableId INT NOT NULL,
    Content TEXT NOT NULL,
    
    -- Can't enforce with foreign key!
    -- Use triggers or app-level validation
    CHECK (CommentableType IN ('Post', 'Photo'))
);

-- Better: Separate junction tables
CREATE TABLE PostComments (
    CommentId INT PRIMARY KEY,
    PostId INT NOT NULL,
    FOREIGN KEY (CommentId) REFERENCES Comments(Id),
    FOREIGN KEY (PostId) REFERENCES Posts(Id)
);

CREATE TABLE PhotoComments (
    CommentId INT PRIMARY KEY,
    PhotoId INT NOT NULL,
    FOREIGN KEY (CommentId) REFERENCES Comments(Id),
    FOREIGN KEY (PhotoId) REFERENCES Photos(Id)
);
```

#### Self-Referencing Relationships

```sql
-- Employee hierarchy (manager-employee)
CREATE TABLE Employees (
    Id INT PRIMARY KEY,
    Name VARCHAR(100) NOT NULL,
    ManagerId INT NULL,
    FOREIGN KEY (ManagerId) REFERENCES Employees(Id)
);

-- Query: Get all reports under a manager (recursive CTE)
WITH RECURSIVE EmployeeHierarchy AS (
    -- Anchor: Start with the manager
    SELECT Id, Name, ManagerId, 0 AS Level
    FROM Employees
    WHERE Id = 1  -- CEO
    
    UNION ALL
    
    -- Recursive: Get direct reports
    SELECT e.Id, e.Name, e.ManagerId, eh.Level + 1
    FROM Employees e
    INNER JOIN EmployeeHierarchy eh ON e.ManagerId = eh.Id
)
SELECT * FROM EmployeeHierarchy;
```

#### Closure Table Pattern

```sql
-- For complex hierarchies (categories, org charts)
CREATE TABLE Categories (
    Id INT PRIMARY KEY,
    Name VARCHAR(100) NOT NULL
);

-- Stores ALL ancestor-descendant pairs
CREATE TABLE CategoryPaths (
    AncestorId INT NOT NULL,
    DescendantId INT NOT NULL,
    Depth INT NOT NULL,
    PRIMARY KEY (AncestorId, DescendantId),
    FOREIGN KEY (AncestorId) REFERENCES Categories(Id),
    FOREIGN KEY (DescendantId) REFERENCES Categories(Id)
);

-- Query: Get all descendants (any depth)
SELECT c.* 
FROM Categories c
JOIN CategoryPaths cp ON c.Id = cp.DescendantId
WHERE cp.AncestorId = 5;
```

<ProgressCheckpoint section="relationships" xpReward={19} />

---

## Section 3: Normalization

###  Beyond 3NF

### Boyce-Codd Normal Form (BCNF)

BCNF is stricter than 3NF - every determinant must be a candidate key.

<DotnetCodePreview
  title="BCNF Violation Example"
  code={`-- 3NF but not BCNF
-- Scenario: Teachers teach subjects, each subject taught by one teacher
| StudentId | Subject | Teacher    |
| 1         | Math    | Dr. Smith  |
| 1         | Science | Dr. Jones  |
| 2         | Math    | Dr. Smith  |  -- Same teacher for Math

-- Problem: Subject → Teacher, but Subject is not a key!
-- StudentId + Subject is the key

-- BCNF Solution: Split the table
CREATE TABLE TeacherSubjects (
    Subject VARCHAR(100) PRIMARY KEY,
    Teacher VARCHAR(100) NOT NULL
);

CREATE TABLE StudentSubjects (
    StudentId INT,
    Subject VARCHAR(100) REFERENCES TeacherSubjects(Subject),
    PRIMARY KEY (StudentId, Subject)
);`}
  steps={[
    {
      lineNumbers: [7],
      highlight: "Functional dependency",
      explanation: "Subject determines Teacher, but Subject alone isn't a key"
    },
    {
      lineNumbers: [12, 13, 14],
      highlight: "BCNF compliant",
      explanation: "Now Subject is the primary key in its own table"
    }
  ]}
/>

##  When to Denormalize

Sometimes breaking normalization rules improves performance:

### Reasons to Denormalize

| Scenario | Strategy |
|:---------|:---------|
| Frequent JOINs | Store calculated/aggregated values |
| Read-heavy systems | Duplicate data to avoid joins |
| Reporting tables | Pre-calculate summaries |
| Caching | Store derived data |

<DotnetCodePreview
  title="Denormalization Example"
  code={`-- Normalized: Requires JOIN for every read
CREATE TABLE Orders (
    Id INT PRIMARY KEY,
    CustomerId INT REFERENCES Customers(Id),
    Total DECIMAL(10,2)
);

-- Queries always need customer name
SELECT o.*, c.Name 
FROM Orders o 
JOIN Customers c ON o.CustomerId = c.Id;

-- Denormalized: Embed customer name (careful!)
CREATE TABLE Orders (
    Id INT PRIMARY KEY,
    CustomerId INT REFERENCES Customers(Id),
    CustomerName VARCHAR(100),  -- Duplicated!
    Total DECIMAL(10,2)
);

-- Now reads are faster but:
-- - Takes more storage
-- - Need to update both places if name changes
-- - Use triggers or app logic to sync`}
  steps={[
    {
      lineNumbers: [9, 10, 11],
      highlight: "Normalized query",
      explanation: "Always needs JOIN - can be slow at scale"
    },
    {
      lineNumbers: [15],
      highlight: "Denormalized field",
      explanation: "Trades storage for read performance"
    },
    {
      lineNumbers: [20, 21, 22],
      highlight: "Trade-offs",
      explanation: "Must handle data sync carefully"
    }
  ]}
/>

##  Index Design Strategy

Design indexes based on query patterns:

<DotnetCodePreview
  title="Strategic Index Design"
  code={`-- Analyze your common queries:

-- Query 1: Find orders by customer in date range
SELECT * FROM Orders 
WHERE CustomerId = ? AND OrderDate BETWEEN ? AND ?;
-- INDEX: (CustomerId, OrderDate)

-- Query 2: Search products by category and price
SELECT * FROM Products 
WHERE CategoryId = ? AND Price < ? 
ORDER BY Price;
-- INDEX: (CategoryId, Price)

-- Query 3: Full-text product search
SELECT * FROM Products 
WHERE Name LIKE '%keyboard%';
-- DON'T use B-tree! Use Full-Text Index

-- Composite Index Order Matters!
CREATE INDEX IX_Orders_Customer_Date 
ON Orders(CustomerId, OrderDate);

-- This index helps:
-- WHERE CustomerId = 5                    
-- WHERE CustomerId = 5 AND OrderDate > X  

-- But NOT:
-- WHERE OrderDate > X                      (can't use leading column)`}
  steps={[
    {
      lineNumbers: [5, 6],
      highlight: "Composite index",
      explanation: "Column order should match WHERE clause order"
    },
    {
      lineNumbers: [10, 11, 12],
      highlight: "Include ORDER BY",
      explanation: "If sorting by Price, include it in index"
    },
    {
      lineNumbers: [23, 24, 27],
      highlight: "Leftmost prefix rule",
      explanation: "Composite indexes work left-to-right"
    }
  ]}
/>

## ️ Design Patterns

### Soft Delete Pattern

<DotnetCodePreview
  title="Soft Delete"
  code={`CREATE TABLE Users (
    Id INT PRIMARY KEY,
    Email VARCHAR(255) NOT NULL,
    IsDeleted BIT DEFAULT 0,
    DeletedAt DATETIME2 NULL
);

-- "Delete" by updating flag
UPDATE Users SET IsDeleted = 1, DeletedAt = GETDATE()
WHERE Id = 42;

-- All queries filter out deleted
CREATE VIEW ActiveUsers AS
SELECT * FROM Users WHERE IsDeleted = 0;

-- Optional: Unique only for active rows
CREATE UNIQUE INDEX IX_Users_Email_Active
ON Users(Email)
WHERE IsDeleted = 0;`}
  steps={[
    {
      lineNumbers: [4, 5],
      highlight: "Soft delete columns",
      explanation: "Track deletion without removing data"
    },
    {
      lineNumbers: [13, 14],
      highlight: "Filtered view",
      explanation: "App uses this view - never sees deleted users"
    },
    {
      lineNumbers: [17, 18, 19],
      highlight: "Filtered unique index",
      explanation: "Allows same email to be 'deleted' then reused"
    }
  ]}
/>

### Audit Trail Pattern

```sql
CREATE TABLE Orders (
    Id INT IDENTITY PRIMARY KEY,
    CustomerId INT NOT NULL,
    Total DECIMAL(18,2) NOT NULL,
    Status VARCHAR(50) NOT NULL,
    
    -- Audit columns
    CreatedAt DATETIME2 DEFAULT GETDATE(),
    CreatedBy VARCHAR(100),
    UpdatedAt DATETIME2,
    UpdatedBy VARCHAR(100),
    Version INT DEFAULT 1
);

-- Audit log table
CREATE TABLE OrderAuditLog (
    Id INT IDENTITY PRIMARY KEY,
    OrderId INT NOT NULL,
    Action VARCHAR(10),  -- INSERT, UPDATE, DELETE
    ChangedAt DATETIME2 DEFAULT GETDATE(),
    ChangedBy VARCHAR(100),
    OldValues NVARCHAR(MAX),  -- JSON of old values
    NewValues NVARCHAR(MAX)   -- JSON of new values
);
```

### Temporal Tables (SQL Server 2016+)

<DotnetCodePreview
  title="System-Versioned Temporal Tables"
  code={`-- Create temporal table (system tracks history automatically!)
CREATE TABLE Products (
    Id INT PRIMARY KEY,
    Name NVARCHAR(100) NOT NULL,
    Price DECIMAL(18,2) NOT NULL,
    
    -- System versioning columns
    SysStartTime DATETIME2 GENERATED ALWAYS AS ROW START,
    SysEndTime DATETIME2 GENERATED ALWAYS AS ROW END,
    PERIOD FOR SYSTEM_TIME (SysStartTime, SysEndTime)
)
WITH (SYSTEM_VERSIONING = ON (HISTORY_TABLE = dbo.ProductsHistory));

-- Query current data
SELECT * FROM Products WHERE Id = 1;

-- Query historical data (time travel!)
SELECT * FROM Products FOR SYSTEM_TIME AS OF '2024-01-15'
WHERE Id = 1;

-- See all versions
SELECT * FROM Products FOR SYSTEM_TIME ALL
WHERE Id = 1;`}
  steps={[
    {
      lineNumbers: [8, 9, 10],
      highlight: "System time period",
      explanation: "Database tracks when each version was valid"
    },
    {
      lineNumbers: [12],
      highlight: "History table",
      explanation: "Old versions automatically stored"
    },
    {
      lineNumbers: [18, 19],
      highlight: "Time travel",
      explanation: "Query data as it was at any point in time"
    }
  ]}
/>

##  Schema Versioning

Track database changes with migration scripts:

```sql
-- Create version tracking table
CREATE TABLE SchemaVersions (
    Version INT PRIMARY KEY,
    Description VARCHAR(500),
    AppliedAt DATETIME2 DEFAULT GETDATE(),
    Checksum VARCHAR(100)
);

-- Example migration (001_CreateUsers.sql)
IF NOT EXISTS (SELECT 1 FROM SchemaVersions WHERE Version = 1)
BEGIN
    CREATE TABLE Users (
        Id INT IDENTITY PRIMARY KEY,
        Email VARCHAR(255) NOT NULL
    );
    
    INSERT INTO SchemaVersions (Version, Description)
    VALUES (1, 'Create Users table');
END;
```

<DatabaseDesignVisualizer mode="advanced" />

## Design Checklist

| Category | Best Practice |
|:---------|:--------------|
| **Keys** | Use surrogate keys (INT/UUID) for flexibility |
| **Normalization** | Start at 3NF, denormalize with metrics |
| **Indexes** | Design for query patterns, not just columns |
| **Constraints** | Enforce at database level, not just app |
| **Naming** | Consistent conventions (snake_case or PascalCase) |
| **Audit** | Track CreatedAt, UpdatedAt for all entities |
| **Soft Delete** | Consider for user-facing data |
| **Versioning** | Use temporal tables or audit logs |

<ProgressCheckpoint section="normalization" xpReward={19} />

---

## Section 4: Constraints

### Advanced Constraint Techniques

#### Exclusion Constraints (PostgreSQL)

```sql
-- Prevent overlapping time ranges
CREATE TABLE Bookings (
    Id SERIAL PRIMARY KEY,
    RoomId INT NOT NULL,
    DateRange daterange NOT NULL,
    
    EXCLUDE USING GIST (
        RoomId WITH =,
        DateRange WITH &&
    )
);

-- Can't book same room for overlapping dates
INSERT INTO Bookings (RoomId, DateRange) 
VALUES (1, '[2024-01-01, 2024-01-05)');  -- OK

INSERT INTO Bookings (RoomId, DateRange) 
VALUES (1, '[2024-01-03, 2024-01-07)');  -- ERROR: Overlaps!
```

#### Computed Columns with Constraints

```sql
-- SQL Server: Persisted computed column
CREATE TABLE Orders (
    Id INT PRIMARY KEY,
    Subtotal DECIMAL(18,2) NOT NULL,
    TaxRate DECIMAL(5,4) NOT NULL,
    Tax AS (Subtotal * TaxRate) PERSISTED,
    Total AS (Subtotal + (Subtotal * TaxRate)) PERSISTED,
    
    CHECK (Subtotal >= 0),
    CHECK (TaxRate BETWEEN 0 AND 1)
);
```

#### Conditional Unique Indexes

```sql
-- SQL Server: Unique only for active records
CREATE UNIQUE INDEX IX_Users_Email_Active
ON Users(Email)
WHERE IsDeleted = 0;

-- PostgreSQL: Partial unique index
CREATE UNIQUE INDEX ix_users_email_active
ON users(email)
WHERE is_deleted = false;
```

#### Cross-Table Constraints with Triggers

```sql
-- Ensure order total matches sum of line items
CREATE TRIGGER trg_validate_order_total
ON OrderItems
AFTER INSERT, UPDATE, DELETE
AS
BEGIN
    IF EXISTS (
        SELECT o.Id
        FROM Orders o
        LEFT JOIN (
            SELECT OrderId, SUM(Quantity * Price) AS CalculatedTotal
            FROM OrderItems
            GROUP BY OrderId
        ) oi ON o.Id = oi.OrderId
        WHERE ABS(o.Total - COALESCE(oi.CalculatedTotal, 0)) > 0.01
    )
    BEGIN
        RAISERROR('Order total does not match line items', 16, 1);
        ROLLBACK;
    END
END;
```

### Domain-Driven Design Constraints

```sql
-- Value objects as constraints
CREATE DOMAIN email_address AS VARCHAR(255)
CHECK (VALUE ~ '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}$');

CREATE DOMAIN positive_money AS DECIMAL(18,2)
CHECK (VALUE >= 0);

CREATE TABLE Users (
    Id INT PRIMARY KEY,
    Email email_address NOT NULL,
    Balance positive_money DEFAULT 0
);
```

<ProgressCheckpoint section="constraints" xpReward={19} />
