# Database Design - Intermediate

Learn normalization - the science of organizing data to eliminate redundancy and improve integrity.

---

## Section 1: Introduction to Design

### Database Design Process

A systematic approach to designing databases:

1. **Requirements Analysis** - What data do we need?
2. **Conceptual Design** - ER diagrams, entities, relationships
3. **Logical Design** - Convert to tables, normalize
4. **Physical Design** - Indexes, partitions, optimization

### Entity-Relationship (ER) Diagrams

Visual representation of database structure:

- **Entities** - Things we store (Users, Orders, Products)
- **Attributes** - Properties of entities (Name, Email, Price)
- **Relationships** - How entities connect (User places Order)

```
[Customer] --< places >-- [Order] --< contains >-- [Product]
   1                         N          N              1
```

### Naming Conventions

| Style | Example | Used By |
|:------|:--------|:--------|
| **snake_case** | `user_profiles`, `order_items` | PostgreSQL, MySQL |
| **PascalCase** | `UserProfiles`, `OrderItems` | SQL Server, C# |
| **camelCase** | `userProfiles`, `orderItems` | JavaScript |

**Pick one and be consistent!**

<ProgressCheckpoint section="intro-design" xpReward={12} />

---

## Section 2: Relationships

### Implementing One-to-One

```sql
-- User has one profile (optional)
CREATE TABLE Users (
    Id INT PRIMARY KEY,
    Email VARCHAR(255) NOT NULL
);

CREATE TABLE UserProfiles (
    UserId INT PRIMARY KEY,
    Bio TEXT,
    Avatar VARCHAR(500),
    FOREIGN KEY (UserId) REFERENCES Users(Id) ON DELETE CASCADE
);
```

**When to use:** Separate frequently-accessed data from rarely-accessed data.

### Implementing One-to-Many

```sql
-- Blog has many posts
CREATE TABLE Blogs (
    Id INT PRIMARY KEY,
    Title VARCHAR(200) NOT NULL
);

CREATE TABLE Posts (
    Id INT PRIMARY KEY,
    BlogId INT NOT NULL,
    Title VARCHAR(200) NOT NULL,
    Content TEXT,
    FOREIGN KEY (BlogId) REFERENCES Blogs(Id)
);

-- Query: Get all posts for a blog
SELECT * FROM Posts WHERE BlogId = 1;
```

### Implementing Many-to-Many

```sql
-- Authors write books, books have authors
CREATE TABLE Authors (
    Id INT PRIMARY KEY,
    Name VARCHAR(100) NOT NULL
);

CREATE TABLE Books (
    Id INT PRIMARY KEY,
    Title VARCHAR(200) NOT NULL,
    ISBN VARCHAR(20) UNIQUE
);

-- Junction table
CREATE TABLE BookAuthors (
    BookId INT,
    AuthorId INT,
    AuthorOrder INT,  -- First author, second author, etc.
    PRIMARY KEY (BookId, AuthorId),
    FOREIGN KEY (BookId) REFERENCES Books(Id),
    FOREIGN KEY (AuthorId) REFERENCES Authors(Id)
);
```

### Cascade Options

```sql
-- ON DELETE CASCADE: Delete child rows when parent is deleted
FOREIGN KEY (CustomerId) REFERENCES Customers(Id) ON DELETE CASCADE

-- ON DELETE SET NULL: Set foreign key to NULL
FOREIGN KEY (CustomerId) REFERENCES Customers(Id) ON DELETE SET NULL

-- ON DELETE RESTRICT: Prevent deletion if children exist (default)
FOREIGN KEY (CustomerId) REFERENCES Customers(Id) ON DELETE RESTRICT
```

<ProgressCheckpoint section="relationships" xpReward={13} />

---

## Section 3: Normalization

###  What is Normalization?

Normalization is the process of organizing your data to:
- **Eliminate redundancy** (don't store the same data twice)
- **Prevent anomalies** (no weird bugs when updating/deleting)
- **Improve data integrity** (data stays consistent)

<DatabaseDesignVisualizer mode="intermediate" initialTab="normalization" />

##  The Normal Forms Journey

### Unnormalized Data (0NF)

Start with a messy spreadsheet:

| OrderId | Customer | Products | Quantities |
|:--------|:---------|:---------|:-----------|
| 1 | John Smith | Laptop, Mouse | 1, 2 |
| 2 | Jane Doe | Keyboard | 1 |

**Problems:**
-  Multiple values in one cell (violates atomicity)
-  Can't easily query individual products
-  Can't add quantities to products

## 1️⃣ First Normal Form (1NF)

**Rule:** Each cell must contain only ONE value. No repeating groups.

<DotnetCodePreview
  title="Converting to 1NF"
  code={`-- BAD: Violates 1NF (multiple values in cell)
| OrderId | Products        | Quantities |
| 1       | Laptop, Mouse   | 1, 2       |

-- GOOD: 1NF compliant (one value per cell)
| OrderId | Customer    | Product  | Quantity |
| 1       | John Smith  | Laptop   | 1        |
| 1       | John Smith  | Mouse    | 2        |
| 2       | Jane Doe    | Keyboard | 1        |`}
  steps={[
    {
      lineNumbers: [2, 3],
      highlight: "Before",
      explanation: "Multiple products in one cell - can't query or sort properly"
    },
    {
      lineNumbers: [6, 7, 8, 9],
      highlight: "After",
      explanation: "Each product gets its own row - atomic values"
    }
  ]}
/>

**New Problem:** Customer name is repeated! 

## 2️⃣ Second Normal Form (2NF)

**Rule:** Must be in 1NF + all non-key columns must depend on the ENTIRE primary key.

<DotnetCodePreview
  title="Converting to 2NF"
  code={`-- Problem: Customer depends only on OrderId, not OrderId+Product
-- This is a "partial dependency"

-- Solution: Split into two tables!

-- Orders table (customer info here)
CREATE TABLE Orders (
    OrderId INT PRIMARY KEY,
    CustomerId INT,
    OrderDate DATE
);

-- OrderItems table (products here)
CREATE TABLE OrderItems (
    OrderId INT,
    ProductId INT,
    Quantity INT,
    PRIMARY KEY (OrderId, ProductId)
);`}
  steps={[
    {
      lineNumbers: [7, 8, 9, 10],
      highlight: "Orders",
      explanation: "Customer info lives with order - no product dependency"
    },
    {
      lineNumbers: [14, 15, 16, 17],
      highlight: "OrderItems",
      explanation: "Products reference orders - proper composite key"
    }
  ]}
/>

## 3️⃣ Third Normal Form (3NF)

**Rule:** Must be in 2NF + no transitive dependencies (non-key → non-key).

<DotnetCodePreview
  title="Converting to 3NF"
  code={`-- Problem: CustomerCity depends on CustomerZip, not on OrderId
-- CustomerZip → CustomerCity is a transitive dependency!

-- BAD: 2NF but not 3NF
| OrderId | CustomerName | CustomerZip | CustomerCity |
| 1       | John Smith   | 10001       | New York     |

-- GOOD: 3NF - Separate customers
CREATE TABLE Customers (
    Id INT PRIMARY KEY,
    Name VARCHAR(100),
    ZipCode VARCHAR(10)
);

CREATE TABLE ZipCodes (
    ZipCode VARCHAR(10) PRIMARY KEY,
    City VARCHAR(100),
    State VARCHAR(50)
);

-- Now city is looked up from ZipCodes, not duplicated!`}
  steps={[
    {
      lineNumbers: [5, 6],
      highlight: "Transitive dependency",
      explanation: "City depends on Zip, Zip depends on Customer"
    },
    {
      lineNumbers: [15, 16, 17, 18],
      highlight: "Separate table",
      explanation: "ZipCode determines City - stored once, reused many times"
    }
  ]}
/>

##  The Golden Rule

> **A column should depend on the key, the whole key, and nothing but the key!**

| Normal Form | What to Check |
|:------------|:--------------|
| 1NF | Every cell has one value |
| 2NF | No partial dependencies |
| 3NF | No transitive dependencies |

##  Implementing Many-to-Many

Many-to-many relationships need a **junction table** (also called bridge table, link table):

<DotnetCodePreview
  title="Many-to-Many Relationship"
  code={`-- Students can take many courses
-- Courses can have many students

-- Parent tables
CREATE TABLE Students (
    Id INT PRIMARY KEY,
    Name VARCHAR(100)
);

CREATE TABLE Courses (
    Id INT PRIMARY KEY,
    Title VARCHAR(200)
);

-- Junction table (bridge)
CREATE TABLE Enrollments (
    StudentId INT REFERENCES Students(Id),
    CourseId INT REFERENCES Courses(Id),
    EnrollDate DATE DEFAULT CURRENT_DATE,
    Grade DECIMAL(3,2),
    PRIMARY KEY (StudentId, CourseId)  -- Composite key
);`}
  steps={[
    {
      lineNumbers: [15, 16, 17],
      highlight: "Junction table",
      explanation: "Links students and courses with foreign keys"
    },
    {
      lineNumbers: [18, 19],
      highlight: "Extra columns",
      explanation: "Can store relationship-specific data like enrollment date"
    },
    {
      lineNumbers: [20],
      highlight: "Composite primary key",
      explanation: "Each student-course pair is unique"
    }
  ]}
/>

## ️ More Constraints

### CHECK Constraint

```sql
CREATE TABLE Products (
    Id INT PRIMARY KEY,
    Price DECIMAL(10,2) CHECK (Price >= 0),
    Stock INT CHECK (Stock >= 0),
    Rating DECIMAL(2,1) CHECK (Rating BETWEEN 0 AND 5)
);
```

### Composite Unique Constraints

```sql
-- User can review each product only once
CREATE TABLE Reviews (
    Id INT PRIMARY KEY,
    UserId INT,
    ProductId INT,
    Rating INT,
    UNIQUE (UserId, ProductId)  -- Composite unique
);
```

<DatabaseDesignVisualizer mode="intermediate" initialTab="keys" />

## Quick Reference

| Concept | Key Point |
|:--------|:----------|
| 1NF | Atomic values only |
| 2NF | No partial dependencies |
| 3NF | No transitive dependencies |
| Junction Table | Enables many-to-many |
| CHECK | Validates data values |

<ProgressCheckpoint section="normalization" xpReward={12} />

---

## Section 4: Constraints

### Advanced Constraint Patterns

#### Composite Unique Constraints

```sql
-- User can review each product only once
CREATE TABLE Reviews (
    Id INT PRIMARY KEY,
    UserId INT NOT NULL,
    ProductId INT NOT NULL,
    Rating INT CHECK (Rating BETWEEN 1 AND 5),
    Comment TEXT,
    UNIQUE (UserId, ProductId)  -- Composite unique
);
```

#### CHECK with Multiple Conditions

```sql
CREATE TABLE Employees (
    Id INT PRIMARY KEY,
    Name VARCHAR(100) NOT NULL,
    Salary DECIMAL(10,2),
    Department VARCHAR(50),
    
    -- Complex check
    CHECK (
        (Department = 'Sales' AND Salary >= 30000) OR
        (Department = 'Engineering' AND Salary >= 50000) OR
        (Department NOT IN ('Sales', 'Engineering'))
    )
);
```

#### Conditional Constraints

```sql
-- Email required only for active users
CREATE TABLE Users (
    Id INT PRIMARY KEY,
    Email VARCHAR(255),
    IsActive BIT DEFAULT 1,
    
    CHECK (IsActive = 0 OR Email IS NOT NULL)
);
```

### Deferred Constraints

```sql
-- PostgreSQL: Check constraint at end of transaction
CREATE TABLE Orders (
    Id INT PRIMARY KEY,
    Total DECIMAL(10,2),
    PaidAmount DECIMAL(10,2) DEFAULT 0,
    
    CONSTRAINT chk_payment_complete 
    CHECK (PaidAmount >= Total) DEFERRABLE INITIALLY DEFERRED
);

-- Can temporarily violate during transaction
BEGIN;
    INSERT INTO Orders (Id, Total) VALUES (1, 100);  -- PaidAmount = 0, violates check
    UPDATE Orders SET PaidAmount = 100 WHERE Id = 1;  -- Now satisfied
COMMIT;  -- Check happens here
```

### Triggers as Constraints

```sql
-- Enforce business rule: Can't delete customer with unpaid orders
CREATE TRIGGER trg_prevent_customer_delete
ON Customers
INSTEAD OF DELETE
AS
BEGIN
    IF EXISTS (
        SELECT 1 FROM Orders o
        INNER JOIN deleted d ON o.CustomerId = d.Id
        WHERE o.Status = 'Unpaid'
    )
    BEGIN
        RAISERROR('Cannot delete customer with unpaid orders', 16, 1);
        ROLLBACK;
    END
    ELSE
    BEGIN
        DELETE FROM Customers 
        WHERE Id IN (SELECT Id FROM deleted);
    END
END;
```

<ProgressCheckpoint section="constraints" xpReward={13} />
