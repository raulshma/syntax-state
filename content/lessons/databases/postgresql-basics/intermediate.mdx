# PostgreSQL Basics - Intermediate

Unlock PostgreSQL's unique features that set it apart from other databases!

---

## Section 1: Introduction to PostgreSQL

### PostgreSQL Architecture

Understanding PostgreSQL's process model:

- **Postmaster** - Main server process that listens for connections
- **Backend processes** - One per client connection
- **Background workers** - Autovacuum, WAL writer, checkpointer
- **Shared memory** - Buffer cache, WAL buffers, lock tables

### Configuration Files

| File | Purpose |
|:-----|:--------|
| `postgresql.conf` | Main configuration |
| `pg_hba.conf` | Client authentication |
| `pg_ident.conf` | User name mapping |

```sql
-- View current settings
SHOW all;
SHOW shared_buffers;
SHOW max_connections;

-- Reload configuration
SELECT pg_reload_conf();
```

<ProgressCheckpoint section="intro-postgres" xpReward={12} />

---

## Section 2: psql Basics

### Advanced psql Features

```sql
-- Variables
\set user_id 42
SELECT * FROM users WHERE id = :user_id;

-- Conditional execution
\if :user_id > 10
    SELECT 'High ID';
\else
    SELECT 'Low ID';
\endif

-- Watch query (auto-refresh)
\watch 2  -- Refresh every 2 seconds

-- Copy data
\copy users TO 'users.csv' CSV HEADER;
\copy users FROM 'users.csv' CSV HEADER;
```

### Query Performance Analysis

```sql
-- Explain query plan
EXPLAIN SELECT * FROM users WHERE email = 'test@example.com';

-- Explain with actual execution
EXPLAIN ANALYZE SELECT * FROM users WHERE email = 'test@example.com';

-- Verbose output
EXPLAIN (ANALYZE, BUFFERS, VERBOSE) 
SELECT * FROM users WHERE email = 'test@example.com';
```

<ProgressCheckpoint section="psql-basics" xpReward={13} />

---

## Section 3: Unique Features

###  JSONB - The Document Store Inside Postgres

PostgreSQL's JSONB type stores JSON documents with full query capability:

<DotnetCodePreview
  title="Working with JSONB"
  code={`-- Create a table with JSONB column
CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL,
    attributes JSONB DEFAULT '{}'::jsonb
);

-- Insert with JSON data
INSERT INTO products (name, attributes) VALUES
('Laptop', '{"brand": "Dell", "specs": {"ram": 16, "storage": 512}}'),
('Phone', '{"brand": "Apple", "color": "Blue", "5G": true}');

-- Query JSON fields
SELECT name, attributes->>'brand' AS brand
FROM products;

-- Filter by JSON content
SELECT * FROM products
WHERE attributes->>'brand' = 'Apple';

-- Check if key exists
SELECT * FROM products
WHERE attributes ? 'color';

-- Access nested values
SELECT name, attributes->'specs'->>'ram' AS ram_gb
FROM products;`}
  steps={[
    {
      lineNumbers: [5],
      highlight: "JSONB column",
      explanation: "JSONB stores binary JSON - faster queries than plain JSON"
    },
    {
      lineNumbers: [13],
      highlight: "->> operator",
      explanation: "Gets JSON value as TEXT - great for SELECTs and WHEREs"
    },
    {
      lineNumbers: [21],
      highlight: "? operator",
      explanation: "Checks if a key exists - unique to PostgreSQL!"
    },
    {
      lineNumbers: [25],
      highlight: "Nested access",
      explanation: "Chain -> and ->> to drill into nested objects"
    }
  ]}
/>

### JSONB Operators Cheat Sheet

| Operator | Purpose | Example |
|:---------|:--------|:--------|
| `->` | Get JSON object | `data->'user'` |
| `->>` | Get value as text | `data->>'name'` |
| `?` | Key exists? | `data ? 'email'` |
| `?|` | Any key exists? | `data ?| array['a','b']` |
| `@>` | Contains? | `data @> '{"active":true}'` |
| `||` | Merge | `data || '{"new":"val"}'` |

##  Arrays - Store Lists Natively

PostgreSQL supports array columns - no junction table needed for simple lists:

<DotnetCodePreview
  title="Working with Arrays"
  code={`-- Create table with array column
CREATE TABLE articles (
    id SERIAL PRIMARY KEY,
    title TEXT NOT NULL,
    tags TEXT[] DEFAULT '{}'
);

-- Insert with array
INSERT INTO articles (title, tags) VALUES
('PostgreSQL Tips', ARRAY['database', 'postgres', 'tips']),
('SQL Basics', '{"sql", "beginner"}');  -- Also valid syntax

-- Query arrays
SELECT * FROM articles
WHERE 'postgres' = ANY(tags);

-- Check if contains all
SELECT * FROM articles
WHERE tags @> ARRAY['database', 'tips'];

-- Array functions
SELECT 
    title,
    array_length(tags, 1) AS tag_count,
    array_to_string(tags, ', ') AS tags_csv
FROM articles;`}
  steps={[
    {
      lineNumbers: [5],
      highlight: "TEXT[]",
      explanation: "Array of text values - works with any data type"
    },
    {
      lineNumbers: [14],
      highlight: "= ANY()",
      explanation: "Checks if value exists in array"
    },
    {
      lineNumbers: [18],
      highlight: "@> operator",
      explanation: "Array contains all specified elements"
    },
    {
      lineNumbers: [22, 23],
      highlight: "Array functions",
      explanation: "Built-in functions for array manipulation"
    }
  ]}
/>

##  Functions and Stored Procedures

PostgreSQL supports multiple languages for functions:

<DotnetCodePreview
  title="Creating Functions"
  code={`-- PL/pgSQL function (most common)
CREATE OR REPLACE FUNCTION get_user_order_total(user_id INTEGER)
RETURNS NUMERIC AS $$
DECLARE
    total NUMERIC;
BEGIN
    SELECT COALESCE(SUM(amount), 0) INTO total
    FROM orders
    WHERE orders.user_id = get_user_order_total.user_id;
    
    RETURN total;
END;
$$ LANGUAGE plpgsql;

-- Call it
SELECT get_user_order_total(42);

-- Table-returning function
CREATE OR REPLACE FUNCTION get_active_users()
RETURNS TABLE(id INTEGER, name TEXT, email TEXT) AS $$
BEGIN
    RETURN QUERY
    SELECT users.id, users.name, users.email
    FROM users
    WHERE users.is_active = true;
END;
$$ LANGUAGE plpgsql;

-- Use like a table
SELECT * FROM get_active_users();`}
  steps={[
    {
      lineNumbers: [2, 3],
      highlight: "Function signature",
      explanation: "Parameter and return type declaration"
    },
    {
      lineNumbers: [4, 5],
      highlight: "DECLARE",
      explanation: "Local variable declarations"
    },
    {
      lineNumbers: [18, 19],
      highlight: "RETURNS TABLE",
      explanation: "Returns multiple rows - can be used in FROM clause"
    }
  ]}
/>

##  Full-Text Search

Built-in search engine capabilities:

<DotnetCodePreview
  title="Full-Text Search"
  code={`-- Add search column
ALTER TABLE articles ADD COLUMN search_vector tsvector;

-- Update with searchable content
UPDATE articles SET search_vector = 
    to_tsvector('english', title || ' ' || COALESCE(content, ''));

-- Create GIN index for fast search
CREATE INDEX idx_articles_search ON articles USING GIN(search_vector);

-- Search!
SELECT title, ts_rank(search_vector, query) AS rank
FROM articles, to_tsquery('english', 'postgres & tips') AS query
WHERE search_vector @@ query
ORDER BY rank DESC;

-- Highlight matching text
SELECT ts_headline('english', content, to_tsquery('postgres'))
FROM articles
WHERE search_vector @@ to_tsquery('postgres');`}
  steps={[
    {
      lineNumbers: [2],
      highlight: "tsvector",
      explanation: "Special type that stores preprocessed searchable text"
    },
    {
      lineNumbers: [8],
      highlight: "GIN index",
      explanation: "Generalized Inverted Index - perfect for text search"
    },
    {
      lineNumbers: [12, 13],
      highlight: "@@ operator",
      explanation: "Matches a tsvector against a tsquery"
    },
    {
      lineNumbers: [17],
      highlight: "ts_headline",
      explanation: "Returns text with search terms highlighted"
    }
  ]}
/>

##  Materialized Views

Cached query results for expensive queries:

```sql
-- Create materialized view
CREATE MATERIALIZED VIEW mv_user_stats AS
SELECT 
    u.id,
    u.name,
    COUNT(o.id) AS order_count,
    COALESCE(SUM(o.amount), 0) AS total_spent
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
GROUP BY u.id, u.name;

-- Create index on materialized view
CREATE INDEX ON mv_user_stats(total_spent DESC);

-- Query it (instant!)
SELECT * FROM mv_user_stats ORDER BY total_spent DESC LIMIT 10;

-- Refresh when data changes
REFRESH MATERIALIZED VIEW mv_user_stats;

-- Concurrent refresh (no locks)
REFRESH MATERIALIZED VIEW CONCURRENTLY mv_user_stats;
```

<PostgresqlExplorer mode="intermediate" />

## Quick Reference

| Feature | Use Case |
|:--------|:---------|
| JSONB | Flexible schema, document-like data |
| Arrays | Simple lists without join tables |
| Full-Text Search | Search engine features |
| Materialized Views | Cache expensive queries |

<ProgressCheckpoint section="unique-features" xpReward={12} />

---

## Section 4: .NET with Npgsql

### Advanced Npgsql Features

```csharp
// Working with arrays
using var cmd = new NpgsqlCommand(
    "SELECT * FROM articles WHERE @tag = ANY(tags)", 
    connection);
cmd.Parameters.AddWithValue("tag", "postgres");

// Working with JSONB
using var cmd2 = new NpgsqlCommand(
    "SELECT * FROM products WHERE attributes @> @filter", 
    connection);
cmd2.Parameters.AddWithValue("filter", NpgsqlDbType.Jsonb, "{\"brand\":\"Apple\"}");

// Bulk copy (fast inserts)
using var writer = connection.BeginBinaryImport(
    "COPY users (name, email) FROM STDIN (FORMAT BINARY)");
foreach (var user in users)
{
    writer.StartRow();
    writer.Write(user.Name);
    writer.Write(user.Email);
}
await writer.CompleteAsync();
```

### Entity Framework Core with PostgreSQL

```csharp
// Configure for PostgreSQL
builder.Services.AddDbContext<AppDbContext>(options =>
    options.UseNpgsql(connectionString, npgsqlOptions =>
    {
        npgsqlOptions.EnableRetryOnFailure(3);
        npgsqlOptions.CommandTimeout(60);
    })
    .UseSnakeCaseNamingConvention()  // user_id instead of UserId
);

// Entity with array
public class Article
{
    public int Id { get; set; }
    public string Title { get; set; } = "";
    public List<string> Tags { get; set; } = new();  // Maps to TEXT[]
}

// Query arrays
var articles = await context.Articles
    .Where(a => a.Tags.Contains("postgres"))
    .ToListAsync();

// Entity with JSONB
public class Product
{
    public int Id { get; set; }
    public string Name { get; set; } = "";
    
    [Column(TypeName = "jsonb")]
    public Dictionary<string, object> Attributes { get; set; } = new();
}
```

### Migrations with Npgsql

```csharp
// In migration
protected override void Up(MigrationBuilder migrationBuilder)
{
    // Create extension
    migrationBuilder.Sql("CREATE EXTENSION IF NOT EXISTS \"uuid-ossp\"");
    
    // Create table with PostgreSQL-specific types
    migrationBuilder.CreateTable(
        name: "events",
        columns: table => new
        {
            id = table.Column<Guid>(type: "uuid", nullable: false, defaultValueSql: "uuid_generate_v4()"),
            data = table.Column<string>(type: "jsonb", nullable: false),
            tags = table.Column<List<string>>(type: "text[]", nullable: false),
            created_at = table.Column<DateTime>(type: "timestamptz", nullable: false, defaultValueSql: "NOW()")
        });
    
    // Create GIN index for JSONB
    migrationBuilder.CreateIndex(
        name: "ix_events_data",
        table: "events",
        column: "data")
        .Annotation("Npgsql:IndexMethod", "GIN");
}
```

<ProgressCheckpoint section="dotnet-npgsql" xpReward={13} />
