# SQL Fundamentals - Intermediate

Now that you know the basics, let's dive deeper into more powerful SQL features that will make you a database pro!

---

## Section 1: Introduction to SQL

### SQL in the Real World

In production applications, SQL is used for:

- **Data retrieval** - Fetching user profiles, product catalogs, order history
- **Data manipulation** - Creating accounts, updating inventory, processing transactions
- **Reporting** - Generating sales reports, analytics dashboards
- **Data integrity** - Ensuring consistency through constraints and transactions

### Database Tables and Relationships

Real applications use multiple related tables:

```sql
-- Users table
CREATE TABLE Users (
    Id INT PRIMARY KEY,
    Name VARCHAR(100),
    Email VARCHAR(100) UNIQUE,
    CreatedAt DATETIME
);

-- Orders table (related to Users)
CREATE TABLE Orders (
    Id INT PRIMARY KEY,
    UserId INT,
    Total DECIMAL(10,2),
    OrderDate DATETIME,
    FOREIGN KEY (UserId) REFERENCES Users(Id)
);
```

The `FOREIGN KEY` creates a relationship: each order belongs to one user.

<ProgressCheckpoint section="intro-sql" xpReward={12} />

---

## Section 2: SELECT Queries

###  JOINs - Connecting Tables

Real databases have multiple related tables. JOINs let you combine data from different tables based on relationships.

<DotnetCodePreview
  title="Understanding JOINs"
  code={`-- INNER JOIN: Only matching rows from both tables
SELECT Users.Name, Orders.Total
FROM Users
INNER JOIN Orders ON Users.Id = Orders.UserId;

-- LEFT JOIN: All users, even without orders
SELECT Users.Name, Orders.Total
FROM Users
LEFT JOIN Orders ON Users.Id = Orders.UserId;`}
  steps={[
    {
      lineNumbers: [2, 3, 4],
      highlight: "INNER JOIN",
      explanation: "Returns only rows where there's a match in BOTH tables - users who have orders"
    },
    {
      lineNumbers: [7, 8, 9],
      highlight: "LEFT JOIN",
      explanation: "Returns ALL users, with NULL for Total when they have no orders"
    }
  ]}
/>

#### Types of JOINs Visualized

| JOIN Type | What It Returns | Use When |
|:----------|:----------------|:---------|
| INNER JOIN | Only matching rows | You need data that exists in both tables |
| LEFT JOIN | All left + matching right | You want all records from main table |
| RIGHT JOIN | All right + matching left | Rarely used (use LEFT JOIN instead) |
| FULL OUTER JOIN | All rows from both | You need complete picture of both |

###  Aggregate Functions

Aggregate functions perform calculations across multiple rows:

<DotnetCodePreview
  title="Common Aggregate Functions"
  code={`-- Count all users
SELECT COUNT(*) AS TotalUsers FROM Users;

-- Find average age
SELECT AVG(Age) AS AverageAge FROM Users;

-- Get min and max
SELECT MIN(Age) AS Youngest, MAX(Age) AS Oldest FROM Users;

-- Sum of all order totals
SELECT SUM(Total) AS Revenue FROM Orders;`}
  steps={[
    {
      lineNumbers: [2],
      highlight: "COUNT(*)",
      explanation: "Counts all rows - useful for knowing how many records exist"
    },
    {
      lineNumbers: [5],
      highlight: "AVG()",
      explanation: "Calculates the average value - great for statistics"
    },
    {
      lineNumbers: [8],
      highlight: "MIN/MAX",
      explanation: "Finds the smallest and largest values"
    },
    {
      lineNumbers: [11],
      highlight: "SUM()",
      explanation: "Adds up all values - perfect for totals like revenue"
    }
  ]}
/>

###  GROUP BY - Grouping Data

GROUP BY organizes your data into groups and lets you aggregate within each group:

<DotnetCodePreview
  title="Grouping Orders by Customer"
  code={`-- Count orders per customer
SELECT 
    Users.Name,
    COUNT(Orders.Id) AS OrderCount,
    SUM(Orders.Total) AS TotalSpent
FROM Users
LEFT JOIN Orders ON Users.Id = Orders.UserId
GROUP BY Users.Id, Users.Name;`}
  steps={[
    {
      lineNumbers: [3, 4, 5],
      highlight: "Aggregates per group",
      explanation: "COUNT and SUM are calculated for EACH user separately"
    },
    {
      lineNumbers: [8],
      highlight: "GROUP BY",
      explanation: "Every non-aggregated column in SELECT must be in GROUP BY"
    }
  ]}
/>

###  HAVING - Filtering Groups

HAVING is like WHERE, but for grouped data:

```sql
-- Find customers with more than 5 orders
SELECT 
    Users.Name,
    COUNT(Orders.Id) AS OrderCount
FROM Users
JOIN Orders ON Users.Id = Orders.UserId
GROUP BY Users.Id, Users.Name
HAVING COUNT(Orders.Id) > 5;
```

> **WHERE vs HAVING:**
> - WHERE filters individual rows BEFORE grouping
> - HAVING filters groups AFTER grouping

<ProgressCheckpoint section="select-queries" xpReward={13} />

---

## Section 3: INSERT, UPDATE, DELETE

### Batch INSERT Operations

Insert multiple rows at once:

```sql
-- Insert multiple users
INSERT INTO Users (Name, Email, Age)
VALUES 
    ('Alice', 'alice@email.com', 28),
    ('Bob', 'bob@email.com', 35),
    ('Charlie', 'charlie@email.com', 42);
```

### UPDATE with Calculations

```sql
-- Increase all prices by 10%
UPDATE Products
SET Price = Price * 1.10
WHERE Category = 'Electronics';

-- Update based on another table
UPDATE Users
SET LastOrderDate = (
    SELECT MAX(OrderDate)
    FROM Orders
    WHERE Orders.UserId = Users.Id
)
WHERE EXISTS (SELECT 1 FROM Orders WHERE Orders.UserId = Users.Id);
```

### Conditional DELETE

```sql
-- Delete old inactive users
DELETE FROM Users
WHERE IsActive = 0 
  AND LastLoginDate < DATEADD(year, -2, GETDATE());

-- Delete with JOIN (SQL Server syntax)
DELETE Orders
FROM Orders
INNER JOIN Users ON Orders.UserId = Users.Id
WHERE Users.IsDeleted = 1;
```

<InfoBox type="warning">
  **Always test UPDATE and DELETE with SELECT first!** Replace UPDATE/DELETE with SELECT * to see what rows will be affected.
</InfoBox>

<ProgressCheckpoint section="insert-update-delete" xpReward={12} />

---

## Section 4: WHERE Clauses

###  Subqueries in WHERE

Subqueries are queries inside queries - powerful for complex logic:

<DotnetCodePreview
  title="Subquery Examples"
  code={`-- Find users above average age
SELECT Name, Age
FROM Users
WHERE Age > (SELECT AVG(Age) FROM Users);

-- Find users who have placed orders
SELECT Name
FROM Users
WHERE Id IN (SELECT DISTINCT UserId FROM Orders);`}
  steps={[
    {
      lineNumbers: [3, 4],
      highlight: "Scalar subquery",
      explanation: "The inner query returns a single value (average age)"
    },
    {
      lineNumbers: [8, 9],
      highlight: "IN subquery",
      explanation: "The inner query returns a list of values to match against"
    }
  ]}
/>

### Advanced WHERE Patterns

```sql
-- EXISTS for checking related records
SELECT Name
FROM Users u
WHERE EXISTS (
    SELECT 1 FROM Orders o 
    WHERE o.UserId = u.Id AND o.Total > 1000
);

-- NOT IN for exclusion
SELECT Name
FROM Users
WHERE Id NOT IN (SELECT UserId FROM Banned);

-- Complex conditions
SELECT *
FROM Products
WHERE (Category = 'Electronics' AND Price < 500)
   OR (Category = 'Books' AND InStock = 1);
```

###  Set Operations

Combine results from multiple queries:

```sql
-- UNION: Combine unique results
SELECT Name FROM Users
UNION
SELECT Name FROM ArchivedUsers;

-- UNION ALL: Include duplicates (faster)
SELECT Name FROM Users
UNION ALL
SELECT Name FROM ArchivedUsers;

-- INTERSECT: Only rows in both
SELECT Email FROM Users
INTERSECT
SELECT Email FROM Newsletter;

-- EXCEPT: Rows in first but not second
SELECT Email FROM Users
EXCEPT
SELECT Email FROM Unsubscribed;
```

## Try Complex Queries

<SqlQueryVisualizer mode="intermediate" />

## Quick Reference

| Feature | Syntax | Purpose |
|:--------|:-------|:--------|
| JOIN | `JOIN table ON condition` | Combine related tables |
| GROUP BY | `GROUP BY column` | Aggregate by groups |
| HAVING | `HAVING condition` | Filter grouped results |
| Subquery | `(SELECT ... FROM ...)` | Query within a query |
| UNION | `query1 UNION query2` | Combine query results |
| EXISTS | `WHERE EXISTS (subquery)` | Check for related records |

<ProgressCheckpoint section="where-clauses" xpReward={13} />
