# Dependency Injection Fundamentals

Dependency Injection (DI) is a design pattern that implements **Inversion of Control (IoC)** - a principle where the control of object creation is transferred from the class itself to an external entity.

---

## Section 1: Understanding Inversion of Control

Traditional programming has a **top-down** control flow:

```csharp
// Traditional: Class controls its dependencies
public class OrderProcessor
{
    private readonly PaymentService _payment = new PaymentService();
    private readonly InventoryService _inventory = new InventoryService();
    // This class is in CONTROL of everything
}
```

With IoC, **control is inverted** - dependencies flow IN:

```csharp
// IoC: Dependencies are injected
public class OrderProcessor
{
    private readonly IPaymentService _payment;
    private readonly IInventoryService _inventory;

    // Dependencies are GIVEN, not created
    public OrderProcessor(IPaymentService payment, IInventoryService inventory)
    {
        _payment = payment;
        _inventory = inventory;
    }
}
```

<InfoBox type="important">
  **IoC vs DI:** IoC is the **principle**, DI is the **pattern** that implements it.
</InfoBox>

<ProgressCheckpoint section="di-what-is" xpReward={13} />

---

## Section 2: Types of Dependency Injection

### Constructor Injection (Recommended )

<DIPatternShowcase pattern="constructor-injection" mode="intermediate" />

**Why Constructor Injection?**
- Dependencies are **explicit** - visible in the constructor signature
- Dependencies are **required** - cannot create the object without them
- Object is **fully initialized** after construction

### Method Injection (Occasionally Useful)

```csharp
public class ReportGenerator
{
    public Report Generate(IDataSource dataSource)
    {
        var data = dataSource.Fetch();
        return new Report(data);
    }
}
```

**Use when:** The dependency varies between calls or is optional.

### Property Injection (Avoid ️)

```csharp
public class Service
{
    public ILogger? Logger { get; set; }  // Optional dependency
    public void DoWork() => Logger?.Log("Working...");
}
```

**Problems:** Object may be in an invalid state before properties are set.

<ProgressCheckpoint section="di-why-matters" xpReward={14} />

---

## Section 3: How ASP.NET Core DI Works

In ASP.NET Core, DI is built-in and works in three steps:

### 1. Register Services (Startup)
```csharp
builder.Services.AddScoped<IUserRepository, UserRepository>();
builder.Services.AddSingleton<ILogger, ConsoleLogger>();
```

### 2. Request Dependencies (Constructor)
```csharp
public class UsersController : ControllerBase
{
    private readonly IUserRepository _repository;
    public UsersController(IUserRepository repository)
    {
        _repository = repository;  // Automatically injected!
    }
}
```

### 3. Container Resolves (Runtime)
The DI container sees what's needed, looks up the registration, and injects it.

<DependencyInjectionVisualizer mode="intermediate" />

### Key Takeaways

<InfoBox type="tip" title="Remember">
-  **IoC** inverts control - dependencies flow IN instead of being created
-  **Constructor injection** is the preferred DI method
-  **Program to interfaces** - depend on abstractions
- ️ **ASP.NET Core** has DI built-in via `IServiceCollection`
</InfoBox>

<ProgressCheckpoint section="di-how-works" xpReward={13} />
