# Dependency Injection Fundamentals

At its core, Dependency Injection implements the **Inversion of Control** principle through a **container** that manages object creation, lifetime, and dependency resolution.

---

## Section 1: The Composition Root Pattern

The **Composition Root** is the single location in your application where the object graph is composed. In ASP.NET Core, this is `Program.cs`.

```csharp
// Program.cs - The Composition Root
var builder = WebApplication.CreateBuilder(args);

// ALL service registrations happen here
builder.Services.AddScoped<IUserRepository, UserRepository>();
builder.Services.AddScoped<IEmailService, SmtpEmailService>();
builder.Services.AddScoped<IUserService, UserService>();

var app = builder.Build();
// After this point, no more registrations - only resolution
```

<InfoBox type="important">
  **Critical Rule:** The Composition Root is the ONLY place where you should
  reference concrete implementations. Everywhere else, depend only on interfaces.
</InfoBox>

<ProgressCheckpoint section="di-what-is" xpReward={20} />

---

## Section 2: Service Descriptors and Resolution

When you call `AddScoped<IUserRepository, UserRepository>()`, the container creates a `ServiceDescriptor`:

```csharp
var descriptor = new ServiceDescriptor(
    serviceType: typeof(IUserRepository),
    implementationType: typeof(UserRepository),
    lifetime: ServiceLifetime.Scoped
);
```

### Constructor Selection Strategy

The built-in container:
1. Finds all **public constructors**
2. Checks if all parameters can be resolved
3. Selects the constructor with the **most parameters** that can be satisfied

<DIContainerExplorer mode="advanced" />

### Open Generics Registration

```csharp
// Registration
builder.Services.AddScoped(typeof(IRepository<>), typeof(Repository<>));

// Now any IRepository<T> resolves to Repository<T>
public class ProductsController
{
    public ProductsController(IRepository<Product> products) { }  // ✅ Works!
}
```

<ProgressCheckpoint section="di-why-matters" xpReward={20} />

---

## Section 3: Advanced Patterns and Anti-Patterns

### Decorator Pattern with DI

```csharp
// Base implementation
public class UserRepository : IUserRepository { /* ... */ }

// Caching decorator
public class CachedUserRepository : IUserRepository
{
    private readonly IUserRepository _inner;
    private readonly IMemoryCache _cache;

    public User GetById(int id)
    {
        return _cache.GetOrCreate($"user:{id}",
            entry => _inner.GetById(id));
    }
}
```

### Anti-Pattern: Service Locator

```csharp
// ❌ Don't do this - hidden dependencies!
public class OrderService
{
    private readonly IServiceProvider _provider;
    public void Process(Order order)
    {
        var payment = _provider.GetRequiredService<IPaymentService>();
    }
}
```

<DIPatternShowcase pattern="service-locator" mode="advanced" />

### Key Takeaways

<InfoBox type="tip" title="Remember">
-  **Composition Root** - Single location for all registrations
-  **Resolution algorithm** - Constructor selection & recursive resolution
-  **Open generics** - `typeof(IRepository<>)` handles all `IRepository<T>`
-  **Decorators** - Wrap implementations to add cross-cutting concerns
-  **ValidateOnBuild** - Catch DI errors at startup
</InfoBox>

<ProgressCheckpoint section="di-how-works" xpReward={20} />
