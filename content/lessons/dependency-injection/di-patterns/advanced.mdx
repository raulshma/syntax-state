# DI Patterns & Best Practices: Advanced

Let's explore advanced DI patterns, composition strategies, and architectural considerations for enterprise applications.

---

## Section 1: Injection Patterns

### The Composition Root

The **Composition Root** is the single location where the entire object graph is composed. In ASP.NET Core, this is `Program.cs`.

```csharp
// Program.cs - THE Composition Root
var builder = WebApplication.CreateBuilder(args);

// ALL registrations here - organized by feature
builder.Services.AddInfrastructure(builder.Configuration);
builder.Services.AddApplication();
builder.Services.AddPresentation();

var app = builder.Build();
```

<InfoBox type="important">
  **Rule:** Reference concrete implementations **only** in the Composition Root.
  Everywhere else, depend only on abstractions.
</InfoBox>

### Layered Registration

```csharp
// Infrastructure layer registration
public static class InfrastructureServiceExtensions
{
    public static IServiceCollection AddInfrastructure(
        this IServiceCollection services,
        IConfiguration configuration)
    {
        services.AddDbContext<AppDbContext>(options =>
            options.UseSqlServer(configuration.GetConnectionString("Default")));

        services.AddScoped<IUserRepository, UserRepository>();
        services.AddScoped<IUnitOfWork, UnitOfWork>();

        services.Configure<EmailOptions>(configuration.GetSection("Email"));
        services.AddTransient<IEmailService, SmtpEmailService>();

        return services;
    }
}

// Application layer registration
public static class ApplicationServiceExtensions
{
    public static IServiceCollection AddApplication(
        this IServiceCollection services)
    {
        services.AddScoped<IUserService, UserService>();
        services.AddScoped<IOrderService, OrderService>();

        // MediatR for CQRS
        services.AddMediatR(cfg =>
            cfg.RegisterServicesFromAssembly(typeof(CreateUserCommand).Assembly));

        // FluentValidation
        services.AddValidatorsFromAssembly(typeof(CreateUserValidator).Assembly);

        return services;
    }
}
```

### Advanced Factory Patterns

#### Abstract Factory

```csharp
public interface INotificationChannelFactory
{
    INotificationChannel Create(NotificationPreference preference);
}

public class NotificationChannelFactory : INotificationChannelFactory
{
    private readonly IServiceProvider _provider;

    public NotificationChannelFactory(IServiceProvider provider)
    {
        _provider = provider;
    }

    public INotificationChannel Create(NotificationPreference pref)
    {
        return pref.Channels
            .Select(channel => ResolveChannel(channel))
            .Aggregate<INotificationChannel, INotificationChannel>(
                new NullChannel(),
                (acc, next) => new CompositeChannel(acc, next));
    }

    private INotificationChannel ResolveChannel(ChannelType type) => type switch
    {
        ChannelType.Email => _provider.GetRequiredService<EmailChannel>(),
        ChannelType.Sms => _provider.GetRequiredService<SmsChannel>(),
        ChannelType.Push => _provider.GetRequiredService<PushChannel>(),
        _ => new NullChannel()
    };
}
```

#### Func<T> Factory

For simple scenarios, inject `Func<T>` instead of `IServiceProvider`:

```csharp
// Registration
builder.Services.AddTransient<ExpensiveService>();
builder.Services.AddSingleton<Func<ExpensiveService>>(provider =>
    () => provider.GetRequiredService<ExpensiveService>());

// Usage
public class MyService
{
    private readonly Func<ExpensiveService> _factory;

    public MyService(Func<ExpensiveService> factory)
    {
        _factory = factory;
    }

    public void DoWork()
    {
        using var expensive = _factory();
        expensive.Process();
    }
}
```

### Decorator Chain Pattern

Build a processing pipeline using decorators:

```csharp
// Base behavior
public class CreateUserHandler : IRequestHandler<CreateUserCommand, User>
{
    public async Task<User> Handle(CreateUserCommand cmd) =>
        new User { Email = cmd.Email };
}

// Validation decorator
public class ValidationDecorator<TRequest, TResponse>
    : IRequestHandler<TRequest, TResponse>
{
    private readonly IRequestHandler<TRequest, TResponse> _inner;
    private readonly IValidator<TRequest> _validator;

    public async Task<TResponse> Handle(TRequest request)
    {
        await _validator.ValidateAndThrowAsync(request);
        return await _inner.Handle(request);
    }
}

// Logging decorator
public class LoggingDecorator<TRequest, TResponse>
    : IRequestHandler<TRequest, TResponse>
{
    private readonly IRequestHandler<TRequest, TResponse> _inner;
    private readonly ILogger _logger;

    public async Task<TResponse> Handle(TRequest request)
    {
        _logger.LogInformation("Handling {Request}", typeof(TRequest).Name);
        var result = await _inner.Handle(request);
        _logger.LogInformation("Handled {Request}", typeof(TRequest).Name);
        return result;
    }
}

// Registration with Scrutor
builder.Services.AddScoped(typeof(IRequestHandler<,>), typeof(CreateUserHandler));
builder.Services.Decorate(typeof(IRequestHandler<,>), typeof(ValidationDecorator<,>));
builder.Services.Decorate(typeof(IRequestHandler<,>), typeof(LoggingDecorator<,>));
```

<ProgressCheckpoint section="injection-patterns" xpReward={20} />

---

## Section 2: Common Anti-Patterns

### Service Locator Anti-Pattern

<DIPatternShowcase pattern="service-locator" mode="advanced" />

The Service Locator pattern hides dependencies and creates runtime coupling:

```csharp
// ‚ùå ANTI-PATTERN
public class OrderProcessor
{
    private readonly IServiceProvider _provider;

    public async Task ProcessAsync(Order order)
    {
        // Dependencies hidden - not visible in constructor
        var validator = _provider.GetRequiredService<IOrderValidator>();
        var payment = _provider.GetRequiredService<IPaymentService>();
        var inventory = _provider.GetRequiredService<IInventoryService>();

        // Runtime failure if service not registered
    }
}
```

**Problems:**

1. **Hidden dependencies** - Can't see what the class needs
2. **Runtime failures** - Missing services discovered at runtime, not compile-time
3. **Testing complexity** - Must mock `IServiceProvider` instead of actual dependencies
4. **Tight coupling** - Direct dependency on DI container

**When acceptable:**

- Factories that need runtime type resolution
- Middleware that creates scopes
- Background services managing scoped lifetimes

### Captive Dependency

A captive dependency occurs when a longer-lived service captures a shorter-lived dependency:

```csharp
// ‚ùå ANTI-PATTERN: Singleton capturing Scoped
public class CachingService  // Registered as Singleton
{
    private readonly AppDbContext _context;  // DbContext is Scoped!

    public CachingService(AppDbContext context)
    {
        _context = context;  // Captured! Will live for app lifetime
    }
}
```

**Fix with IServiceScopeFactory:**

```csharp
// ‚úÖ CORRECT
public class CachingService
{
    private readonly IServiceScopeFactory _scopeFactory;

    public CachingService(IServiceScopeFactory scopeFactory)
    {
        _scopeFactory = scopeFactory;
    }

    public async Task<User> GetUserAsync(int id)
    {
        using var scope = _scopeFactory.CreateScope();
        var context = scope.ServiceProvider.GetRequiredService<AppDbContext>();
        return await context.Users.FindAsync(id);
    }
}
```

### Circular Dependencies

```csharp
// ‚ùå ANTI-PATTERN
public class ServiceA
{
    public ServiceA(ServiceB b) { }
}

public class ServiceB
{
    public ServiceB(ServiceA a) { }  // Circular!
}
```

**Solutions:**

1. **Introduce mediator/event bus:**

```csharp
public class ServiceA
{
    private readonly IMediator _mediator;

    public async Task DoWorkAsync()
    {
        await _mediator.Send(new ServiceBCommand());
    }
}
```

2. **Use Lazy<T>:**

```csharp
public class ServiceA
{
    private readonly Lazy<ServiceB> _serviceB;

    public ServiceA(Lazy<ServiceB> serviceB)
    {
        _serviceB = serviceB;
    }

    public void DoWork()
    {
        _serviceB.Value.Process();  // Resolved on demand
    }
}
```

### Constructor Over-Injection

```csharp
// ‚ùå ANTI-PATTERN: God class
public class OrderService
{
    public OrderService(
        IOrderRepository orders,
        IUserRepository users,
        IProductRepository products,
        IInventoryService inventory,
        IPaymentService payment,
        IShippingService shipping,
        IEmailService email,
        INotificationService notifications,
        IAnalyticsService analytics,
        ILogger<OrderService> logger)  // 10 dependencies!
    { }
}
```

**Fix with Facade pattern:**

```csharp
// ‚úÖ BETTER: Introduce facades
public interface IOrderFulfillment
{
    Task FulfillAsync(Order order);
}

public class OrderService
{
    private readonly IOrderRepository _orders;
    private readonly IOrderFulfillment _fulfillment;
    private readonly ILogger<OrderService> _logger;

    public OrderService(
        IOrderRepository orders,
        IOrderFulfillment fulfillment,
        ILogger<OrderService> logger)
    {
        _orders = orders;
        _fulfillment = fulfillment;
        _logger = logger;
    }
}
```

<ProgressCheckpoint section="common-anti-patterns" xpReward={20} />

---

## Section 3: Best Practices

### Conditional Registration

Register different implementations based on environment or configuration:

```csharp
// Environment-based
if (builder.Environment.IsDevelopment())
{
    builder.Services.AddScoped<IEmailService, FakeEmailService>();
}
else
{
    builder.Services.AddScoped<IEmailService, SmtpEmailService>();
}

// Feature flag-based
var features = builder.Configuration.GetSection("Features");
if (features.GetValue<bool>("UseNewPaymentGateway"))
{
    builder.Services.AddScoped<IPaymentGateway, StripeGateway>();
}
else
{
    builder.Services.AddScoped<IPaymentGateway, LegacyGateway>();
}

// Assembly scanning with conditional filtering
builder.Services.Scan(scan => scan
    .FromAssemblyOf<IApplicationService>()
    .AddClasses(classes => classes.Where(type =>
        !type.Name.EndsWith("Deprecated")))
    .AsImplementedInterfaces()
    .WithScopedLifetime());
```

### Integration Testing with DI

#### WebApplicationFactory Customization

```csharp
public class CustomWebApplicationFactory : WebApplicationFactory<Program>
{
    protected override void ConfigureWebHost(IWebHostBuilder builder)
    {
        builder.ConfigureServices(services =>
        {
            // Remove production database
            var dbDescriptor = services.Single(
                d => d.ServiceType == typeof(DbContextOptions<AppDbContext>));
            services.Remove(dbDescriptor);

            // Add test database
            services.AddDbContext<AppDbContext>(options =>
            {
                options.UseInMemoryDatabase("TestDb");
            });

            // Replace external services with fakes
            services.RemoveAll<IEmailService>();
            services.AddScoped<IEmailService, FakeEmailService>();
        });
    }
}

// Test usage
public class UserApiTests : IClassFixture<CustomWebApplicationFactory>
{
    private readonly HttpClient _client;

    public UserApiTests(CustomWebApplicationFactory factory)
    {
        _client = factory.CreateClient();
    }

    [Fact]
    public async Task CreateUser_ReturnsCreated()
    {
        var response = await _client.PostAsJsonAsync("/api/users",
            new { Email = "test@example.com" });

        Assert.Equal(HttpStatusCode.Created, response.StatusCode);
    }
}
```

### Module Pattern

Organize registrations into cohesive modules:

```csharp
public interface IServiceModule
{
    void RegisterServices(IServiceCollection services, IConfiguration configuration);
}

public class UserModule : IServiceModule
{
    public void RegisterServices(IServiceCollection services, IConfiguration config)
    {
        services.AddScoped<IUserRepository, UserRepository>();
        services.AddScoped<IUserService, UserService>();
        services.AddScoped<IUserValidator, UserValidator>();
    }
}

public class EmailModule : IServiceModule
{
    public void RegisterServices(IServiceCollection services, IConfiguration config)
    {
        services.Configure<EmailOptions>(config.GetSection("Email"));
        services.AddTransient<IEmailService, SmtpEmailService>();
        services.AddTransient<IEmailTemplateEngine, RazorTemplateEngine>();
    }
}

// Registration extension
public static class ModuleExtensions
{
    public static IServiceCollection AddModules(
        this IServiceCollection services,
        IConfiguration configuration,
        params IServiceModule[] modules)
    {
        foreach (var module in modules)
        {
            module.RegisterServices(services, configuration);
        }
        return services;
    }
}

// Usage
builder.Services.AddModules(
    builder.Configuration,
    new UserModule(),
    new EmailModule(),
    new PaymentModule());
```

### Anti-Pattern Detection Checklist

| Smell                      | Detection                      | Fix                      |
| :------------------------- | :----------------------------- | :----------------------- |
| Service Locator            | `IServiceProvider` in app code | Constructor injection    |
| Captive Dependency         | Scoped in singleton            | `IServiceScopeFactory`   |
| Constructor Over-Injection | 5+ dependencies                | Split class, use facade  |
| Circular Dependency        | A‚ÜíB‚ÜíA                          | Introduce mediator, lazy |
| Hidden Dependency          | Static service calls           | Explicit injection       |
| Ambient Context            | `HttpContext.Current`          | `IHttpContextAccessor`   |

### Validation at Startup

Catch configuration errors early:

```csharp
builder.Services.AddOptions<EmailOptions>()
    .Bind(builder.Configuration.GetSection("Email"))
    .ValidateDataAnnotations()
    .ValidateOnStart();

public class EmailOptions
{
    [Required]
    public string SmtpHost { get; set; } = "";

    [Range(1, 65535)]
    public int Port { get; set; } = 587;

    [EmailAddress]
    public string FromAddress { get; set; } = "";
}
```

## Key Takeaways

-  **Composition Root** - Single registration location, organized by feature
-  **Decorator chains** - Build cross-cutting behavior pipelines
-  **Conditional registration** - Environment/feature-based implementations
- üß™ **WebApplicationFactory** - Replace services for integration testing
-  **Module pattern** - Organize registrations into cohesive units
-  **Anti-pattern detection** - Know the smells and their fixes
- Ô∏è **Captive dependencies** - Use `IServiceScopeFactory` for scope management
-  **Circular dependencies** - Break with mediator or `Lazy<T>`

<ProgressCheckpoint section="best-practices" xpReward={20} />
