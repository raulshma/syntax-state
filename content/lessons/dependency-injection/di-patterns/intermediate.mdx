# DI Patterns & Best Practices

Let's explore common DI patterns, anti-patterns to avoid, and practical guidelines for writing maintainable, testable code.

---

## Section 1: Injection Patterns

### Constructor Injection Best Practices

List ALL required dependencies in the constructor:

```csharp
public class OrderService
{
    private readonly IOrderRepository _orderRepo;
    private readonly IPaymentService _payment;
    private readonly ILogger<OrderService> _logger;

    public OrderService(
        IOrderRepository orderRepo,
        IPaymentService payment,
        ILogger<OrderService> logger)
    {
        _orderRepo = orderRepo ?? throw new ArgumentNullException(nameof(orderRepo));
        _payment = payment ?? throw new ArgumentNullException(nameof(payment));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }
}
```

<DIPatternShowcase pattern="constructor-injection" mode="intermediate" />

### Guard Clauses vs Null-Forgiving

```csharp
// Option 1: Guard clauses (verbose but clear)
public OrderService(IOrderRepository repo)
{
    _repo = repo ?? throw new ArgumentNullException(nameof(repo));
}

// Option 2: C# 11+ required keyword
public class OrderService
{
    private readonly IOrderRepository _repo;

    public required IOrderRepository Repo { init => _repo = value; }
}
```

### The Options Pattern

Use `IOptions<T>` for configuration instead of raw values:

<DIPatternShowcase pattern="options-pattern" mode="intermediate" />

```csharp
// Define options class
public class EmailOptions
{
    public string SmtpHost { get; set; } = "smtp.example.com";
    public int Port { get; set; } = 587;
    public string FromAddress { get; set; } = "";
}

// Register
builder.Services.Configure<EmailOptions>(
    builder.Configuration.GetSection("Email"));

// Inject
public class EmailService
{
    private readonly EmailOptions _options;

    public EmailService(IOptions<EmailOptions> options)
    {
        _options = options.Value;
    }
}
```

#### Options Interfaces Compared

| Interface             | When to Use                                      |
| :-------------------- | :----------------------------------------------- |
| `IOptions<T>`         | Singleton options, read once                     |
| `IOptionsSnapshot<T>` | Scoped, updates per request (reloadable configs) |
| `IOptionsMonitor<T>`  | Singleton but watches for changes                |

### Factory Pattern with DI

Use factories for runtime object creation:

<DIPatternShowcase pattern="factory-pattern" mode="intermediate" />

```csharp
// Factory interface
public interface IReportFactory
{
    IReport Create(ReportType type);
}

// Factory implementation
public class ReportFactory : IReportFactory
{
    private readonly IServiceProvider _provider;

    public ReportFactory(IServiceProvider provider)
    {
        _provider = provider;
    }

    public IReport Create(ReportType type) => type switch
    {
        ReportType.Sales => _provider.GetRequiredService<SalesReport>(),
        ReportType.Inventory => _provider.GetRequiredService<InventoryReport>(),
        _ => throw new ArgumentException("Unknown report type")
    };
}

// Usage
public class ReportController
{
    private readonly IReportFactory _factory;

    public ReportController(IReportFactory factory)
    {
        _factory = factory;
    }

    [HttpGet("{type}")]
    public IActionResult Generate(ReportType type)
    {
        var report = _factory.Create(type);
        return Ok(report.Generate());
    }
}
```

<ProgressCheckpoint section="injection-patterns" xpReward={13} />

---

## Section 2: Common Anti-Patterns

### Service Locator Anti-Pattern

**Avoid** injecting `IServiceProvider` and resolving manually:

<DIPatternShowcase pattern="service-locator" mode="intermediate" />

```csharp
// ‚ùå ANTI-PATTERN: Service Locator
public class OrderService
{
    private readonly IServiceProvider _provider;

    public OrderService(IServiceProvider provider)
    {
        _provider = provider;
    }

    public void Process(Order order)
    {
        // Hidden dependencies - not visible in constructor!
        var payment = _provider.GetRequiredService<IPaymentService>();
        var email = _provider.GetRequiredService<IEmailService>();
    }
}
```

**Problems:**

1. Dependencies are **hidden** (not visible in constructor)
2. **Harder to test** (need to mock IServiceProvider)
3. **Runtime failures** instead of compile-time errors

#### When Service Locator is Acceptable

The ONLY acceptable places:

- **Factories** that create objects at runtime
- **Middleware** that needs scoped services
- **Background services** that need to create scopes

```csharp
// ‚úÖ OK: Factory using IServiceProvider
public class NotifierFactory : INotifierFactory
{
    private readonly IServiceProvider _provider;

    public INotifier Create(string type) => type switch
    {
        "email" => _provider.GetRequiredService<EmailNotifier>(),
        "sms" => _provider.GetRequiredService<SmsNotifier>(),
        _ => throw new ArgumentException("Unknown type")
    };
}
```

### Captive Dependency

```csharp
// ‚ùå Scoped service captured in singleton
public class MySingleton
{
    private readonly MyScopedService _scoped;  // WRONG!
}
```

**Fix:** Use `IServiceScopeFactory` in singletons:

```csharp
// ‚úÖ CORRECT: Create scope when needed
public class MySingleton
{
    private readonly IServiceScopeFactory _scopeFactory;

    public MySingleton(IServiceScopeFactory scopeFactory)
    {
        _scopeFactory = scopeFactory;
    }

    public void DoWork()
    {
        using var scope = _scopeFactory.CreateScope();
        var scoped = scope.ServiceProvider.GetRequiredService<MyScopedService>();
        scoped.Process();
    }
}
```

### Circular Dependency

```csharp
// ‚ùå A depends on B, B depends on A
public class ServiceA { public ServiceA(ServiceB b) { } }
public class ServiceB { public ServiceB(ServiceA a) { } }  // Boom!
```

**Fix:** Introduce a third service or use `Lazy<T>`:

```csharp
// ‚úÖ Break cycle with Lazy<T>
public class ServiceA
{
    private readonly Lazy<ServiceB> _serviceB;

    public ServiceA(Lazy<ServiceB> serviceB)
    {
        _serviceB = serviceB;
    }
}
```

### Constructor Over-Injection

```csharp
// ‚ùå Too many dependencies = class does too much
public class GodClass
{
    public GodClass(IA a, IB b, IC c, ID d, IE e, IF f, IG g) { }
}
```

**Fix:** Split into smaller classes (Single Responsibility Principle).

<ProgressCheckpoint section="common-anti-patterns" xpReward={14} />

---

## Section 3: Best Practices

### Testing with DI

Constructor injection makes testing straightforward:

```csharp
public class UserServiceTests
{
    [Fact]
    public async Task CreateUser_SendsWelcomeEmail()
    {
        // Arrange - Create mocks
        var mockRepo = new Mock<IUserRepository>();
        var mockEmail = new Mock<IEmailService>();

        // Inject mocks
        var service = new UserService(
            mockRepo.Object,
            mockEmail.Object);

        // Act
        await service.CreateUserAsync("test@example.com");

        // Assert
        mockEmail.Verify(
            e => e.SendAsync("test@example.com", It.IsAny<string>()),
            Times.Once);
    }
}
```

### Organizing Service Registrations

Group related services together:

```csharp
// Program.cs
var builder = WebApplication.CreateBuilder(args);

// Infrastructure services
builder.Services.AddDbContext<AppDbContext>(options =>
    options.UseSqlServer(builder.Configuration.GetConnectionString("Default")));
builder.Services.AddScoped<IUserRepository, UserRepository>();
builder.Services.AddScoped<IOrderRepository, OrderRepository>();

// Application services
builder.Services.AddScoped<IUserService, UserService>();
builder.Services.AddScoped<IOrderService, OrderService>();

// External services
builder.Services.Configure<EmailOptions>(builder.Configuration.GetSection("Email"));
builder.Services.AddTransient<IEmailService, SmtpEmailService>();

var app = builder.Build();
```

### Extension Methods for Registration

Create extension methods for cleaner registration:

```csharp
public static class ServiceCollectionExtensions
{
    public static IServiceCollection AddApplicationServices(
        this IServiceCollection services)
    {
        services.AddScoped<IUserService, UserService>();
        services.AddScoped<IOrderService, OrderService>();
        services.AddScoped<IProductService, ProductService>();
        return services;
    }

    public static IServiceCollection AddInfrastructure(
        this IServiceCollection services,
        IConfiguration configuration)
    {
        services.AddDbContext<AppDbContext>(options =>
            options.UseSqlServer(configuration.GetConnectionString("Default")));

        services.AddScoped<IUserRepository, UserRepository>();
        services.AddScoped<IOrderRepository, OrderRepository>();

        return services;
    }
}

// Usage in Program.cs
builder.Services.AddApplicationServices();
builder.Services.AddInfrastructure(builder.Configuration);
```

### Conditional Registration

Register different implementations based on environment:

```csharp
if (builder.Environment.IsDevelopment())
{
    builder.Services.AddScoped<IEmailService, FakeEmailService>();
}
else
{
    builder.Services.AddScoped<IEmailService, SmtpEmailService>();
}
```

### Validation at Startup

Validate configuration at startup:

```csharp
builder.Services.AddOptions<EmailOptions>()
    .Bind(builder.Configuration.GetSection("Email"))
    .ValidateDataAnnotations()
    .ValidateOnStart();

public class EmailOptions
{
    [Required]
    public string SmtpHost { get; set; } = "";

    [Range(1, 65535)]
    public int Port { get; set; } = 587;

    [EmailAddress]
    public string FromAddress { get; set; } = "";
}
```

## Key Takeaways

-  **Constructor injection** - All dependencies explicit and visible
- Ô∏è **Options pattern** - Use `IOptions<T>` for configuration
-  **Avoid Service Locator** - Except in factories/middleware
-  **Factory pattern** - For runtime object creation
- üß™ **Easy testing** - Inject mocks via constructor
-  **Extension methods** - Organize registrations cleanly
-  **Validate early** - Use ValidateOnStart for options

<ProgressCheckpoint section="best-practices" xpReward={13} />
