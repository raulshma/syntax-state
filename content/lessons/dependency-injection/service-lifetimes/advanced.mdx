# Service Lifetimes: Deep Dive

Let's explore the internals of service lifetimes, advanced patterns, and how to handle complex scenarios involving lifetime management.

---

## Section 1: Lifetime Internals

<ServiceLifetimeDemo mode="advanced" showComparison />

### Singleton Storage

Singletons are stored in the **root container**:

```csharp
// Simplified internal structure
internal class ServiceProvider
{
    private readonly Dictionary<Type, object> _singletons = new();
    
    public object GetSingleton(Type type, Func<object> factory)
    {
        lock (_lock)
        {
            if (!_singletons.TryGetValue(type, out var instance))
            {
                instance = factory();
                _singletons[type] = instance;
            }
            return instance;
        }
    }
}
```

**Key Points:**
- Thread-safe via locking
- Never disposed until app shutdown
- Shared across all scopes and threads

### Scoped Storage

Scoped services live in a **service scope** and are disposed when the scope ends.

<ProgressCheckpoint section="lifetime-overview" xpReward={20} />

---

## Section 2: Captive Dependencies

A **captive dependency** occurs when a shorter-lived service is captured by a longer-lived service:

```csharp
// ‚ö†Ô∏è Scoped captured in Singleton
public class SingletonService
{
    private readonly ScopedService _scoped;
    public SingletonService(ScopedService scoped)
    {
        _scoped = scoped;  // This instance is now IMMORTAL
    }
}
```

### Detection with ValidateScopes

```csharp
builder.Host.UseDefaultServiceProvider(options =>
{
    options.ValidateScopes = builder.Environment.IsDevelopment();
    options.ValidateOnBuild = builder.Environment.IsDevelopment();
});
```

### Solution: IServiceScopeFactory

```csharp
public class BackgroundWorker : BackgroundService
{
    private readonly IServiceScopeFactory _scopeFactory;
    
    protected override async Task ExecuteAsync(CancellationToken ct)
    {
        using (var scope = _scopeFactory.CreateScope())
        {
            var dbContext = scope.ServiceProvider
                .GetRequiredService<AppDbContext>();
            await ProcessBatchAsync(dbContext, ct);
        }
    }
}
```

<ProgressCheckpoint section="lifetime-comparison" xpReward={20} />

---

## Section 3: Advanced Patterns

### Thread Safety Requirements

| Lifetime  | Thread Safety Required? | Why?                                   |
| :-------- | :---------------------- | :------------------------------------- |
| Singleton |  **Yes, always**      | Multiple threads access simultaneously |
| Scoped    | Ô∏è Usually no           | Typically one thread per HTTP request  |
| Transient | Ô∏è Usually no           | New instance per injection             |

### Keyed Services (.NET 8+)

```csharp
// Registration
builder.Services.AddKeyedSingleton<ICache, RedisCache>("redis");
builder.Services.AddKeyedSingleton<ICache, MemoryCache>("memory");

// Constructor injection with attribute
public class CacheController
{
    public CacheController(
        [FromKeyedServices("redis")] ICache primaryCache,
        [FromKeyedServices("memory")] ICache fallbackCache)
    {
        // Each key maintains its own instance tracking
    }
}
```

### Key Takeaways

<InfoBox type="tip" title="Remember">
-  **Captive dependencies** - Never inject shorter lifetime into longer
-  **IServiceScopeFactory** - Create scopes in singletons/background services
- üßµ **Thread safety** - Required for singletons, usually not for scoped
-  **Keyed services** - .NET 8+ feature for multiple implementations
- Ô∏è **Disposal** - Container handles `IDisposable`/`IAsyncDisposable`
</InfoBox>

<ProgressCheckpoint section="lifetime-pitfalls" xpReward={20} />
