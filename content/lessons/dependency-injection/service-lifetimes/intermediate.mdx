# Service Lifetimes: Singleton, Scoped, Transient

Understanding service lifetimes is crucial for building reliable ASP.NET Core applications. Each lifetime determines **when instances are created** and **how long they live**.

---

## Section 1: The Three Lifetimes Compared

<ServiceLifetimeDemo mode="intermediate" showComparison />

### Singleton Lifetime

A single instance is created on **first request** and reused for the **entire application lifetime**.

```csharp
builder.Services.AddSingleton<IConfigurationService, ConfigurationService>();
```

**Characteristics:**
- Created once, lives until app shuts down
- Shared across all requests and all threads
- Must be **thread-safe**

**Ideal Use Cases:**
| Service | Why Singleton? |
|:--------|:---------------|
| `ILogger<T>` | Thread-safe, write to shared output |
| `IConfiguration` | Read-only, doesn't change at runtime |
| `IMemoryCache` | Application-wide caching |

### Scoped Lifetime

A new instance is created **once per scope** (typically once per HTTP request).

```csharp
builder.Services.AddScoped<AppDbContext>();
```

**Characteristics:**
- Created at the start of a scope (request)
- Shared within that scope
- Disposed at the end of the scope

<ProgressCheckpoint section="lifetime-overview" xpReward={13} />

---

## Section 2: Instance Creation Behavior

Let's trace what happens across multiple HTTP requests:

```csharp
builder.Services.AddSingleton<SingletonService>();
builder.Services.AddScoped<ScopedService>();
builder.Services.AddTransient<TransientService>();
```

### Request 1:
| Service          | Instance Created?       | Which Instance?      |
| :--------------- | :---------------------- | :------------------- |
| SingletonService |  Yes (first time)     | `#1`                 |
| ScopedService    |  Yes                  | `#1` (for Request 1) |
| TransientService |  Yes (each injection) | `#1, #2, #3...`      |

### Request 2:
| Service          | Instance Created? | Which Instance?          |
| :--------------- | :---------------- | :----------------------- |
| SingletonService |  No (reuses)    | `#1` (same as before)    |
| ScopedService    |  Yes            | `#2` (new for Request 2) |
| TransientService |  Yes            | `#4, #5, #6...` (new)    |

<InfoBox type="important">
  **Key Insight:** Singleton instances are **reused**, Scoped instances are
  **shared within a request**, Transient instances are **always new**.
</InfoBox>

<ProgressCheckpoint section="lifetime-comparison" xpReward={14} />

---

## Section 3: Common Mistakes and Best Practices

###  Injecting Scoped into Singleton

```csharp
// BAD: Scoped service captured in singleton!
public class MySingleton
{
    private readonly ScopedService _scoped;  // Lives forever now!
    public MySingleton(ScopedService scoped) => _scoped = scoped;
}
```

This creates a **captive dependency** - the scoped service is trapped and never refreshed.

###  DbContext as Singleton

```csharp
// NEVER do this!
builder.Services.AddSingleton<AppDbContext>();  // üíÄ
```

DbContext is not thread-safe and tracks entities - it MUST be Scoped.

### Best Practices

1. **Default to Scoped** - Most services should be scoped
2. **Singleton for configuration/logging** - Stateless, shared services
3. **Transient for stateless utilities** - Quick operations
4. **Never inject shorter lifetime into longer** - Scoped ‚Üí Singleton = BAD

### Key Takeaways

<InfoBox type="tip" title="Remember">
-  **Singleton** - One instance forever, must be thread-safe
-  **Scoped** - One instance per request, the most common choice
-  **Transient** - New instance every injection, for lightweight services
- Ô∏è **Never** inject Scoped into Singleton
</InfoBox>

<ProgressCheckpoint section="lifetime-pitfalls" xpReward={13} />
