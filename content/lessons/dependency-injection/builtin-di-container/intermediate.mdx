# The Built-in DI Container

The ASP.NET Core DI container (`Microsoft.Extensions.DependencyInjection`) provides multiple ways to register services, from simple interface-to-implementation mappings to factory-based registrations.

---

## Section 1: IServiceCollection Methods

The `IServiceCollection` interface provides methods for all three lifetimes:

<DIContainerExplorer mode="intermediate" />

### Basic Registration Forms

```csharp
// Form 1: Interface → Implementation
builder.Services.AddScoped<IUserRepository, UserRepository>();

// Form 2: Self-registration (implementation only)
builder.Services.AddScoped<UserRepository>();

// Form 3: Instance registration (singletons only)
var logger = new ConsoleLogger();
builder.Services.AddSingleton<ILogger>(logger);

// Form 4: Type objects (open generics)
builder.Services.AddScoped(typeof(IRepository<>), typeof(Repository<>));
```

### Factory-Based Registration

Use a factory when you need runtime logic or access to other services:

```csharp
// Simple factory
builder.Services.AddScoped<IEmailService>(provider =>
{
    return new SmtpEmailService("smtp.example.com", 587);
});

// Factory with dependencies
builder.Services.AddScoped<IUserService>(provider =>
{
    var repository = provider.GetRequiredService<IUserRepository>();
    var logger = provider.GetRequiredService<ILogger<UserService>>();
    return new UserService(repository, logger);
});
```

<InfoBox type="tip">
  Factory-based registration is useful when: Constructor requires runtime values, You need conditional creation logic, or You want to wrap with decorators.
</InfoBox>

<ProgressCheckpoint section="container-basics" xpReward={13} />

---

## Section 2: TryAdd and Multiple Implementations

### TryAdd Methods: Safe Registration

`TryAdd*` methods only register if the service **isn't already registered**:

```csharp
// Always adds (may duplicate)
builder.Services.AddScoped<IEmailService, SmtpEmailService>();

// Only adds if not already registered
builder.Services.TryAddScoped<IEmailService, SmtpEmailService>();
```

### Multiple Implementations

Register multiple implementations of the same interface:

```csharp
builder.Services.AddScoped<INotifier, EmailNotifier>();
builder.Services.AddScoped<INotifier, SmsNotifier>();
builder.Services.AddScoped<INotifier, PushNotifier>();
```

Inject all implementations:

```csharp
public class NotificationService
{
    private readonly IEnumerable<INotifier> _notifiers;

    public NotificationService(IEnumerable<INotifier> notifiers)
    {
        _notifiers = notifiers;  // Gets ALL three notifiers!
    }

    public async Task NotifyAll(string message)
    {
        foreach (var notifier in _notifiers)
        {
            await notifier.SendAsync(message);
        }
    }
}
```

<InfoBox type="important">
When injecting a single `INotifier`, you get the **last registered** implementation. Use `IEnumerable<T>` to get all.
</InfoBox>

<ProgressCheckpoint section="registration-methods" xpReward={14} />

---

## Section 3: Extension Methods and Best Practices

### Extension Method Pattern

Organize registrations into extension methods:

```csharp
// In ServiceCollectionExtensions.cs
public static class ServiceCollectionExtensions
{
    public static IServiceCollection AddUserServices(
        this IServiceCollection services)
    {
        services.AddScoped<IUserRepository, UserRepository>();
        services.AddScoped<IUserService, UserService>();
        services.AddScoped<IUserValidator, UserValidator>();
        return services;
    }
}

// Usage in Program.cs
builder.Services.AddUserServices();
```

### Resolving Services

**In Constructors (Preferred):**
```csharp
public class UserController
{
    public UserController(IUserService service) { }
}
```

**Via IServiceProvider (Avoid in App Code):**
```csharp
// Only use in factories or composition root!
app.Services.GetRequiredService<IUserService>();
app.Services.GetService<IUserService>();  // Returns null if not found
```

### GetRequiredService vs GetService

| Method                    | If Not Found                       |
| :------------------------ | :--------------------------------- |
| `GetRequiredService<T>()` | Throws `InvalidOperationException` |
| `GetService<T>()`         | Returns `null`                     |

Always prefer `GetRequiredService<T>()` - fail fast, clear error messages.

### Key Takeaways

<InfoBox type="tip" title="Remember">
-  **Multiple registration forms** - Interface+impl, self, instance, factory
-  **TryAdd methods** - Register only if not already registered
-  **Multiple implementations** - Use `IEnumerable<T>` to get all
-  **Extension methods** - Organize registrations cleanly
- ️ **GetRequiredService** - Prefer over `GetService` for fail-fast behavior
</InfoBox>

<ProgressCheckpoint section="advanced-registration" xpReward={13} />
