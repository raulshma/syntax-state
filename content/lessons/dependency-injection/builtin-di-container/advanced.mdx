# The Built-in DI Container: Advanced

Let's explore advanced container features including open generics, decorators, custom providers, and the internals of service resolution.

---

## Section 1: Open Generics

Register a generic type definition to handle all closed generic types:

```csharp
// Register open generic
builder.Services.AddScoped(typeof(IRepository<>), typeof(Repository<>));

// Now resolves automatically:
// IRepository<User> → Repository<User>
// IRepository<Product> → Repository<Product>
// IRepository<Order> → Repository<Order>
```

<DIContainerExplorer mode="advanced" />

### Open Generic Implementation

```csharp
public interface IRepository<T> where T : class
{
    Task<T?> GetByIdAsync(int id);
    Task<IList<T>> GetAllAsync();
}

public class Repository<T> : IRepository<T> where T : class
{
    private readonly AppDbContext _context;

    public Repository(AppDbContext context) => _context = context;

    public async Task<T?> GetByIdAsync(int id) =>
        await _context.Set<T>().FindAsync(id);

    public async Task<IList<T>> GetAllAsync() =>
        await _context.Set<T>().ToListAsync();
}
```

<ProgressCheckpoint section="container-basics" xpReward={20} />

---

## Section 2: Decorator Pattern

Decorators wrap existing implementations to add cross-cutting concerns.

### Manual Decoration

```csharp
// Base registration
builder.Services.AddScoped<UserRepository>();

// Decorator wrapping
builder.Services.AddScoped<IUserRepository>(provider =>
{
    var inner = provider.GetRequiredService<UserRepository>();
    var cache = provider.GetRequiredService<IMemoryCache>();
    return new CachedUserRepository(inner, cache);
});
```

### Decorator Implementation Example

```csharp
public class CachedUserRepository : IUserRepository
{
    private readonly IUserRepository _inner;
    private readonly IMemoryCache _cache;

    public CachedUserRepository(IUserRepository inner, IMemoryCache cache)
    {
        _inner = inner;
        _cache = cache;
    }

    public async Task<User?> GetByIdAsync(int id)
    {
        return await _cache.GetOrCreateAsync(
            $"user:{id}",
            async entry =>
            {
                entry.AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(5);
                return await _inner.GetByIdAsync(id);
            });
    }
}
```

### Keyed Services (.NET 8+)

```csharp
// Registration with keys
builder.Services.AddKeyedSingleton<IStorage, LocalStorage>("local");
builder.Services.AddKeyedSingleton<IStorage, S3Storage>("s3");

// Injection via attribute
public class FileController
{
    public FileController(
        [FromKeyedServices("s3")] IStorage primaryStorage,
        [FromKeyedServices("local")] IStorage fallbackStorage)
    { }
}
```

<ProgressCheckpoint section="registration-methods" xpReward={20} />

---

## Section 3: Validation and Debugging

### Enable Build-Time Validation

```csharp
builder.Host.UseDefaultServiceProvider(options =>
{
    options.ValidateScopes = true;     // Detect scope violations
    options.ValidateOnBuild = true;    // Validate at startup
});
```

### Common Validation Errors

| Error                                            | Cause                | Fix                              |
| :----------------------------------------------- | :------------------- | :------------------------------- |
| "No service registered for type X"               | Missing registration | Add `builder.Services.Add*<X>()` |
| "Cannot consume scoped from singleton"           | Captive dependency   | Use `IServiceScopeFactory`       |
| "Multiple constructors accepting all parameters" | Ambiguous ctor       | Use single constructor           |

### Performance Considerations

```csharp
// ❌ Slow: Resolves on every call
public void Process()
{
    var service = _provider.GetRequiredService<IHeavyService>();
    service.DoWork();
}

// ✅ Fast: Inject once via constructor
public Process(IHeavyService service)
{
    _service = service;
}
```

### Lazy Initialization

```csharp
builder.Services.AddScoped<Lazy<IExpensiveService>>(provider =>
    new Lazy<IExpensiveService>(() =>
        provider.GetRequiredService<IExpensiveService>()));

public class MyService
{
    private readonly Lazy<IExpensiveService> _expensive;

    public void DoExpensiveWork()
    {
        _expensive.Value.Process();  // Created on first access
    }
}
```

### Key Takeaways

<InfoBox type="tip" title="Remember">
-  **Open generics** - `typeof(IRepository<>)` handles all `IRepository<T>`
-  **Decorators** - Wrap implementations for caching, logging, etc.
-  **Keyed services** - .NET 8+ feature for named implementations
-  **ValidateOnBuild** - Catch errors at startup, not runtime
-  **Lazy<T>** - Defer expensive service creation until needed
</InfoBox>

<ProgressCheckpoint section="advanced-registration" xpReward={20} />
