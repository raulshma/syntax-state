# Serilog: Structured Logging Made Simple 

Imagine you're a detective investigating a crime. Would you rather have:
-  A plain text note: "Someone took something from somewhere"
-  Structured evidence: `{ "who": "John Doe", "what": "laptop", "where": "Office 301", "when": "2025-12-15 14:30" }`

The second option is **infinitely more useful**, right? That's **Serilog**!

## What is Serilog?

Serilog is a **structured logging library** for .NET that treats logs as data, not just text. Instead of this:

```
[2025-12-15 14:30:00] User John (ID: 123) purchased Product ABC for $49.99
```

Serilog creates this:

```json
{
  "Timestamp": "2025-12-15T14:30:00Z",
  "Level": "Information",
  "UserId": 123,
  "UserName": "John",
  "ProductId": "ABC",
  "Price": 49.99,
  "Message": "User purchased product"
}
```

Now you can **query** your logs like a database! 

<KeyConcept title="Why Serilog?">
While ASP.NET Core has built-in logging, Serilog adds superpowers: structured logging, rich sinks (output destinations), powerful filtering, and seamless integration with modern observability platforms.
</KeyConcept>

<ProgressCheckpoint section="serilog-introduction" xpReward={12} />

## Installing Serilog

Add these NuGet packages:

```bash
dotnet add package Serilog.AspNetCore
dotnet add package Serilog.Sinks.Console
dotnet add package Serilog.Sinks.File
```

### Basic Setup

```csharp
using Serilog;

var builder = WebApplication.CreateBuilder(args);

// Configure Serilog
Log.Logger = new LoggerConfiguration()
    .MinimumLevel.Information()
    .WriteTo.Console()
    .WriteTo.File("logs/app.log", rollingInterval: RollingInterval.Day)
    .CreateLogger();

// Replace built-in logging with Serilog
builder.Host.UseSerilog();

try
{
    Log.Information("Starting web application");
    var app = builder.Build();
    app.Run();
}
catch (Exception ex)
{
    Log.Fatal(ex, "Application terminated unexpectedly");
}
finally
{
    Log.CloseAndFlush();
}
```

<InfoBox type="tip">
**Quick Win**: Add `UseSerilog()` and you instantly get better logging with minimal code!
</InfoBox>

<ProgressCheckpoint section="structured-logging-concepts" xpReward={10} />

## Structured Logging in Action

The magic of Serilog is in **message templates**:

```csharp
public class OrdersController : ControllerBase
{
    private readonly ILogger<OrdersController> _logger;

    [HttpPost]
    public async Task<IActionResult> CreateOrder(CreateOrderRequest request)
    {
        // ❌ Bad: Loses structure
        _logger.LogInformation($"Creating order for {request.CustomerId} with {request.Items.Count} items");

        // ✅ Good: Structured properties
        _logger.LogInformation(
            "Creating order for customer {CustomerId} with {ItemCount} items totaling {TotalAmount:C}",
            request.CustomerId,
            request.Items.Count,
            request.TotalAmount
        );

        // Later you can query: "Show me all orders where TotalAmount > 100"
        // Without structured logging, you'd need regex on text!

        return Ok();
    }
}
```

### Structured Output Example

When you run this, Serilog outputs (in JSON format):

```json
{
  "@t": "2025-12-15T14:30:00.123Z",
  "@l": "Information",
  "@mt": "Creating order for customer {CustomerId} with {ItemCount} items totaling {TotalAmount}",
  "CustomerId": 12345,
  "ItemCount": 3,
  "TotalAmount": 149.99
}
```

Now tools like **Seq**, **Elasticsearch**, or **Azure Application Insights** can search and analyze this!

<ProgressCheckpoint section="sinks-enrichers" xpReward={8} />

## Sinks: Where Logs Go

**Sinks** are output destinations. Serilog has 200+ sinks!

```csharp
Log.Logger = new LoggerConfiguration()
    .WriteTo.Console()                                  // Developer's screen
    .WriteTo.File("logs/app.log")                      // Local files
    .WriteTo.Seq("http://localhost:5341")              // Seq server
    .WriteTo.Elasticsearch(elasticConfig)               // Elasticsearch
    .WriteTo.ApplicationInsights(telemetryConfig)       // Azure
    .CreateLogger();
```

### Popular Sinks

| Sink | Use Case | Example |
|------|----------|---------|
| **Console** | Development | See logs in terminal |
| **File** | Simple apps | `logs/app-20251215.log` |
| **Seq** | Development/staging | Visual log viewer |
| **Elasticsearch** | Production | Powerful search |
| **ApplicationInsights** | Azure apps | Full observability |

## Configuration from appsettings.json

You can configure Serilog in JSON instead of code:

```json
{
  "Serilog": {
    "Using": ["Serilog.Sinks.Console", "Serilog.Sinks.File"],
    "MinimumLevel": {
      "Default": "Information",
      "Override": {
        "Microsoft": "Warning",
        "System": "Warning"
      }
    },
    "WriteTo": [
      { "Name": "Console" },
      {
        "Name": "File",
        "Args": {
          "path": "logs/app.log",
          "rollingInterval": "Day"
        }
      }
    ]
  }
}
```

Then load it:

```csharp
builder.Host.UseSerilog((context, configuration) =>
{
    configuration.ReadFrom.Configuration(context.Configuration);
});
```

<InfoBox type="success">
Now you can change log settings without recompiling!
</InfoBox>

## Real-World Example

```csharp
public class PaymentService
{
    private readonly ILogger<PaymentService> _logger;

    public async Task<PaymentResult> ProcessPayment(PaymentRequest request)
    {
        using (_logger.BeginScope("PaymentProcessing"))
        {
            _logger.LogInformation(
                "Processing payment for order {OrderId}, amount {Amount:C}, method {PaymentMethod}",
                request.OrderId,
                request.Amount,
                request.PaymentMethod
            );

            try
            {
                var result = await _paymentGateway.ChargeAsync(request);
                
                _logger.LogInformation(
                    "Payment successful: TransactionId {TransactionId}, Status {Status}",
                    result.TransactionId,
                    result.Status
                );

                return result;
            }
            catch (PaymentException ex)
            {
                _logger.LogError(ex,
                    "Payment failed for order {OrderId}, reason: {Reason}",
                    request.OrderId,
                    ex.Reason
                );
                throw;
            }
        }
    }
}
```

## Key Takeaways

 Serilog adds structured logging to .NET
 Logs become queryable data, not just text
 Message templates preserve structure: `{PropertyName}`
 Sinks send logs to different destinations
 Configure via code or appsettings.json
 Seamlessly integrates with existing code

<InfoBox type="tip">
**Next Level**: Combine Serilog with **Seq** (free for development) to get a visual log viewer with filtering and searching!
</InfoBox>
