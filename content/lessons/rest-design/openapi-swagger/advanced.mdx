# Advanced OpenAPI: Authentication, Client Generation, and Design-First

Let's explore enterprise-grade OpenAPI features: securing Swagger UI, generating client code, and design-first development.

## Section 1: Adding Authentication to Swagger UI 

### JWT Bearer Token Authentication

```csharp
builder.Services.AddSwaggerGen(options =>
{
    options.AddSecurityDefinition("Bearer", new OpenApiSecurityScheme
    {
        Description = "JWT Authorization header. Enter 'Bearer' [space] and your token.",
        Name = "Authorization",
        In = ParameterLocation.Header,
        Type = SecuritySchemeType.ApiKey,
        Scheme = "Bearer"
    });

    options.AddSecurityRequirement(new OpenApiSecurityRequirement
    {
        {
            new OpenApiSecurityScheme
            {
                Reference = new OpenApiReference
                {
                    Type = ReferenceType.SecurityScheme,
                    Id = "Bearer"
                }
            },
            new List<string>()
        }
    });
});
```

**Result:** A green "Authorize" button appears in Swagger UI! ðŸŸ¢

<ProgressCheckpoint section="jwt-auth" xpReward={10} />

### OAuth 2.0 Authentication

```csharp
options.AddSecurityDefinition("oauth2", new OpenApiSecurityScheme
{
    Type = SecuritySchemeType.OAuth2,
    Flows = new OpenApiOAuthFlows
    {
        AuthorizationCode = new OpenApiOAuthFlow
        {
            AuthorizationUrl = new Uri("https://auth.example.com/authorize"),
            TokenUrl = new Uri("https://auth.example.com/token"),
            Scopes = new Dictionary<string, string>
            {
                { "read", "Read access" },
                { "write", "Write access" }
            }
        }
    }
});
```

<ProgressCheckpoint section="oauth" xpReward={5} />

### API Key Authentication

```csharp
options.AddSecurityDefinition("ApiKey", new OpenApiSecurityScheme
{
    Description = "API Key in header. X-API-Key: {your-api-key}",
    In = ParameterLocation.Header,
    Name = "X-API-Key",
    Type = SecuritySchemeType.ApiKey
});
```

<ProgressCheckpoint section="api-key" xpReward={5} />

---

## Section 2: Client Code Generation ðŸ¤–

### The Power of Automation

OpenAPI's biggest advantage: **machines can read it and generate code!**

**Benefits:**
-  Full TypeScript types
-  Autocomplete in IDE
-  Compile-time error checking
-  Always in sync with API

<ProgressCheckpoint section="codegen-intro" xpReward={5} />


### Using NSwag for TypeScript Generation

```bash
# Install
dotnet tool install -g NSwag.ConsoleCore

# Generate
nswag run nswag.json
```

**Use Generated Client:**
```typescript
import { ApiClient, CreateUserDto } from './api/generated-client';

const client = new ApiClient('https://api.example.com');

// Fully typed!
const newUser: CreateUserDto = {
  name: 'John Doe',
  email: 'john@example.com'
};

const user = await client.users_Create(newUser);
```

<ProgressCheckpoint section="nswag" xpReward={10} />

### Using OpenAPI Generator

```bash
# Install
npm install @openapitools/openapi-generator-cli -g

# Generate TypeScript client
openapi-generator-cli generate \
  -i http://localhost:5001/swagger/v1/swagger.json \
  -g typescript-fetch \
  -o ./src/api/generated

# Generate C# client
openapi-generator-cli generate \
  -i http://localhost:5001/swagger/v1/swagger.json \
  -g csharp \
  -o ./ClientLibrary
```

**Supports 50+ languages:** TypeScript, C#, Java, Python, Go, Ruby, PHP, Kotlin, Swift...

<ProgressCheckpoint section="openapi-generator" xpReward={5} />

---

## Section 3: Design-First vs Code-First 

### Code-First Approach (What We've Been Doing)

1. Write C# controllers
2. Add attributes and XML comments
3. Swagger generates OpenAPI spec
4. Generate client code from spec

**Pros:** Natural for developers, less upfront work
**Cons:** API design happens during coding

<ProgressCheckpoint section="code-first" xpReward={3} />

### Design-First Approach

1. Write OpenAPI spec (YAML/JSON)
2. Review with stakeholders
3. Generate server interfaces
4. Implement the interfaces

**Pros:** API design before coding, stakeholder approval early
**Cons:** More upfront work, learning curve

<ProgressCheckpoint section="design-first" xpReward={3} />

### Design-First Example

```yaml
openapi: 3.0.1
info:
  title: Product API
  version: 1.0.0
paths:
  /api/products:
    get:
      summary: Get all products
      responses:
        '200':
          description: Success
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/Product'
components:
  schemas:
    Product:
      type: object
      properties:
        id:
          type: integer
        name:
          type: string
        price:
          type: number
```

<ProgressCheckpoint section="design-first-example" xpReward={4} />

### Custom Operation Filters

```csharp
public class AddResponseHeadersFilter : IOperationFilter
{
    public void Apply(OpenApiOperation operation, OperationFilterContext context)
    {
        operation.Responses["200"].Headers = new Dictionary<string, OpenApiHeader>
        {
            { "X-Rate-Limit", new OpenApiHeader { Schema = new OpenApiSchema { Type = "integer" } } }
        };
    }
}

builder.Services.AddSwaggerGen(options =>
{
    options.OperationFilter<AddResponseHeadersFilter>();
});
```

<ProgressCheckpoint section="operation-filters" xpReward={3} />

<ProgressCheckpoint section="document-filters" xpReward={2} />

<KeyConcept title="Production OpenAPI Checklist">
  1. Enable XML comments for rich documentation
  2. Add authentication configuration
  3. Use ProducesResponseType attributes
  4. Provide example values in DTOs
  5. Generate client code in CI/CD
  6. Version your API and document in Swagger
  7. Exclude internal endpoints from public docs
</KeyConcept>

<ProgressCheckpoint section="customization" xpReward={10} />
