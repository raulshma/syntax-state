# Advanced REST: Richardson Maturity Model & HATEOAS

While many APIs claim to be "RESTful," true REST involves more than just using GET and POST. Let's explore the advanced concepts that separate a basic "Web API" from a truly "RESTful API."

<InfoBox type="info">
  Most production APIs operate at Level 2 of the Richardson Maturity Model. Level 3 (HATEOAS) is the theoretical ideal but adds significant complexity. Understanding all levels helps you make informed architectural decisions.
</InfoBox>

## Section 1: Richardson Maturity Model - Levels 0 & 1

Leonard Richardson analyzed web service designs and created a maturity model with 4 levels. Each level builds on the previous one.

### Level 0: The Swamp of POX (Plain Old XML) Ô∏è

**Characteristics:**
- Single endpoint for everything
- HTTP used only as a transport mechanism
- All operations use POST
- No use of HTTP features (methods, status codes, headers)

```csharp
// Everything goes to one endpoint
[HttpPost("api")]
public IActionResult HandleRequest([FromBody] XmlCommand command)
{
    switch (command.Action)
    {
        case "GetUser":
            return Ok(GetUser(command.UserId));
        case "CreateUser":
            return Ok(CreateUser(command.UserData));
        case "DeleteUser":
            return Ok(DeleteUser(command.UserId));
        default:
            return BadRequest("Unknown action");
    }
}
```

**Problems:**
- No caching (everything is POST)
- No standard error handling
- Difficult to understand and document
- Can't leverage HTTP infrastructure (proxies, CDNs)

<ProgressCheckpoint section="level-0" xpReward={10} />

### Level 1: Resources 

**Characteristics:**
- Multiple endpoints (one per resource type)
- Still mostly uses POST
- Beginning to organize around resources

```csharp
[HttpPost("api/users")]
public IActionResult HandleUserRequest([FromBody] UserCommand command)
{
    switch (command.Action)
    {
        case "get":
            return Ok(GetUser(command.Id));
        case "create":
            return Ok(CreateUser(command.Data));
        case "delete":
            return Ok(DeleteUser(command.Id));
    }
}
```

**Improvements:**
- Better organization
- Easier to understand what resources exist
- Can apply different security rules per resource

**Still Missing:**
- Proper HTTP method usage
- Standard status codes
- Caching capabilities

<ProgressCheckpoint section="level-1" xpReward={10} />

---

## Section 2: Level 2 - HTTP Verbs (Industry Standard)

### Level 2: HTTP Verbs 

**This is where most modern "REST" APIs operate!**

**Characteristics:**
- Uses HTTP methods correctly (GET, POST, PUT, DELETE)
- Returns appropriate status codes (200, 201, 404, 500)
- Leverages HTTP features (caching, idempotency)

```csharp
[ApiController]
[Route("api/users")]
public class UsersController : ControllerBase
{
    [HttpGet("{id}")]
    [ProducesResponseType(StatusCodes.Status200OK)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    public IActionResult GetUser(int id)
    {
        var user = _repo.GetUser(id);
        if (user == null)
            return NotFound();
        
        return Ok(user);
    }

    [HttpPost]
    [ProducesResponseType(StatusCodes.Status201Created)]
    [ProducesResponseType(StatusCodes.Status400BadRequest)]
    public IActionResult CreateUser([FromBody] CreateUserDto dto)
    {
        if (!ModelState.IsValid)
            return BadRequest(ModelState);
        
        var user = _repo.CreateUser(dto);
        return CreatedAtAction(nameof(GetUser), new { id = user.Id }, user);
    }

    [HttpPut("{id}")]
    [ProducesResponseType(StatusCodes.Status204NoContent)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    public IActionResult UpdateUser(int id, [FromBody] UpdateUserDto dto)
    {
        if (!_repo.UserExists(id))
            return NotFound();
        
        _repo.UpdateUser(id, dto);
        return NoContent();
    }

    [HttpDelete("{id}")]
    [ProducesResponseType(StatusCodes.Status204NoContent)]
    public IActionResult DeleteUser(int id)
    {
        if (!_repo.UserExists(id))
            return NotFound();
        
        _repo.DeleteUser(id);
        return NoContent();
    }
}
```

**Request Examples:**
```http
GET    /api/users/123      ‚Üí 200 OK (with user data)
POST   /api/users          ‚Üí 201 Created
PUT    /api/users/123      ‚Üí 204 No Content
DELETE /api/users/123      ‚Üí 204 No Content
GET    /api/users/999      ‚Üí 404 Not Found
```

**Benefits:**
- **Caching:** GET requests can be cached
- **Idempotency:** PUT and DELETE are safe to retry
- **Standard Semantics:** Everyone knows what GET means
- **Tooling Support:** Browsers, proxies, CDNs understand HTTP methods

<ProgressCheckpoint section="level-2" xpReward={10} />

---

## Section 3: Level 3 - HATEOAS (Hypermedia)

### HATEOAS = Hypermedia As The Engine Of Application State 

**The Principle:** The server tells the client what actions are available through hypermedia links.

**The Vision:** Clients don't hardcode URLs or business logic. They discover available actions from the server's responses.

### Non-HATEOAS Response (Level 2)

```json
{
  "id": 1,
  "name": "Wireless Headphones",
  "price": 199.99,
  "stock": 5,
  "status": "available"
}
```

Client must hardcode URLs and business logic - changes require updating all clients.

### HATEOAS Response (Level 3)

```json
{
  "id": 1,
  "name": "Wireless Headphones",
  "price": 199.99,
  "stock": 5,
  "_links": {
    "self": { "href": "/api/products/1", "method": "GET" },
    "add-to-cart": { "href": "/api/cart/items", "method": "POST" },
    "reviews": { "href": "/api/products/1/reviews", "method": "GET" }
  }
}
```

**If out of stock, different links appear:**
```json
{
  "id": 2,
  "name": "Gaming Mouse",
  "stock": 0,
  "_links": {
    "self": { "href": "/api/products/2", "method": "GET" },
    "notify-when-available": { "href": "/api/products/2/notifications", "method": "POST" }
  }
}
```

<ProgressCheckpoint section="hateoas-concept" xpReward={10} />

### Implementing HATEOAS in ASP.NET Core Ô∏è

```csharp
public class Link
{
    public string Href { get; set; }
    public string Rel { get; set; }
    public string Method { get; set; }
}

public class ProductResource
{
    public int Id { get; set; }
    public string Name { get; set; }
    public decimal Price { get; set; }
    public List<Link> Links { get; set; } = new();
}

[HttpGet("{id}")]
public IActionResult GetProduct(int id)
{
    var product = _repo.GetProduct(id);
    if (product == null)
        return NotFound();

    var resource = new ProductResource
    {
        Id = product.Id,
        Name = product.Name,
        Price = product.Price
    };

    // Self link
    resource.Links.Add(new Link
    {
        Href = Url.Link("GetProduct", new { id }),
        Rel = "self",
        Method = "GET"
    });

    // Conditional links based on business rules
    if (product.Stock > 0)
    {
        resource.Links.Add(new Link
        {
            Href = Url.Link("AddToCart", null),
            Rel = "add-to-cart",
            Method = "POST"
        });
    }

    // Admin-only actions
    if (User.IsInRole("Admin"))
    {
        resource.Links.Add(new Link
        {
            Href = Url.Link("DeleteProduct", new { id }),
            Rel = "delete",
            Method = "DELETE"
        });
    }

    return Ok(resource);
}
```

### The HATEOAS Trade-off ü§î

<KeyConcept title="When to Use Each Level">
  **Level 2 (Most Common):** Internal APIs, mobile apps, microservices - use versioning and OpenAPI docs.
  
  **Level 3 (HATEOAS):** Public APIs with many unknown clients, long-lived APIs (10+ years), when business rules change frequently.
</KeyConcept>

**Industry Reality:** Most successful APIs (GitHub, Stripe, Twitter) operate at Level 2. They use versioning and good documentation instead of HATEOAS. Choose the level that matches your needs, not the theoretical ideal.

<ProgressCheckpoint section="hateoas-implementation" xpReward={10} />
