# REST Principles: The 6 Architectural Constraints

REST (Representational State Transfer) is an architectural style defined by Roy Fielding in his 2000 doctoral dissertation. It's not a protocol or standard - it's a set of **constraints** that, when followed, create scalable, maintainable, and performant web services.

<InfoBox type="info">
  Think of REST constraints like building codes for houses. You can build a house without following them, but following the codes ensures safety, efficiency, and compatibility with utilities.
</InfoBox>

## Section 1: REST Introduction & Client-Server Separation

### What Makes an API "RESTful"? 

If your API follows all six constraints, it's truly "RESTful". Most APIs only follow some constraints - that's okay! Understanding all of them helps you make informed design decisions.

### Constraint 1: Client-Server Separation 

**The Principle:** The client and server are separate entities that communicate only through requests and responses.

**Why It Matters:**
- **Client** handles the user interface and experience
- **Server** handles data storage and business logic
- They can evolve independently without breaking each other

**Real-World Analogy:**
Think of a restaurant. The kitchen (server) can renovate, hire new chefs, or change suppliers without affecting how customers (clients) order food. As long as the menu interface stays consistent, both sides can improve independently.

**Benefits:**
- Frontend teams can redesign the UI without touching backend code
- Backend can optimize databases without affecting mobile apps
- Multiple clients (web, mobile, desktop) can use the same API

<ProgressCheckpoint section="rest-intro" xpReward={3} />

<ProgressCheckpoint section="client-server" xpReward={3} />

---

## Section 2: Cacheability & Uniform Interface

### Constraint 2: Cacheable Responses 

**The Principle:** Responses must explicitly indicate whether they can be cached.

**Why It Matters:**
Caching dramatically improves performance by reusing responses instead of regenerating them.

```csharp
[HttpGet("products/{id}")]
[ResponseCache(Duration = 3600)] // Cache for 1 hour
public IActionResult GetProduct(int id)
{
    var product = _repo.GetProduct(id);
    
    if (product == null)
        return NotFound();
    
    // Response includes: Cache-Control: public, max-age=3600
    return Ok(product);
}
```

**What Happens:**
1. First request: Server processes and returns product data
2. Response header says: "You can cache this for 1 hour"
3. Next 100 requests: Client/CDN returns cached copy
4. After 1 hour: Cache expires, next request hits server again

**When NOT to Cache:**
```csharp
[HttpGet("account/balance")]
[ResponseCache(NoStore = true)] // Never cache sensitive data
public IActionResult GetBalance()
{
    var balance = _repo.GetCurrentBalance(UserId);
    return Ok(balance);
}
```

<ProgressCheckpoint section="cacheable" xpReward={4} />

### Constraint 3: Uniform Interface 

**The Principle:** All APIs should follow consistent, standardized patterns.

This is what makes REST APIs predictable and easy to learn. It has four sub-constraints:

**3.1 Resource Identification:**
```
GET /api/users/123        ‚Üê User with ID 123
GET /api/users/123/orders ‚Üê Orders for user 123
```

**3.2 Resource Manipulation Through Representations:**
```csharp
// Update user by sending new representation
PUT /api/users/123
{
  "name": "John Doe",
  "email": "john@example.com"
}
```

**3.3 Self-Descriptive Messages:**
```http
GET /api/users/123
Accept: application/json
Authorization: Bearer eyJhbGc...

HTTP/1.1 200 OK
Content-Type: application/json
Cache-Control: max-age=3600

{ "id": 123, "name": "John" }
```

**3.4 Hypermedia (HATEOAS):**
```json
{
  "id": 123,
  "name": "John",
  "_links": {
    "self": "/api/users/123",
    "orders": "/api/users/123/orders"
  }
}
```

<ProgressCheckpoint section="uniform-interface" xpReward={5} />

---

## Section 3: Layered System, Code on Demand & REST vs RPC

### Constraint 4: Layered System Ô∏è

**The Principle:** The client cannot tell whether it's connected directly to the end server or to an intermediary.

**The Architecture:**
```
Client ‚Üí CDN ‚Üí Load Balancer ‚Üí API Gateway ‚Üí Web Server ‚Üí Database
```

The client just sees: `https://api.example.com/users`

It doesn't know (and doesn't care) about:
- CDN caching responses
- Load balancer distributing requests
- API gateway handling authentication
- Multiple web servers processing requests

**Benefits:**
- **Security:** Hide internal architecture
- **Scalability:** Add caching layers, load balancers
- **Flexibility:** Change infrastructure without affecting clients

<ProgressCheckpoint section="layered-system" xpReward={5} />

### Constraint 5: Code on Demand (Optional) 

**The Principle:** Servers can extend client functionality by sending executable code.

**Example:** A server could send JavaScript code that the client executes.

**Why It's Optional:**
- Rarely used in modern APIs
- Security concerns with executing server-provided code
- Most clients prefer static, predictable behavior

<InfoBox type="warning">
  This constraint is optional and rarely implemented in modern REST APIs. Most teams skip it entirely.
</InfoBox>

<ProgressCheckpoint section="code-on-demand" xpReward={5} />

### REST vs RPC: Different Philosophies ü§î

<Comparison
  leftTitle="RPC (Remote Procedure Call)"
  rightTitle="REST (Resource-Oriented)"
  leftContent={[
    "Action-oriented (verbs in URLs)",
    "Function calls over network",
    "Example: POST /deleteUser?id=1",
    "Focuses on operations"
  ]}
  rightContent={[
    "Resource-oriented (nouns in URLs)",
    "State manipulation via HTTP methods",
    "Example: DELETE /users/1",
    "Focuses on resources and their state"
  ]}
/>

**Example Comparison:**
```
RPC Style:
POST /api/createUser
POST /api/updateUser
POST /api/deleteUser

REST Style:
POST   /api/users      (create)
PUT    /api/users/1    (update)
DELETE /api/users/1    (delete)
```

<ProgressCheckpoint section="constraints" xpReward={5} />
