# API Versioning: Don't Break Your Users' Apps!

Imagine you release a popular video game. Millions of people are playing it. One day, you decide to "improve" the controls: the "X" button no longer makes you jump - now it quits the game!

**Result:**  Everyone gets angry, apps break, and users leave.

## Section 1: The API Contract 

An API is a **contract** (promise) between you and everyone using it.

**The Promise:**
```
"If you call GET /api/users/123, 
I will return a user object with these fields:
- id (number)
- name (string)
- email (string)"
```

**Breaking the Promise (Bad!):**
```
"Actually, I changed my mind. 
Now 'name' is called 'fullName' 
and I added a required 'phoneNumber' field."
```

**What Happens:**
- Mobile apps crash (looking for 'name' field that doesn't exist)
- Websites show errors
- Integrations break
- Users get angry

<InfoBox type="warning">
  **Breaking Change:** Any change that makes existing client code stop working. Examples: renaming fields, removing endpoints, changing data types, adding required parameters.
</InfoBox>

<ProgressCheckpoint section="api-contract" xpReward={7} />

---

## Section 2: The Solution - Versioning 

Instead of changing the existing "game," you release a **sequel**!

**Version 1 (Original API):**
```
GET /api/v1/users/123
{
  "id": 123,
  "name": "John Doe",
  "email": "john@example.com"
}
```

**Version 2 (New API):**
```
GET /api/v2/users/123
{
  "id": 123,
  "fullName": "John Doe",
  "email": "john@example.com",
  "phoneNumber": "+1234567890"
}
```

**Key Point:** Both work! Old apps use v1, new apps use v2. Nobody breaks!

<ProgressCheckpoint section="versioning-solution" xpReward={6} />


### URL Versioning 

The most common way to version APIs is to put the version number in the URL:

```
https://api.twitter.com/1.1/statuses/home_timeline
https://api.twitter.com/2/tweets

https://api.stripe.com/v1/charges
https://api.stripe.com/v1/customers
```

<InfoBox type="success">
  **Why This Works:** Each version is a completely separate path. Old apps keep using `/v1/`, new apps use `/v2/`. No conflicts!
</InfoBox>

<ProgressCheckpoint section="url-versioning" xpReward={7} />

---

## Section 3: When to Version & Real-World Examples 

### Real-World Example: Adding Features

**Version 1 (Initial Release):**
```json
GET /api/v1/recipes/42
{
  "id": 42,
  "title": "Chocolate Cake",
  "ingredients": ["flour", "sugar", "cocoa"]
}
```

**Version 2 (New Features):**
```json
GET /api/v2/recipes/42
{
  "id": 42,
  "title": "Chocolate Cake",
  "cookingTime": 45,
  "difficulty": "medium",
  "ingredients": ["flour", "sugar", "cocoa"]
}
```

**Meanwhile, v1 still works exactly as before!**

<ProgressCheckpoint section="real-world-example" xpReward={5} />

### When Do You Need a New Version? ðŸ¤”

** Create a New Version When:**
- Removing fields
- Renaming fields (`name` â†’ `fullName`)
- Changing data types (`"19.99"` â†’ `19.99`)
- Changing behavior

** DON'T Need New Version When:**
- Adding optional fields
- Adding new endpoints
- Bug fixes

<InfoBox type="tip">
  **Rule of Thumb:** If existing client code might break, you need a new version. If existing code keeps working, you don't!
</InfoBox>

<Quiz
  question="Why do we version APIs?"
  options={[
    "To make URLs look professional",
    "To prevent breaking changes for existing users",
    "To increase server speed",
    "It is required by law"
  ]}
  correctAnswer={1}
  explanation="Versioning allows us to introduce changes without breaking existing applications."
/>

<Quiz
  question="Which change requires a new API version?"
  options={[
    "Adding a new optional field",
    "Renaming 'name' to 'fullName'",
    "Fixing a bug",
    "Adding a new endpoint"
  ]}
  correctAnswer={1}
  explanation="Renaming a field is a breaking change because existing clients expect the old field name."
/>

<ProgressCheckpoint section="when-to-version" xpReward={5} />
