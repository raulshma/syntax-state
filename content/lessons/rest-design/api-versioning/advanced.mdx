# Advanced API Versioning: Deprecation, Migration, and Enterprise Patterns

Managing API versions in production requires sophisticated strategies for deprecation, migration, and long-term maintenance.

## Section 1: Version Deprecation Strategy 

### Marking Versions as Deprecated

```csharp
[ApiController]
[Route("api/v{version:apiVersion}/[controller]")]
[ApiVersion("1.0", Deprecated = true)]  // Mark as deprecated
[ApiVersion("2.0")]
[ApiVersion("3.0")]
public class UsersController : ControllerBase
{
    [HttpGet]
    [MapToApiVersion("1.0")]
    public IActionResult GetUsersV1()
    {
        Response.Headers.Add("X-API-Deprecated", "true");
        Response.Headers.Add("X-API-Sunset-Date", "2026-06-01");
        Response.Headers.Add("X-API-Deprecation-Info", 
            "https://docs.myapi.com/migration/v1-to-v2");
        
        return Ok(new[] { new { Id = 1, Name = "John" } });
    }
}
```

### Deprecation Timeline (Industry Standard: 12-18 Months)

```
Month 0:  Release v2, announce v1 deprecation
Month 3:  Warning phase - email users still on v1
Month 6:  Aggressive warnings, reduce rate limits for v1
Month 12: Final warning, set sunset date
Month 18: v1 returns 410 Gone
```

### Implementing Sunset Responses

```csharp
public class ApiVersionSunsetMiddleware
{
    private readonly Dictionary<string, DateTime> _sunsetDates = new()
    {
        { "1.0", new DateTime(2026, 6, 1) }
    };

    public async Task InvokeAsync(HttpContext context, RequestDelegate next)
    {
        var version = context.GetRequestedApiVersion();
        
        if (version != null && _sunsetDates.TryGetValue(version.ToString(), out var sunsetDate))
        {
            if (DateTime.UtcNow >= sunsetDate)
            {
                context.Response.StatusCode = 410; // Gone
                await context.Response.WriteAsJsonAsync(new
                {
                    error = "API version no longer supported",
                    migrationGuide = "https://docs.myapi.com/migration/v1-to-v2"
                });
                return;
            }
            
            context.Response.Headers.Add("Sunset", sunsetDate.ToString("R"));
        }
        
        await next(context);
    }
}
```

<ProgressCheckpoint section="api-contract" xpReward={15} />

---

## Section 2: Migration Patterns 

### Adapter Pattern - Don't Duplicate Business Logic

```csharp
// Domain model (version-agnostic)
public class User
{
    public int Id { get; set; }
    public string FirstName { get; set; }
    public string LastName { get; set; }
    public string Email { get; set; }
}

// V1 DTO
public class UserV1Dto
{
    public int Id { get; set; }
    public string Name { get; set; }  // Combined name
}

// V2 DTO
public class UserV2Dto
{
    public int Id { get; set; }
    public string FirstName { get; set; }
    public string LastName { get; set; }
    public string Email { get; set; }
}

// Adapters
public static class UserAdapters
{
    public static UserV1Dto ToV1(User user) => new()
    {
        Id = user.Id,
        Name = $"{user.FirstName} {user.LastName}"
    };
    
    public static UserV2Dto ToV2(User user) => new()
    {
        Id = user.Id,
        FirstName = user.FirstName,
        LastName = user.LastName,
        Email = user.Email
    };
}
```


### Controller Using Adapters

```csharp
[ApiController]
[Route("api/v{version:apiVersion}/[controller]")]
public class UsersController : ControllerBase
{
    private readonly IUserService _userService;
    
    [HttpGet("{id}")]
    [MapToApiVersion("1.0")]
    public IActionResult GetUserV1(int id)
    {
        var user = _userService.GetById(id);  // Single source of truth
        return Ok(UserAdapters.ToV1(user));
    }
    
    [HttpGet("{id}")]
    [MapToApiVersion("2.0")]
    public IActionResult GetUserV2(int id)
    {
        var user = _userService.GetById(id);  // Same business logic
        return Ok(UserAdapters.ToV2(user));
    }
}
```

<ProgressCheckpoint section="versioning-solution" xpReward={15} />

### Feature Flags for Gradual Rollout

```csharp
public class FeatureFlagVersioningMiddleware
{
    public async Task InvokeAsync(HttpContext context, RequestDelegate next)
    {
        var version = context.GetRequestedApiVersion();
        var userId = context.User.GetUserId();
        
        if (version?.MajorVersion == 2)
        {
            var hasV2Access = await _featureFlags.IsEnabledAsync("api-v2", userId);
            
            if (!hasV2Access)
            {
                context.Response.StatusCode = 403;
                await context.Response.WriteAsJsonAsync(new
                {
                    error = "API v2 is currently in beta",
                    message = "Contact support to join the beta program"
                });
                return;
            }
        }
        
        await next(context);
    }
}
```

<ProgressCheckpoint section="url-versioning" xpReward={10} />

---

## Section 3: Monitoring & Golden Rules 

### Track Version Usage

```csharp
public class ApiVersionTelemetryMiddleware
{
    public async Task InvokeAsync(HttpContext context, RequestDelegate next)
    {
        var version = context.GetRequestedApiVersion();
        
        _logger.LogInformation(
            "API Request: Version={Version}, Endpoint={Endpoint}",
            version,
            context.GetEndpoint()?.DisplayName
        );
        
        _metrics.IncrementCounter("api_requests_total", new Dictionary<string, string>
        {
            { "version", version?.ToString() ?? "unspecified" }
        });
        
        await next(context);
    }
}
```

### Dashboard Queries

```sql
-- Users still on v1
SELECT user_id, COUNT(*) as request_count
FROM api_logs
WHERE version = '1.0' AND timestamp > NOW() - INTERVAL '7 days'
GROUP BY user_id;

-- Version adoption over time
SELECT DATE(timestamp), version, COUNT(*)
FROM api_logs
WHERE timestamp > NOW() - INTERVAL '30 days'
GROUP BY DATE(timestamp), version;
```

<ProgressCheckpoint section="real-world-example" xpReward={10} />

### The Golden Rules of API Versioning 

<KeyConcept title="Never Break the Contract">
  Once an API version is public, **NEVER** change its behavior. If you need different behavior, create a new version.
</KeyConcept>

**Rule 1: Immutability**
```csharp
❌ v1 initially returned { "name": "John" }
   Later changed to { "fullName": "John" }  ← BREAKS CLIENTS!

✅ v1 always returns { "name": "John" }
   v2 returns { "fullName": "John" }
```

**Rule 2: Backward Compatibility**
-  Safe: Adding optional fields, new endpoints, bug fixes
-  Breaking: Removing/renaming fields, changing types, changing behavior

**Rule 3: Support Multiple Versions**
```csharp
✅ v1 (stable) + v2 (current)
✅ v2 (stable) + v3 (current) + v1 (deprecated)
❌ Only v2 (breaks v1 users immediately)
```

**Rule 4: Communicate Changes**
- Migration guide
- Deprecation timeline
- Breaking changes list
- Code examples

**Rule 5: Version Everything from Day One**
```csharp
✅ /api/v1/users  (not /api/users)
```

<ProgressCheckpoint section="when-to-version" xpReward={50} />
