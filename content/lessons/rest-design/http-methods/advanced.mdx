# Advanced HTTP: Idempotency, Safety, and Production Patterns

Building production-grade APIs requires deep understanding of HTTP semantics, especially **safety** and **idempotency**.

## Section 1: Safety & Idempotency Fundamentals Ô∏è

### Understanding Safety

**Definition:** A method is **safe** if it doesn't modify server state.

**Safe Methods:** GET, HEAD, OPTIONS, TRACE

```csharp
// ‚úÖ SAFE - Read-only
[HttpGet("users/{id}")]
public IActionResult GetUser(int id)
{
    return Ok(_repository.GetById(id));
}

// ‚ùå UNSAFE - Modifies data (WRONG!)
[HttpGet("users/{id}/activate")]
public IActionResult ActivateUser(int id)
{
    _repository.Activate(id); // DON'T DO THIS!
    return Ok();
}
```

<InfoBox type="warning">
  **Never use GET for operations that modify data!** GET requests can be cached, prefetched, and called by web crawlers.
</InfoBox>

<ProgressCheckpoint section="safety" xpReward={7} />

### Understanding Idempotency 

**Definition:** A method is **idempotent** if making the request N times has the same effect as making it once.

| Method | Idempotent? | Explanation |
|:-------|:------------|:------------|
| **GET** |  YES | Reading data 5 times doesn't change anything |
| **PUT** |  YES | Setting name to "John" 5 times = name is "John" |
| **DELETE** |  YES | Deleting ID 123 five times: first succeeds, rest return 404 |
| **POST** |  NO | Creating an order 5 times creates 5 orders |
| **PATCH** | Ô∏è DEPENDS | `{"age": 30}` is idempotent. `{"age": "+1"}` is NOT |

<ProgressCheckpoint section="idempotency-basics" xpReward={7} />

### The Payment Problem 

**Scenario:** A user clicks "Pay Now" on a mobile app.

```
1. App sends: POST /api/payments
2. Server processes payment and charges card
3. Server sends: 200 OK
4. ‚ö†Ô∏è NETWORK FAILURE - Response lost!
5. App thinks it failed
6. App retries: POST /api/payments
7. Server charges card AGAIN
8. User charged twice! üò±
```

**The Problem:** POST is not idempotent. Each call creates a new payment.

<ProgressCheckpoint section="payment-problem" xpReward={6} />

---

## Section 2: Idempotency Solutions 

### Solution 1: Idempotency Keys

**Pattern:** Client generates a unique key and sends it with the request. Server uses the key to detect duplicates.

```csharp
[HttpPost("payments")]
public async Task<IActionResult> CreatePayment(
    [FromHeader(Name = "Idempotency-Key")] string idempotencyKey,
    [FromBody] PaymentRequest request)
{
    if (string.IsNullOrEmpty(idempotencyKey))
        return BadRequest(new { error = "Idempotency-Key header required" });
    
    // Check if we've seen this key before
    var cached = await _cache.GetAsync<PaymentResponse>($"payment:{idempotencyKey}");
    
    if (cached != null)
        return Ok(cached); // Return cached result
    
    // Process payment
    var result = await _paymentService.ProcessPayment(request);
    
    // Cache the result for 24 hours
    await _cache.SetAsync($"payment:{idempotencyKey}", result, TimeSpan.FromHours(24));
    
    return CreatedAtAction(nameof(GetPayment), new { id = result.Id }, result);
}
```

**Client Usage:**
```javascript
const idempotencyKey = crypto.randomUUID();

await fetch('/api/payments', {
  method: 'POST',
  headers: {
    'Idempotency-Key': idempotencyKey
  },
  body: JSON.stringify(paymentData)
});
```

<ProgressCheckpoint section="idempotency-keys" xpReward={10} />


### Solution 2: Natural Idempotency with PUT 

**Pattern:** Use PUT with a client-generated ID instead of POST.

```csharp
// ‚úÖ Idempotent - calling multiple times with same ID has same effect
[HttpPut("orders/{id}")]
public IActionResult CreateOrUpdateOrder(Guid id, [FromBody] OrderRequest request)
{
    var existingOrder = _repository.GetById(id);
    
    if (existingOrder != null)
        return Ok(existingOrder); // Order already exists
    
    var order = _repository.Create(id, request);
    return CreatedAtAction(nameof(GetOrder), new { id }, order);
}
```

**Client Usage:**
```javascript
const orderId = crypto.randomUUID();
// Safe to call multiple times
await fetch(`/api/orders/${orderId}`, { method: 'PUT', body: orderData });
```

<ProgressCheckpoint section="natural-idempotency" xpReward={5} />

### Advanced Status Codes 

**409 Conflict - Resource State Conflicts:**
```csharp
[HttpPost("orders/{id}/cancel")]
public IActionResult CancelOrder(int id)
{
    var order = _repository.GetById(id);
    
    if (order.Status == OrderStatus.Shipped)
        return Conflict(new { error = "Cannot cancel shipped order" });
    
    order.Status = OrderStatus.Cancelled;
    return NoContent();
}
```

**422 Unprocessable Entity - Semantic Errors:**
```csharp
[HttpPost("transfers")]
public IActionResult CreateTransfer([FromBody] TransferRequest request)
{
    var account = _repository.GetAccount(request.FromAccountId);
    
    if (account.Balance < request.Amount)
        return UnprocessableEntity(new { error = "Insufficient funds" });
    
    _transferService.Process(request);
    return Ok();
}
```

**429 Too Many Requests - Rate Limiting:**
```csharp
context.Response.StatusCode = 429;
context.Response.Headers["Retry-After"] = "60";
await context.Response.WriteAsJsonAsync(new { error = "Rate limit exceeded" });
```

<ProgressCheckpoint section="advanced-status-codes" xpReward={5} />

---

## Section 3: ETags & Content Negotiation Ô∏è

### ETags for Optimistic Locking

An ETag (Entity Tag) is a version identifier for a resource. It changes when the resource changes.

```csharp
[HttpGet("users/{id}")]
public IActionResult GetUser(int id)
{
    var user = _repository.GetById(id);
    if (user == null) return NotFound();
    
    var etag = $"\"{user.Version}\"";
    Response.Headers.ETag = etag;
    
    // Check If-None-Match header (for caching)
    if (Request.Headers.IfNoneMatch == etag)
        return StatusCode(304); // Not Modified
    
    return Ok(user);
}

[HttpPut("users/{id}")]
public IActionResult UpdateUser(int id, [FromBody] UpdateUserDto dto,
    [FromHeader(Name = "If-Match")] string? ifMatch)
{
    var user = _repository.GetById(id);
    if (user == null) return NotFound();
    
    var currentETag = $"\"{user.Version}\"";
    
    if (!string.IsNullOrEmpty(ifMatch) && ifMatch != currentETag)
        return StatusCode(412, new { error = "Resource modified by another user" });
    
    user.Name = dto.Name;
    user.Version++;
    _repository.Save(user);
    
    Response.Headers.ETag = $"\"{user.Version}\"";
    return NoContent();
}
```

<ProgressCheckpoint section="etags" xpReward={5} />

### Content Negotiation 

Support multiple response formats based on client preferences:

```csharp
[HttpGet("users/{id}")]
[Produces("application/json", "application/xml", "text/csv")]
public IActionResult GetUser(int id)
{
    var user = _repository.GetById(id);
    // ASP.NET Core negotiates based on Accept header
    return Ok(user);
}
```

```http
GET /api/users/123
Accept: application/json  ‚Üí Returns JSON

GET /api/users/123
Accept: application/xml   ‚Üí Returns XML
```

<ProgressCheckpoint section="content-negotiation" xpReward={5} />

### Idempotency Decision Tree

```
Is the operation naturally idempotent?
‚îú‚îÄ YES (e.g., "set status to X")
‚îÇ  ‚îî‚îÄ Use PUT or PATCH
‚îî‚îÄ NO (e.g., "create new order")
   ‚îú‚îÄ Can client generate ID?
   ‚îÇ  ‚îî‚îÄ YES ‚Üí Use PUT with client-generated ID
   ‚îî‚îÄ Is it critical (payments, orders)?
      ‚îî‚îÄ YES ‚Üí MUST use Idempotency-Key header
```

<KeyConcept title="Production API Checklist">
  1. Use idempotency keys for critical operations
  2. Implement ETags for optimistic locking
  3. Return appropriate status codes
  4. Never modify data in GET requests
  5. Document retry behavior in your API docs
</KeyConcept>

<ProgressCheckpoint section="idempotency" xpReward={10} />
