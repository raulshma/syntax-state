# Relational Operators

Relational operators test relationships between values — whether a property exists in an object or whether an object is an instance of a class. These operators are essential for type checking and property validation.

---

## Section 1: The in Operator

### The Key Finder 

The `in` operator checks if a property exists in an object:

| Check | Result |
|:------|:-------|
| `"name" in {name: "Alice"}` | `true` |
| `"age" in {name: "Alice"}` | `false` |
| `0 in ["a", "b"]` | `true` (index exists) |

<InfoBox type="info">
The **in operator** returns `true` if the specified property exists in the object or its prototype chain. It checks for property **names** (keys), not values.
</InfoBox>

### Basic Usage

```javascript
// Object properties
const user = { name: "Alice", age: 25 };

"name" in user     // true
"age" in user      // true
"email" in user    // false

// Works with inherited properties too!
"toString" in user  // true (inherited from Object.prototype)

// Array indices (arrays are objects!)
const arr = ["a", "b", "c"];

0 in arr           // true (index 0 exists)
2 in arr           // true (index 2 exists)
3 in arr           // false (index 3 doesn't exist)
"length" in arr    // true (arrays have length property)

// Sparse arrays
const sparse = [1, , 3];  // Hole at index 1
0 in sparse        // true
1 in sparse        // false (hole!)
2 in sparse        // true
```

### in vs hasOwnProperty

```javascript
const child = Object.create({ inherited: true });
child.own = "value";

// in checks prototype chain
"inherited" in child     // true
"own" in child           // true
"toString" in child      // true

// hasOwnProperty only checks own properties
child.hasOwnProperty("inherited")  // false
child.hasOwnProperty("own")        // true
child.hasOwnProperty("toString")   // false

// Modern: Object.hasOwn() (ES2022)
Object.hasOwn(child, "inherited")  // false
Object.hasOwn(child, "own")        // true
```

### Practical Patterns

```javascript
// Check before accessing
function getProperty(obj, key) {
  if (key in obj) {
    return obj[key];
  }
  return "Property not found";
}

// Feature detection
if ("geolocation" in navigator) {
  // Geolocation API is available
}

if ("serviceWorker" in navigator) {
  // Service Workers are supported
}

// Validate required fields
function validateUser(user) {
  const required = ["name", "email", "password"];
  for (const field of required) {
    if (!(field in user)) {
      throw new Error(`Missing required field: ${field}`);
    }
  }
  return true;
}
```

<OperatorVisualizer scenario="relational-in" />

<ProgressCheckpoint section="in-operator" xpReward={20} />

---

## Section 2: The instanceof Operator

### The Family Tree 

`instanceof` checks if an object is an instance of a constructor:

```javascript
// Basic usage
const arr = [1, 2, 3];
const obj = { a: 1 };
const date = new Date();

arr instanceof Array    // true
arr instanceof Object   // true (arrays inherit from Object)
obj instanceof Object   // true
obj instanceof Array    // false
date instanceof Date    // true
date instanceof Object  // true
```

<InfoBox type="info">
The **instanceof operator** tests whether the prototype property of a constructor appears anywhere in the prototype chain of an object. It's used for type checking with constructor functions and classes.
</InfoBox>

### How instanceof Works

```javascript
// instanceof checks the prototype chain
function Animal(name) {
  this.name = name;
}

function Dog(name) {
  Animal.call(this, name);
}
Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;

const buddy = new Dog("Buddy");

buddy instanceof Dog     // true
buddy instanceof Animal  // true
buddy instanceof Object  // true
buddy instanceof Array   // false

// The check: is Constructor.prototype in object's chain?
Dog.prototype.isPrototypeOf(buddy)     // true
Animal.prototype.isPrototypeOf(buddy)  // true
```

### With ES6 Classes

```javascript
class Vehicle {
  constructor(type) {
    this.type = type;
  }
}

class Car extends Vehicle {
  constructor(brand) {
    super("car");
    this.brand = brand;
  }
}

class Motorcycle extends Vehicle {
  constructor(brand) {
    super("motorcycle");
    this.brand = brand;
  }
}

const tesla = new Car("Tesla");
const harley = new Motorcycle("Harley");

tesla instanceof Car        // true
tesla instanceof Vehicle    // true
tesla instanceof Motorcycle // false

harley instanceof Motorcycle // true
harley instanceof Vehicle    // true
harley instanceof Car        // false
```

### instanceof Gotchas

```javascript
// Primitives are NOT instances
"hello" instanceof String   // false
42 instanceof Number        // false
true instanceof Boolean     // false

// But wrapper objects are
new String("hello") instanceof String  // true
new Number(42) instanceof Number       // true

// Cross-frame issues (different global contexts)
// An array from an iframe is NOT instanceof Array in parent!
// Use Array.isArray() instead

// null and undefined
null instanceof Object      // false
undefined instanceof Object // false
```

<ProgressCheckpoint section="instanceof-operator" xpReward={20} />

---

## Section 3: Prototype Chain

### Understanding the Chain

```javascript
// Every object has a prototype chain
const arr = [1, 2, 3];

// arr → Array.prototype → Object.prototype → null

arr instanceof Array   // true (Array.prototype in chain)
arr instanceof Object  // true (Object.prototype in chain)

// Check the chain manually
Object.getPrototypeOf(arr) === Array.prototype  // true
Object.getPrototypeOf(Array.prototype) === Object.prototype  // true
Object.getPrototypeOf(Object.prototype) === null  // true
```

### Custom instanceof Behavior

```javascript
// Symbol.hasInstance lets you customize instanceof
class Even {
  static [Symbol.hasInstance](num) {
    return Number.isInteger(num) && num % 2 === 0;
  }
}

2 instanceof Even   // true
3 instanceof Even   // false
4 instanceof Even   // true
"2" instanceof Even // false (not a number)

// Practical: type checking class
class Stringable {
  static [Symbol.hasInstance](obj) {
    return typeof obj === "string" || 
           (obj && typeof obj.toString === "function");
  }
}

"hello" instanceof Stringable  // true
42 instanceof Stringable       // true (has toString)
null instanceof Stringable     // false
```

### Type Checking Best Practices

```javascript
// For primitives: use typeof
typeof value === "string"
typeof value === "number"
typeof value === "boolean"

// For arrays: use Array.isArray()
Array.isArray([1, 2, 3])  // true (works across frames)

// For null: use strict equality
value === null

// For objects/classes: use instanceof
value instanceof Date
value instanceof RegExp
value instanceof MyClass

// For plain objects: combine checks
function isPlainObject(value) {
  return value !== null && 
         typeof value === "object" && 
         Object.getPrototypeOf(value) === Object.prototype;
}

// Comprehensive type check
function getType(value) {
  if (value === null) return "null";
  if (Array.isArray(value)) return "array";
  if (value instanceof Date) return "date";
  if (value instanceof RegExp) return "regexp";
  return typeof value;
}
```

<ProgressCheckpoint section="prototype-chain" xpReward={15} />

---

## Section 4: Practical Patterns

### Type Guards

```javascript
// Runtime type checking
function processValue(value) {
  if (typeof value === "string") {
    return value.toUpperCase();
  }
  
  if (typeof value === "number") {
    return value * 2;
  }
  
  if (Array.isArray(value)) {
    return value.map(v => processValue(v));
  }
  
  if (value instanceof Date) {
    return value.toISOString();
  }
  
  if (value instanceof Error) {
    return value.message;
  }
  
  return String(value);
}
```

### Duck Typing Alternative

```javascript
// Instead of checking type, check capabilities
function canSwim(animal) {
  return typeof animal.swim === "function";
}

function canFly(animal) {
  return typeof animal.fly === "function";
}

const duck = {
  swim() { console.log("Swimming"); },
  fly() { console.log("Flying"); }
};

const fish = {
  swim() { console.log("Swimming"); }
};

canSwim(duck)  // true
canFly(duck)   // true
canSwim(fish)  // true
canFly(fish)   // false

// "If it walks like a duck and quacks like a duck..."
```

### Validation Utilities

```javascript
// Comprehensive validation helpers
const is = {
  string: v => typeof v === "string",
  number: v => typeof v === "number" && !isNaN(v),
  boolean: v => typeof v === "boolean",
  array: v => Array.isArray(v),
  object: v => v !== null && typeof v === "object" && !Array.isArray(v),
  function: v => typeof v === "function",
  null: v => v === null,
  undefined: v => v === undefined,
  nullish: v => v == null,
  date: v => v instanceof Date && !isNaN(v),
  regexp: v => v instanceof RegExp,
  error: v => v instanceof Error,
  promise: v => v instanceof Promise,
  
  // Property checks
  hasProperty: (obj, prop) => prop in obj,
  hasOwnProperty: (obj, prop) => Object.hasOwn(obj, prop),
};

// Usage
is.string("hello")           // true
is.number(42)                // true
is.array([1, 2, 3])          // true
is.hasProperty({a: 1}, "a")  // true
```

<CodePlayground
  initialCode={`// Relational operators experiments

// in operator
const user = { name: "Alice", age: 25 };
console.log("'name' in user:", "name" in user);
console.log("'email' in user:", "email" in user);
console.log("'toString' in user:", "toString" in user);

// Array indices
const arr = ["a", "b", "c"];
console.log("\\n0 in arr:", 0 in arr);
console.log("5 in arr:", 5 in arr);

// instanceof
console.log("\\n[] instanceof Array:", [] instanceof Array);
console.log("[] instanceof Object:", [] instanceof Object);
console.log("{} instanceof Array:", {} instanceof Array);

// Class hierarchy
class Animal {}
class Dog extends Animal {}
const buddy = new Dog();

console.log("\\nbuddy instanceof Dog:", buddy instanceof Dog);
console.log("buddy instanceof Animal:", buddy instanceof Animal);

// Type checking pattern
function getType(v) {
  if (v === null) return "null";
  if (Array.isArray(v)) return "array";
  return typeof v;
}
console.log("\\ngetType([]):", getType([]));
console.log("getType({}):", getType({}));
console.log("getType(null):", getType(null));`}
  title="Relational Operators Playground"
/>

### Quick Knowledge Check

<Quiz id="in-operator-quiz">
  <Question>What does `"toString" in {}` return?</Question>
  <Answer>false</Answer>
  <Answer correct>true</Answer>
  <Answer>undefined</Answer>
  <Answer>TypeError</Answer>
</Quiz>

<Quiz id="instanceof-primitive-quiz">
  <Question>What does `"hello" instanceof String` return?</Question>
  <Answer>true</Answer>
  <Answer correct>false</Answer>
  <Answer>undefined</Answer>
  <Answer>TypeError</Answer>
</Quiz>

<Quiz id="array-check-quiz">
  <Question>What's the best way to check if a value is an array?</Question>
  <Answer>`typeof value === "array"`</Answer>
  <Answer>`value instanceof Array`</Answer>
  <Answer correct>`Array.isArray(value)`</Answer>
  <Answer>`value.constructor === Array`</Answer>
</Quiz>

### Summary

| Operator | Purpose | Example |
|:---------|:--------|:--------|
| `in` | Check property exists | `"name" in obj` |
| `instanceof` | Check prototype chain | `arr instanceof Array` |
| `hasOwnProperty` | Check own property | `obj.hasOwnProperty("x")` |
| `Object.hasOwn` | Modern own property check | `Object.hasOwn(obj, "x")` |

<KeyConcept title="Congratulations! ">
You've completed the **Expressions and Operators** topic! You now understand:
- **Assignment**: `=`, `+=`, destructuring
- **Comparison**: `===`, `==`, `<`, `>`
- **Arithmetic**: `+`, `-`, `*`, `/`, `%`, `**`
- **Logical**: `&&`, `||`, `!`, `??`
- **Bitwise**: `&`, `|`, `^`, `~`, `<<`, `>>`
- **String**: concatenation, template literals
- **Ternary**: `condition ? a : b`
- **Comma**: `(a, b, c)`
- **Unary**: `typeof`, `delete`, `void`, `+`, `-`
- **Relational**: `in`, `instanceof`

These operators are the building blocks of all JavaScript expressions!
</KeyConcept>

<ProgressCheckpoint section="practical-patterns" xpReward={15} />
